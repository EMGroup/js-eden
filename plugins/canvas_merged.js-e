## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Arc = function(x, y, r, sAngle, eAngle, colour, drawingOptions) {
	this.x = x;
	this.y = y;
	this.r = r;
	this.sAngle = sAngle;
	this.eAngle = eAngle;
	var radiansPerUnit = Math.PI / root.lookup("semicircleAngle").value();
	var sRadians = sAngle * radiansPerUnit;
	var eRadians = eAngle * radiansPerUnit;
	var twoPI = 2 * Math.PI;
	sRadians = sRadians % twoPI;
	if (sRadians < 0) {
		sRadians = sRadians + twoPI;
	}
	eRadians = eRadians % twoPI;
	if (eRadians < 0) {
		eRadians = eRadians + twoPI;
	}
	this.sRadians = sRadians;
	this.eRadians = eRadians;
	
	this.colour = colour
	this.drawingOptions = drawingOptions;
}
}}$;

#! Draw an Arc. See [drawing options](@external CanvasExamples > drawingoptions) to control appearance.
#
# ##Usage Example
#  `Arc(x, y, radius, startAngle, endAngle);`
#  `Arc(x, y, radius, startAngle, endAngle, "red");`
#
# @param x X position
# @param y Y position
# @param r Radius
# @param sAngle Start angle in degrees
# @param eAngle End angle in degrees
# @param [colour] Default is black
# @param [drawingOptions] Drawing Options object
#
#  #canvas #arc #drawingOptions
func Arc {
${{
	var x = arguments[0];
	var y = arguments[1];
	var r = arguments[2];
	var sAngle = arguments[3];
	var eAngle = arguments[4];
	var colour, drawingOptions;
	if (arguments.length == 6 && typeof(arguments[5]) == "object" && !(arguments[5] instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		colour = "black";
		drawingOptions = arguments[5];
	} else {
		colour = arguments[5];
		drawingOptions = arguments[6];
		if (colour === undefined) { colour = "black"; }
	}
	return new Arc(x, y, r, sAngle, eAngle, colour, drawingOptions);
}}$; };
semicircleAngle ~> [Arc];

${{

Arc.prototype.draw = function(context, scale) {
	var anticlockwise;
	if (this.drawingOptions !== undefined && "direction" in this.drawingOptions) {
		var directionName = this.drawingOptions.direction;
		var turnedThroughAC = this.eRadians - this.sRadians;
		if (this.eRadians < this.sRadians) {
			turnedThroughAC = turnedThroughAC + 2 * Math.PI;
		}
		switch (directionName) {
		case "anticlockwise":
		case "acw":
		case "ccw":
			anticlockwise = true;
			break;
		case "auto":
			anticlockwise = this.sAngle < this.eAngle;
			break;
		case "clockwise":
		case "cw":
			anticlockwise = false;
			break;
		case "major":
			anticlockwise = turnedThroughAC > Math.PI;
			break;
		case "minor":
			anticlockwise = turnedThroughAC <= Math.PI;
			break;
		default:
			//Invalid value specified.
			anticlockwise = true;
		}
	} else {
		//Default to "auto" 
		anticlockwise = this.sAngle < this.eAngle;
	}
	var sRadians = this.sRadians;
	var eRadians = this.eRadians;
	if (scale < 0) {
		sRadians = -sRadians;
		eRadians = -eRadians;
		anticlockwise = !anticlockwise;
	}
	var r = this.r - context.lineWidth / 2;
	context.beginPath();
	context.arc(this.x, this.y, r, -sRadians, -eRadians, anticlockwise);
	context.strokeStyle = this.colour;
	context.stroke();

	if (this.drawingOptions !== undefined && this.drawingOptions.arrowhead instanceof Arrowhead) {
		var cos1 = Math.cos(-sRadians);
		var sin1 = Math.sin(-sRadians);
		var cos2 = Math.cos(-eRadians);
		var sin2 = Math.sin(-eRadians);
		var x1 = this.x + r * cos1;
		var y1 = this.y + r * sin1;
		var x2 = this.x + r * cos2;
		var y2 = this.y + r * sin2;
		var gradient1 = -cos1 / sin1;
		var gradient2 = -cos2 / sin2;
		var reverse1, reverse2;
		if (anticlockwise) {
			reverse1 = sRadians <= Math.PI;
			reverse2 = eRadians <= Math.PI;
		} else {
			reverse1 = sRadians > Math.PI;
			reverse2 = eRadians > Math.PI;
		}
		this.drawingOptions.arrowhead.draw(context, scale, x1, y1, gradient1, reverse1, x2, y2,
			gradient2, reverse2);
	}
};

Arc.prototype.toString = function() {
	var s = "Arc(" + Eden.edenCodeForValues(this.x, this.y, this.r, this.sAngle, this.eAngle, this.colour);

	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
}

Arc.prototype.getEdenCode = Arc.prototype.toString;

}}$;

## Copyright (c) 2016, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
	Arrowhead = function(start, end, length, width, filled) {
		this.start = start;
		this.end = end;
		this.length = length;
		this.width = width;
		this.filled = filled;
	};

	Arrowhead.prototype.toString = function () {
		return "Arrowhead(" + Eden.edenCodeForValues(this.start, this.end, this.length, this.width,
			this.filled) + ")";
	};

	Arrowhead.prototype.getEdenCode = Arrowhead.prototype.toString;

	Arrowhead.prototype.draw = function (context, scale, x1, y1, gradient1, reverse1, x2, y2, gradient2, reverse2) {
		var invGradient, len1, len2, len3, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y;
		var lineWidth = context.lineWidth;
		var adjustment = lineWidth / 4;
		var filled = this.filled;

		var width = this.width;
		var length = this.length;

		if (length === undefined) {
			if (lineWidth <= 4) {
				length = 10 / scale;
			} else {
				length = lineWidth * 2.5 / scale;
			}
		} else {
			length = length / scale;
		}
		if (width === undefined) {
			width = length / 2;
		} else {
			width = (width / 2) / scale;
		}

		context.fillStyle = context.strokeStyle;

		if (this.start) {
			invGradient = - 1 / gradient1;
			if ((reverse1 && invGradient == Infinity) || (!reverse1 && invGradient == -Infinity)) {
				//Horizontal left
				p1x = x1 + length;
				p1y = y1 - width;
				p2x = p1x;
				p2y = y1 + width;
				p3x = x1 + adjustment;
				p3y = y1;
			} else if (gradient1 == 0) {
				//Horizontal right
				p1x = x1 - length;
				p1y = y1 - width;
				p2x = p1x;
				p2y = y1 + width;
				p3x = x1 - adjustment;
				p3y = y1;
			} else if ((reverse1 && gradient1 == -Infinity) || (!reverse1 && gradient1 == Infinity)) {
				//Vertical upward
				p1x = x1 - width;
				p1y = y1 + length;
				p2x = x1 + width;
				p2y = p1y;
				p3x = x1;
				p3y = y1 + adjustment;
			} else if (gradient1 == Infinity || gradient1 == -Infinity) {
				//Vertical downward
				p1x = x1 - width;
				p1y = y1 - length;
				p2x = x1 + width;
				p2y = p1y;
				p3x = x1;
				p3y = y1 - adjustment;
			} else {
				len1 = Math.sqrt(length * length / (1 + gradient1 * gradient1));
				if (reverse1) {
					len1 = -len1;
				}
				p0x = x1 + len1;
				p0y = y1 + len1 * gradient1;
				len2 = Math.sqrt(width * width / (1 + invGradient * invGradient));
				p1x = p0x - len2;
				p1y = p0y - len2 * invGradient;
				p2x = p0x + len2;
				p2y = p0y + len2 * invGradient;
				len3 = Math.sqrt(adjustment * adjustment / (1 + gradient1 * gradient1));
				p3x = x1 - len3;
				p3y = y1 - len3 * gradient1
			}

			context.beginPath();
			context.moveTo(p1x, p1y);
			context.lineTo(p3x, p3y);
			context.lineTo(p2x, p2y);
			if (filled) {
				context.closePath();
				context.fill();
			}
			context.stroke();
		}

		if (this.end) {
			invGradient = - 1 / gradient2;
			if ((reverse2 && invGradient == -Infinity) || (!reverse2 && invGradient == Infinity)) {
				//Horizontal left
				p1x = x2 + length;
				p1y = y2 - width;
				p2x = p1x;
				p2y = y2 + width;
				p3x = x2 + adjustment;
				p3y = y2;
			} else if (gradient2 == 0) {
				//Horizontal right
				p1x = x2 - length;
				p1y = y2 - width;
				p2x = p1x;
				p2y = y2 + width;
				p3x = x2 - adjustment;
				p3y = y2;
			} else if ((reverse2 && gradient2 == Infinity) || (!reverse2 && gradient2 == -Infinity)) {
				//Vertical upward
				p1x = x2 - width;
				p1y = y2 + length;
				p2x = x2 + width;
				p2y = p1y;
				p3x = x2;
				p3y = y2 + adjustment;
			} else if (gradient2 == Infinity || gradient2 == -Infinity) {
				//Vertical downward
				p1x = x2 - width;
				p1y = y2 - length;
				p2x = x2 + width;
				p2y = p1y;
				p3x = x2;
				p3y = y2 - adjustment;
			} else {
				len1 = Math.sqrt(length * length / (1 + gradient2 * gradient2));
				if (reverse2) {
					len1 = -len1;
				}
				p0x = x2 - len1;
				p0y = y2 - len1 * gradient2;
				len2 = Math.sqrt(width * width / (1 + invGradient * invGradient));
				p1x = p0x - len2;
				p1y = p0y - len2 * invGradient;
				p2x = p0x + len2;
				p2y = p0y + len2 * invGradient;
				len3 = Math.sqrt(adjustment * adjustment / (1 + gradient2 * gradient2));
				p3x = x2 - len3;
				p3y = y2 - len3 * gradient2
			}

			context.beginPath();
			context.moveTo(p1x, p1y);
			context.lineTo(p3x, p3y);
			context.lineTo(p2x, p2y);
			if (filled) {
				context.closePath();
				context.fill();
			}
			context.stroke();
		}
	};

}}$;

#! Create an Arrowhead line.
# @param start Whether to draw the arrowhead at the start
# @param end Whether to draw the arrowhead at the end
# @param length Length of the arrowhead
# @param width Width of the arrowhead. IF undefined, a proportional value is automatically chosen.
# @param [filled] Whether to fill the arrowhead or just draw an outline. Defaults to true.
# 
#  #canvas #arrow #arrowhead #shape #arrow #library #draw
func Arrowhead {
	${{
		var argsProcessed;
		var numArgs = arguments.length;
		var arg = arguments[0];
		var argType = typeof(arg);

		var start, end, length, width, filled;

		if ((argType == "boolean" && numArgs >= 2 &&
		 (typeof(arguments[1]) == "boolean" || arguments[1] === undefined)) ||
		 numArgs == 5
		) {
			start = arg;
			end = arguments[1];
			argsProcessed = 2;
			arg = arguments[2];
			argType = typeof(arg);
		} else {
			start = false;
			end = true;
			argsProcessed = 0;
		}

		if (argType == "number" || arg === undefined) {
			length = arg;
			argsProcessed++;
			arg = arguments[argsProcessed];
			argType = typeof(arg);
		}

		if (argType == "number" || arg === undefined) {
			width = length;
			length = arg;
			argsProcessed++;
		}

		if (argsProcessed < numArgs) {
			filled = arguments[argsProcessed];
		}

		if (filled === undefined) {
			filled = true;
		}

		return new Arrowhead(start, end, length, width, filled);
	}}$;
}

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

#! Creates a clickable Button in your canvas. If you give the button a name then you can use observables with that name and _click or _clicked to respond to button presses.
#
# ##Usage Example
#  `Button("mybutton", "Label", x, y);`
#
# @param name Name to be used for the _click and _clicked observable
# @param label Label to be displayed
# @param [imageURL] Image to be displayed on the button
# @param x
# @param y
# @param [width] Default fits the size of the label
# @param [height] Default fits the size of the label
# @param [enabled]
# 
#  #canvas #button
func Button {
${{
	var argsProcessed, arg, argType;
	var name, label, imageURL;
	var nameSpecified = false;
	for (argsProcessed = 0; argsProcessed < 3; argsProcessed++) {
		arg = arguments[argsProcessed];
		if (arg !== undefined && typeof(arg) != "string") {
			break;
		}
	}

	if (argsProcessed == 3) {
		name = arguments[0];
		label = arguments[1];
		imageURL = arguments[2];
		nameSpecified = true;
	} else if (argsProcessed > 0) {
		var str = arguments[argsProcessed - 1];
		var found = false;
		for (var i = 0; i < Button.imageFileSuffixes.length; i++) {
			var filenameSuffix = Button.imageFileSuffixes[i];
			if (str.substr(-filenameSuffix.length) == filenameSuffix) {
				imageURL = str;
				if (argsProcessed == 2) {
					label = arguments[0];
				}
				found = true;
				break;
			}
		}
		if (!found) {
			label = str;
			if (argsProcessed == 2) {
				name = arguments[0];
				nameSpecified = true;
			}
		}
	}
	if (name === undefined) {
		var obsName = root.currentObservableName();
		if (!nameSpecified) {
			name = obsName;
		}
		if (name === undefined) {
			eden.error(new Error("Button: The button defined by observable " + obsName + " must have a name."), "error");
			return undefined;
		}	
	}

	var x = arguments[argsProcessed];
	argsProcessed++;
	var y = arguments[argsProcessed];
	argsProcessed++;
	arg = arguments[argsProcessed];
	argType = typeof(arg);

	var width, minHeight, enabled;

	if (argType == "number") {
		width = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);

		if (argType == "number") {
			minHeight = arg;
			argsProcessed++;
			arg = arguments[argsProcessed];
			argType = typeof(arg);
		}
	}

	if (argType == "boolean") {
		enabled = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);	
	} else {
		enabled = true;
	}

	if (argsProcessed < arguments.length - 2) {
		argsProcessed = arguments.length - 2;
	}

	var fillcolour = arguments[argsProcessed];
	var textcolour = arguments[argsProcessed + 1];
	return new Button(name, label, imageURL, x, y, width, minHeight, enabled, fillcolour, textcolour);
}}$;
}

${{
Button = function (name, label, imageURL, x, y, width, minHeight, enabled, fillcolour, textcolour) {
	this.name = name;
	this.obsName = root.currentObservableName();
	this.label = label;
	this.imageURL = imageURL;
	this.x = x;
	this.y = y;
	this.width = width;
	this.minHeight = minHeight;
	this.enabled = enabled;
	this.fillcolour = fillcolour;
	this.textcolour = textcolour;
};

Button.imageFileSuffixes = [".jpg", ".jpeg", ".png", ".gif", ".svg", ".svgz", ".webp", ".bmp", ".ico"];

Button.prototype.hash = function () {
	return this.name+"$$"+
				this.label+"$$"+
				this.imageURL+"$$"+
				this.x+"$$"+
				this.y+"$$"+
				this.width+"$$"+
				this.minHeight+"$$"+
				this.enabled+"$$"+
				this.fillcolour+"$$"+
				this.textcolour;
};

Button.prototype.draw = function (context) {

	if (this.elements === undefined) {
		var name = this.name;

		var disabled = this.enabled === false? 'disabled="disabled" ' : ' ';
		var inputHtml = '<button ' +
			disabled +
			'class="canvashtml-item" ' +
			'style="';
		if (this.fillcolour !== undefined) {
			inputHtml = inputHtml + 'background-color: ' + this.fillcolour + '; ';
		}
		if (this.textcolour !== undefined) {
			inputHtml = inputHtml + 'color: ' + this.textcolour + '; ';
		}
		if (this.width === undefined) {
			inputHtml = inputHtml + 'max-width: 256px';
		}
		inputHtml = inputHtml + '">';
		if (this.imageURL !== undefined) {
			inputHtml = inputHtml + '<img src="' + this.imageURL + '" style="max-width: 100%"/><br/>';
		}
		if (this.label !== undefined) {
			inputHtml = inputHtml + this.label;
		}
		inputHtml = inputHtml + '</button>';

		var inputJQ = $(inputHtml);
		var clickSym = root.lookup(name + "_click");
		if (clickSym.value() === undefined) {
			//var agent = root.lookup("Button");
			clickSym.assign(false, root.scope, EdenSymbol.hciAgent);
			root.lookup(name + "_clicked").assign(false, root.scope, EdenSymbol.hciAgent);
		}

		inputJQ
		.click(function () {
			root.lookup(name + "_clicked").assign(true, root.scope, EdenSymbol.hciAgent, true);
			root.lookup(name + "_clicked").assign(false, root.scope, EdenSymbol.hciAgent, true);
		})
		.on("mousedown", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseDownZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		})
		.on("mouseup", function () {
			edenUI.plugins.Canvas2D.endClick();
		})
		.on("mouseenter", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		});

		var button = inputJQ.get(0);
		this.elements = [button];

	} else {

		//Case when the user has performed direct assignment to one or more JavaScript properties.
		var button = this.elements[0];
		button.value = this.label;

		if (this.enabled) {
			button.disabled = false;
		} else {
			button.disabled = true;
		}

		var style = button.style;
		var fillcolour = this.fillcolour;
		if (style.backgroundColor != fillcolour) {
			if (fillcolour === undefined) {
				style.backgroundColor = "";
			} else {
				style.backgroundColor = fillcolour;
			}
		}
		var textcolour = this.textcolour;
		if (style.color != textcolour) {
			if (textcolour === undefined) {
				style.color = "";
			} else {
				style.color = textcolour;
			}
		}
	}
};

Button.prototype.scale = function (scale, zoom, origin) {
	var style = this.elements[0].style;
	style.left = Math.round((this.x + origin.x) * scale) + "px";
	style.top =  Math.round((this.y + origin.y) * scale) + "px";
	style.fontSize = zoom + "em";

	if (this.width === undefined) {
		style.width = "";
	} else {
		style.width = Math.round(this.width * scale) + "px";
	}

	if (this.minHeight === undefined) {
		style.minHeight = "";
	} else {
		style.minHeight = Math.ceil(this.minHeight * scale) + "px";
	}
};

Button.prototype.toString = function () {
	var s;
	if (this.name == this.obsName) {
		s = "Button(" + Eden.edenCodeForValues(this.label, this.imageURL, this.x, this.y, this.enabled);
	} else {
		s = "Button(" + Eden.edenCodeForValues(this.name, this.label, this.imageURL, this.x, this.y, this.enabled);
	}
	if (this.fillcolour !== undefined || this.textcolour !== undefined) {
		s = s + ", " + Eden.edenCodeForValues(this.fillcolour, this.textcolour);
	}
	s = s + ")";
	return s;
};

Button.prototype.getEdenCode = Button.prototype.toString;

}}$;

# Copyright (c) 2013, Empirical Modelling Group
# All rights reserved.
#
# See LICENSE.txt


#Initialize observables
mouseButton = "";
mouseButtons = "";
mouseCapture = false;
mouseCaptured = false;
mouseContextMenuEnabled = false;
mouseDoubleClicks = 0;
mouseDown = @;
mouseDownView = @;
mouseDownZone = @;
mouseFollow = false;
mousePosition = @;
mousePressed = false;
mouseUp = @;
mouseWheel = 0;
mouseWheelEnabled = false;
mouseWheelVelocity = 0;
mouseView = @;
mouseX is mousePosition == @? @ : mousePosition["x"];
mouseY is mousePosition == @? @ : mousePosition["y"];
mouseZone = @;
pixel is 1 / view_picture_scale;
touchPanX = 0;
touchPanXSpeed = 0;
touchPinch = 0;
touchPinchEnabled = false;


${{
	root.lookup("mouseCapture").addJSObserver("releaseCapture", function (obs, lock) {
		if (!lock && document.exitPointerLock) {
			document.exitPointerLock();
		}
	});
}}$;

/** 
* Attempts to capture the mouse pointer so the it cannot leave the current canvas window.  This
* allows the mouse to be used as a pure sensor and the mousePosition observable becomes able to take
* on any value, free from the constraints of the size of the window.  Note that this procedure will
* only work if the window has already been in mouse capture mode previously and the user did not
* exit capture mode using the escape key.

* The sequence of events:
* 1) The model sets the mouseCapture observable to true, meaning that mouse capture is permitted.
* 1) The user clicks in the canvas window to initiate capture mode.  The mouseCaptured observable
*     automatically gets set to true.
* 1) Capture mode is ended either by (a) the user pressing the escape key, or, (b) the model
*     setting the mouseCapture observable to false.
* 1) Calling attemptMouseCapture after case (3b) has occurred will succeed in the mouse pointer
*     becoming captured again immediately.  However, if case (3a) occurred then calling
*     attemptMouseCapture won't do anything.  If this situation occurs then the model can still set
*     mouseCapture to true and wait for the user to re-grant permission to capture mouse movements
*     by clicking in the window again.
*
* Note that at the time of writing (5/2/2015) although the underlying API has received the W3C's
* Candidate Recommendation approval it is currently only implemented in recent versions of Chrome.
* Access to mouse capturing capabilities can be restricted based upon a browser preference setting.
* (In Chrome this is under Settings->Advanced settings->Content settings->Mouse cursor.)
*/
proc attemptMouseCapture {
	${{
		var canvasName = root.lookup("mouseView").value();
		if (canvasName !== undefined) {
			canvases[canvasName].requestPointerLock();
		}
	}}$;
}

/**
* Creates a canvas and a triggered procedure so that canvas display is kept in
* sync with the value of a given observable at all times.  The first parameter
* is the name of the observable that provides the list of drawables.  The
* second, optional parameter, is the text to place into the window's title bar.
*
* 
* If three parameters are provided, the first is the viewName, the second is the
* observable that stores the list of drawables. The third parameter is the text to place
* into the window's title bar.
* 
* @param [viewName]
* @param observableName
* @param viewTitle
* 
*/
proc createCanvas {
	para p1, p2, p3;
	auto obsName, viewTitle, viewName;
	auto titleSymName, contentSymName, addJSObserver;
	auto argc;
	argc = ${{ arguments.length }}$;
	viewName = @;
	viewTitle = @;

	if (argc == 1) {
		obsName = p1;
	} else if (argc == 2) {
		obsName = p1;
		viewTitle = p2;
	} else if (argc == 3) {
		viewName = p1;
		obsName = p2;
		viewTitle = p3;
		if (!isString(viewName)) {
			error("createCanvas: The first argument must be a string, not a " // type(viewName));
			return;
		}
	} else {
		error("createCanvas: This procedure requires at least 1 argument and at most 3 arguments.");
		return;
	}

	
	
	if (isPointer(obsName)) {
		obsName = nameof(obsName);
	} else if (!isString(obsName)) {
		error("createCanvas: The observable name must be expressed as a string or a pointer, not a " // type(obsName));
		return;
	}

	if (viewName == @) {
		viewName = obsName;
	}
	
	if (viewTitle != @ && !isString(viewTitle)) {
		error("createCanvas: The window title must be a string, not a " // type(viewTitle));
		return;
	}

	if (`obsName` == @) {
		`obsName` = [];
	}

	createView(viewName, "Canvas2D");
	execute2("view_" // viewName // "_content is " // obsName // ";", "*Default");
	if (viewTitle == @) {
		# don't attempt to make this update by dependency on redefinition of _view_viewName_content.
		# Severe performance problems result.
		viewTitle = "Canvas " // obsName;
	}
	`"view_" // viewName // "_title"` = viewTitle;
}

/**
* Returns a string that can be used as the src attribute for an <img> tag inside the content of a
* HTML view.  The image with the special URL returned by this function is a snapshot of the contents
* of the canvas at the time this function was called.
* Optional parameter can be used to select which canvas should be used to take the snapshot.
* 
* @param [canvasName]
* 
*/
func canvasURL {
	${{
		var canvasName;
		if (arguments.length > 1) {
			eden.error(new Error("canvasURL: This function requires at most one argument."), "error");
			return "";
		} else if (arguments.length == 0) {
			canvasName = "picture";
		} else {
			canvasName = arguments[0];
			if (canvasName === undefined) {
				return "";
			} else if (typeof(canvasName) == "string") {
				if (!(canvasName in canvases)) {
					return "";
				}
			} else {
				eden.error(new Error("canvasURL: The first argument must be a string, not a " + typeof(canvasName)), "error");
				return "";
			}
		}
		
		return canvases[canvasName].toDataURL();
	}}$;
}

/**
* Finds the topmost shape object at a given pair of canvas coordinates.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] Include in the search any shapes that do not have a mouse zone name set (N.B. the default is false!)
*/
func shapeOnTopAt {
	${{
		var target = arguments[0];
		var x, y, testAll;
		if (arguments.length < 2 || arguments.length > 4) {
			eden.error(new Error("shapeOnTopAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
			return undefined;
		}
		if (arguments[1] instanceof Point) {
			x = arguments[1].x;
			y = arguments[1].y;
			testAll = arguments[2];
		} else {
			x = arguments[1];
			y = arguments[2];
			testAll = arguments[3];
		}

		if (target === undefined || x === undefined || y === undefined) {
			return undefined;
		}
		if (target instanceof Symbol) {
			var match = target.name.match(/^\/_view_(.*)_content$/);
			if (match === null) {
				eden.error(new Error("shapeOnTopAt: The first argument must be either a string or a pointer to a _view_xxx_content observable, not " +
					Eden.edenCodeForValue(target)), "error");
				return undefined;
			} else {
				target = match[1];
			}
		} else if (typeof(target) != "string") {
			eden.error(new Error("shapeOnTopAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");		
			return undefined;
		}
		if (typeof(x) != "number") {
			eden.error(new Error("shapeOnTopAt: The x-coordinate must be a number, not a " + typeof(x)), "error");		
			return undefined;
		} else if (typeof(y) != "number") {
			eden.error(new Error("shapeOnTopAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
			return undefined;
		}
		return edenUI.plugins.Canvas2D.findDrawableHit(target, x, y, false, testAll);
	}}$;
}

/**
* Finds the bottommost shape object at a given pair of canvas coordinates.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] Include in the search any shapes that do not have a mouse zone name set (N.B. the default is false!)
*/
func shapeOnBottomAt {
	${{
		var target = arguments[0];
		var x, y, testAll;
		if (arguments.length < 2 || arguments.length > 4) {
			eden.error(new Error("shapeOnBottomAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
			return undefined;
		}
		if (arguments[1] instanceof Point) {
			x = arguments[1].x;
			y = arguments[1].y;
			testAll = arguments[2];
		} else {
			x = arguments[1];
			y = arguments[2];
			testAll = arguments[3];
		}

		if (target === undefined || x === undefined || y === undefined) {
			return undefined;
		}
		if (target instanceof Symbol) {
			var match = target.name.match(/^\/_view_(.*)_content$/);
			if (match === null) {
				eden.error(new Error("shapeOnBottomAt: The first argument must be either a string or a pointer to a _view_xxx_content observable, not " +
					Eden.edenCodeForValue(target)), "error");
				return undefined;
			} else {
				target = match[1];
			}
		} else if (typeof(target) != "string") {
			eden.error(new Error("shapeOnBottomAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");		
			return undefined;
		}
		if (typeof(x) != "number") {
			eden.error(new Error("shapeOnBottomAt: The x-coordinate must be a number, not a " + typeof(x)), "error");		
			return undefined;
		} else if (typeof(y) != "number") {
			eden.error(new Error("shapeOnBottomAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
			return undefined;
		}
		return edenUI.plugins.Canvas2D.findDrawableHit(target, x, y, true, testAll);
	}}$;
}

/**
* Finds the name of the mouse zone of the topmost shape at a given pair of canvas coordinates.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
*/
func zoneOnTopAt {
	auto drawable;
	drawable = apply(shapeOnTopAt, ${{ arguments }}$);
	if (drawable == @) {
		return @;
	} else {
		return drawable["name"];
	}
}

/**
* Finds the name of the mouse zone of the bottommost shape at a given pair of canvas coordinates.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
*/
func zoneOnBottomAt {
	auto drawable;
	drawable = apply(shapeOnBottomAt, ${{ arguments }}$);
	if (drawable == @) {
		return @;
	} else {
		return drawable["name"];
	}
}

/**
* Obtains the observable name associated with a given canvas shape (if there is one).
* @param shape
*/
func observableForShape {
	${{
		var drawable = arguments[0];
		if (drawable === undefined) {
			return undefined;
		} else if ("obsName" in drawable) {
			return drawable["obsName"];
		} else {
			return drawable["name"];
		}
	}}$;
}

/**
* Finds the observable name associated with the topmost shape at a given pair of canvas coordinates (if there is one).
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] Include in the search any shapes that do not have a mouse zone name set (N.B. the default is false!)
*/
func observableOnTopAt {
	auto drawable;
	drawable = apply(shapeOnTopAt, ${{ arguments }}$);
	return observableForShape(drawable);
}

/**
* Finds the observable name associated with the bottommost shape at a given pair of canvas coordinates (if there is one).
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] Include in the search any shapes that do not have a mouse zone name set (N.B. the default is false!)
*/
func observableOnBottomAt {
	auto drawable;
	drawable = apply(shapeOnBottomAt, ${{ arguments }}$);
	return observableForShape(drawable);
}

/**
* Finds all of the shape objects present at a given pair of canvas coordinates and returns them as a list.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] If false then only shapes which have a mouse zone name set are returned (N.B. the default is false!)
*/
func shapesAt {
	${{
		var target = arguments[0];
		var x, y, testAll;
		if (arguments.length < 2 || arguments.length > 4) {
			eden.error(new Error("shapesAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
			return undefined;
		}
		if (arguments[1] instanceof Point) {
			x = arguments[1].x;
			y = arguments[1].y;
			testAll = arguments[2];
		} else {
			x = arguments[1];
			y = arguments[2];
			testAll = arguments[3];
		}

		if (target === undefined || x === undefined || y === undefined) {
			return undefined;
		}
		if (target instanceof Symbol) {
			var match = target.name.match(/^\/_view_(.*)_content$/);
			if (match === null) {
				eden.error(new Error("shapesAt: The first argument must be either a string or a pointer to a _view_xxx_content observable, not " +
					Eden.edenCodeForValue(target)), "error");
				return undefined;
			} else {
				target = match[1];
			}
		} else if (typeof(target) != "string") {
			eden.error(new Error("shapesAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");		
			return undefined;
		}
		if (typeof(x) != "number") {
			eden.error(new Error("shapesAt: The x-coordinate must be a number, not a " + typeof(x)), "error");		
			return undefined;
		} else if (typeof(y) != "number") {
			eden.error(new Error("shapesAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
			return undefined;
		}
		return edenUI.plugins.Canvas2D.findAllDrawablesHit(target, x, y, testAll);
	}}$;
}

/**
* Finds all of the mouse zone names of the shapes intersecting at a given pair of canvas coordinates and returns them as a list.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
*/
func zonesAt {
	auto drawables, zones, i;
	drawables = apply(shapesAt, ${{ arguments }}$);
	zones = [];
	for (i = 1; i <= drawables#; i++) {
		append zones, drawables[i]["name"];
	}
	return zones;
}

/**
* Finds all of observable names associated with shapes intersecting at a given pair of canvas coordinates and returns them as a list.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] If false then only shapes which have a mouse zone name set are considered (N.B. the default is false!)
*/
func observablesAt {
	auto drawables, obsList, obsName, i;
	drawables = apply(shapesAt, ${{ arguments }}$);
	obsList = [];
	for (i = 1; i <= drawables#; i++) {
		obsName = observableForShape(drawables[i]);
		if (obsName != @) {
			append obsList, obsName;
		}
	}
	return obsList;
}


#! A 3D point containing x, y and z. #library
Point3D is ${{ new Point3D }}$ ($1, $2, $3);

Point2D is ${{ new Point }}$ ($1,$2);

RGB is "rgb("//$1//","//$2//","//$3//")";


/* Copyright (c) 2013, Empirical Modelling Group
 * All rights reserved.
 *
 * See LICENSE.txt
 */

#Taints the canvas if the file is located on another domain.

${{
CanvasImage = function (name, dx, dy, dWidth, dHeight, sx1, sy1, sx2, sy2, smoothed, file) {
	this.name = edenUI.plugins.Canvas2D.initZoneFromName(name, "Image");
	this.obsName = root.currentObservableName();

	var temp;
	if (sx2 !== undefined) {
		if (sx1 > sx2) {
			temp = sx1;
			sx1 = sx2;
			sx2 = temp;
		}
		this.sWidth = sx2 - sx1;
	}
	if (sy2 !== undefined) {
		if (sy1 > sy2) {
			temp = sy1;
			sy1 = sy2;
			sy2 = temp;
		}
		this.sHeight = sy2 - sy1;
	}

	this.originalDWidth = dWidth;
	this.originalDHeight = dHeight;
	this.originalSX2 = sx2;
	this.originalSY2 = sy2;
	
	this.dx = dx;
	this.dy = dy;
	this.dWidth = dWidth;
	this.dHeight = dHeight;
	this.sx = sx1;
	this.sy = sy1;
	this.smoothed = smoothed;

	if (CanvasImage.cache[file]) {
		this.image = CanvasImage.cache[file];
		this.loaded = this.image.complete;

		var me = this;

		if (this.loaded) {
			if (me.sWidth === undefined) {
				me.sWidth = me.image.width - me.sx;
			}
			if (me.sHeight === undefined) {
				me.sHeight = me.image.height - me.sy;
			}
			if (me.dWidth === undefined && me.dHeight === undefined) {
				me.dWidth = me.sWidth;
				me.dHeight = me.sHeight;		
			} else if (me.dWidth === undefined) {
				me.dWidth = me.sWidth * me.dHeight / me.sHeight;
			} else if (me.dHeight === undefined) {
				me.dHeight = me.sHeight * me.dWidth / me.sWidth;
			}
		}
	} else {
		this.image = new Image();
		//this.image.setAttribute("crossorigin","anonymous");	
		this.canvasesToRepaint = {};
		this.loaded = false;
	
	 this.texture = undefined;
	
		this.image.onload = function() {
			if (me.sWidth === undefined) {
				me.sWidth = me.image.width - me.sx;
			}
			if (me.sHeight === undefined) {
				me.sHeight = me.image.height - me.sy;
			}
			if (me.dWidth === undefined && me.dHeight === undefined) {
				me.dWidth = me.sWidth;
				me.dHeight = me.sHeight;		
			} else if (me.dWidth === undefined) {
				me.dWidth = me.sWidth * me.dHeight / me.sHeight;
			} else if (me.dHeight === undefined) {
				me.dHeight = me.sHeight * me.dWidth / me.sWidth;
			}

			me.loaded = true;
			for (var viewName in me.canvasesToRepaint) {
				edenUI.plugins.Canvas2D.drawPicture(viewName);
			}
		}
		this.image.src = file;
		CanvasImage.cache[file] = this.image;
	}
};

CanvasImage.cache = {};
}}$;

#! Creates an image element for display on the canvas together with the
# geometric shapes.  Taints the canvas if url is located on another domain.
#
# ##Usage Example
#   `Image(x, y, url);`
#	`Image(x, y, width, height, url);`
#
# ##Examples
# * [Scaling an Image](@external CanvasExamples > scaledimage)
# * [Using OpenClipart](@external CanvasExamples > openclipart)
# * [Rotating an Image](@external CanvasExamples > rotateimage)
# * [Keyframe Animation](@external CanvasExamples > keyframeimage)
# * [Sprites](@external CanvasExamples > sprites)
# * [Upload an Image](@external CanvasExamples > uploadimage)
#
#   @param [name]
#   @param x X-coordinate
#   @param y Y-coordinate
#   @param [width] Width in pixels
#   @param [height] Height in pixels
#   @param [clip_left]
#   @param [clip_top]
#   @param [clip_right]
#   @param [clip_bottom]
#   @param [smoothed]
#   @param url Source file for the image
#
#   #canvas #library #picture #photo #photograph #draw
func Image {
	${{
		var numArgs = arguments.length;
		var argsProcessed;
		var name;
		if (typeof(arguments[0]) == "string") {
			name = arguments[0];
			argsProcessed = 1;
		} else {
			argsProcessed = 0;
		}

		var dx = arguments[argsProcessed];
		argsProcessed++;
		var dy = arguments[argsProcessed];
		argsProcessed++;

		var dWidth, dHeight, sx1 = 0, sy1 = 0, sx2, sy2, smoothed = true, file;

		if (numArgs - 1 > argsProcessed) {
			dWidth = arguments[argsProcessed];
			argsProcessed++;
		}
		if (numArgs - 1 > argsProcessed) {
			dHeight = arguments[argsProcessed];
			argsProcessed++;
		}
		if (numArgs - 1 > argsProcessed) {
			sx1 = arguments[argsProcessed];
			argsProcessed++;
		}
		if (numArgs - 1 > argsProcessed) {
			sy1 = arguments[argsProcessed];
			argsProcessed++;
		}
		if (numArgs - 1 > argsProcessed) {
			sx2 = arguments[argsProcessed];
			argsProcessed++;
		}
		if (numArgs - 1 > argsProcessed) {
			sy2 = arguments[argsProcessed];
			argsProcessed++;
		}
		if (numArgs - 1 > argsProcessed) {
			smoothed = arguments[argsProcessed];
			argsProcessed++;
		}
		file = arguments[numArgs - 1];
		return new CanvasImage(name, dx, dy, dWidth, dHeight, sx1, sy1, sx2, sy2, smoothed, file);
	}}$;
}

${{
function isPowerOf2(value) {
  return (value & (value - 1)) == 0;
};


CanvasImage.prototype.draw = function(context, scale, viewName) {
	if (this.loaded) {

		if (!this.texture) {
			this.texture = context.createTexture();
			context.bindTexture(context.TEXTURE_2D, this.texture);
			context.pixelStorei(context.UNPACK_FLIP_Y_WEBGL, true);
			context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, context.RGBA, context.UNSIGNED_BYTE, this.image);

			if (isPowerOf2(this.image.width) && isPowerOf2(this.image.height)) {
				// the dimensions are power of 2 so generate mips and turn on 
				// tri-linear filtering.
				context.generateMipmap(context.TEXTURE_2D);
				context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.LINEAR_MIPMAP_LINEAR);
			  } else {
				// at least one of the dimensions is not a power of 2 so set the filtering
				// so WebGL will render it.
				context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);
				context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);
				context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.LINEAR);
			  }

			console.log("IMAGE TEXTURE MADE");

			//context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);
			//context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST);
			//context.bindTexture(context.TEXTURE_2D, null);
		} else {
			context.bindTexture(context.TEXTURE_2D, this.texture);
		}

		/*var smoothed = this.smoothed;
		context.mozImageSmoothingEnabled = smoothed;
		context.msImageSmoothingEnabled = smoothed;
		context.imageSmoothingEnabled = smoothed;
		if (scale > 0) {
			context.drawImage(this.image, this.sx, this.sy, this.sWidth, this.sHeight, this.dx, this.dy, this.dWidth, this.dHeight);
		} else {
			if (!this.flippedImage) {
				var buffer = document.createElement("canvas");
				buffer.width = this.dWidth;
				buffer.height = this.dHeight;
				var bufferContext = buffer.getContext("2d");
				bufferContext.scale(1, -1);
				bufferContext.drawImage(this.image, this.sx, this.sy, this.sWidth, this.sHeight, 0, -this.dHeight, this.dWidth, this.dHeight);
				this.flippedImage = buffer;
			}
			context.drawImage(this.flippedImage, this.dx, this.dy - this.dHeight);
		}*/


	} else {
		this.canvasesToRepaint[viewName] = true;
	}
};

CanvasImage.prototype.isHit = function (context, scale, x, y) {
	return x >= this.dx && x < this.dx + this.dWidth && y >= this.dy && y < this.dy + this.dHeight;
}

CanvasImage.prototype.toString = function() {
  return "Image(" +	Eden.edenCodeForValues(this.dx, this.dy, this.originalDWidth,
	this.originalDHeight, this.sx, this.sy, this.originalSX2, this.originalSY2, this.smoothed, this.image.src) + ")";
};

CanvasImage.prototype.getEdenCode = CanvasImage.prototype.toString;

}}$;

## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Checkbox = function (name, label, x, y, tristate, enabled) {
	this.name = name;
	this.obsName = root.currentObservableName();
	this.label = label;
	this.x = x;
	this.y = y;
	this.tristate = tristate;
    this.enabled = enabled;
}

Checkbox.prototype.hash = function () {
	return this.label+"$$"+
				this.name+"$$"+
				this.x+"$$"+
				this.y+"$$"+
				this.tristate+"$$"+
				this.enabled;
};
}}$;

#! Make a clickable checkbox on the canvas. Give it a name and then an observable `name_checked` is set to true of false.
#
# @param [name]
# @param label
# @param x x position
# @param y y position
# @param [tristate] If true, the checkbox will have three states; true, false, undefined. Defaults to false
# @param [enabled] Defaults to true.
#  #canvas #checkbox #tick #box #tickbox #check #form
func Checkbox {
${{
	var argsProcessed;

	var name;
	if (typeof(arguments[1]) == "string" || arguments[1] === undefined) {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("Checkbox: Every checkbox must have a name."), "error");
			return undefined;
		}
	}

	var label;
	if (typeof(arguments[argsProcessed]) == "string" || arguments[argsProcessed] === undefined) {
		label = arguments[argsProcessed];
		argsProcessed++;
	}

	var x = arguments[argsProcessed];
	var y = arguments[argsProcessed + 1];

	var tristate = arguments[argsProcessed + 2];
	if (tristate === undefined) tristate = false;

	var enabled = arguments[argsProcessed + 3];
	if (enabled === undefined) enabled = true;

	return new Checkbox(name, label, x, y, tristate, enabled);
}}$; }

${{

Checkbox.prototype.draw = function(context) {

	if (this.elements === undefined) {
		var me = this;
		var name = this.name;

		var inputJQ = $('<input type="checkbox"/>');
		var inputElement = inputJQ.get(0);
		var element, elementJQ;
		if (this.label === undefined) {
			element = inputElement;
			elementJQ = inputJQ;
		} else {
			var labelJQ = $('<label> ' + this.label + '</label>');
			labelJQ.prepend(inputJQ);
			element = labelJQ.get(0);
			elementJQ = labelJQ;
		}
		element.className = "canvashtml-item";

		inputElement.disabled = (this.enabled === false);
		
		var valueSym = root.lookup(name + "_checked");
		var value = valueSym.value();
		if (value === undefined) {
			if (this.tristate) {
				inputElement.indeterminate = true;
			} else {
				valueSym.assign(false, root.scope, root.lookup("Checkbox"));
			}
		} else {
			inputElement.checked = value;
		}
		valueSym.addJSObserver("updateCheckbox", function (obs, value) {
			var element = me.elements[0];
			if (value === undefined) {
				element.indeterminate = true;
				element.checked = false;
			} else {
				element.indeterminate = false;
				element.checked = (value == true);
			}
		});

		inputJQ.change(function (event) {
			var element = event.target;
			var value;
			if (element.indeterminate) {
				element.indeterminate = false;
				element.checked = true;
				value = true;
			} else if (me.tristate && valueSym.value() === false) {
				element.indeterminate = true;
				element.checked = false;
				value = undefined;
			} else {
				value = element.checked;
			}
			valueSym.assign(value, root.scope, EdenSymbol.hciAgent, true);
		})

		elementJQ.on("mousedown", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseDownZone").assign(undefined, root.scope, EdenSymbol.hciAgent, mouseFollow);
		})
		.on("mouseup", function () {
			edenUI.plugins.Canvas2D.endClick();
		})
		.on("mouseenter", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		});

		this.elements = [element];
	}
};

Checkbox.prototype.scale = function (scale, zoom, origin) {
	var outerElement = this.elements[0];
	var inputElement;
	if (outerElement.tagName.toLowerCase() == "label") {
		inputElement = outerElement.children[0];
	} else {
		inputElement = outerElement;
	}
	var outerStyle = outerElement.style;
	var inputStyle = inputElement.style;

	outerStyle.left = Math.round((this.x + origin.x) * scale) + "px";
	outerStyle.top =  Math.round((this.y + origin.y) * scale) + "px";

	var checkboxSize = Math.round(13 * zoom) + "px";
	inputStyle.width = checkboxSize;
	inputStyle.height = checkboxSize;
};

Checkbox.prototype.toString = function() {
	if (this.name == this.obsName) {
		return "Checkbox(" + Eden.edenCodeForValues(this.x, this.y, this.tristate, this.enabled) + ")";
	} else {
		return "Checkbox(" + Eden.edenCodeForValues(this.name, this.x, this.y, this.tristate, this.enabled) + ")";	
	}
};

Checkbox.prototype.getEdenCode = Checkbox.prototype.toString;

}}$;

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Circle = function(x, y, radius, fillcolour, outlinecolour, drawingOptions) {
	this.x = x;
	this.y = y;
	this.radius = radius;
	if (fillcolour === undefined && outlinecolour === undefined) {
		this.fillcolour = undefined;
		this.outlinecolour = "black";
	} else {
		this.fillcolour = fillcolour;
		this.outlinecolour = outlinecolour;
	}
	this.drawingOptions = drawingOptions;
	this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Circle");
	this.obsName = root.currentObservableName();
}
}}$;

#! Creates a circle. See [drawing options](@external CanvasExamples > drawingoptions) for more styling options.
#
# ##Usage Example
#  `Circle(x, y, radius, "purple");`
#  `Circle(x, y, radius, "green", "red");`
# 
# @param x x position of center of the circle
# @param y y position of center of the circle
# @param radius radius of the circle
# @param [fillColour]
# @param [outlineColour] defaults to black
# @param [drawingOptions] object of drawingOptions
# 
#  #canvas #circle #shape #draw #library
func Circle {
${{
	var x = arguments[0];
	var y = arguments[1];
	var radius = arguments[2];
	var fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 3) {
		fillcolour = arguments[3];
		if (processUpTo == 4) {
			outlinecolour = arguments[4];
		}
	}
	if (fillcolour === undefined && outlinecolour === undefined) {
		outlinecolour = "black";
	}
	return new Circle(x, y, radius, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

Circle.prototype.draw = function (context, scale) {
	if (this.radius > 0) {

		this.tracePath(context, scale);
		if (this.fillcolour !== undefined) {
			edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
			context.fill();
		}
		if (this.outlinecolour !== undefined) {
			context.strokeStyle = this.outlinecolour;
			context.stroke();
		}

	}
};

Circle.prototype.tracePath = function (context, scale) {
	var halfLineWidth;
	if (this.outlinecolour !== undefined) {
		halfLineWidth = context.lineWidth / 2;
	} else {
		halfLineWidth = 0;
	}

	var adjustedRadius;
	if (this.radius <= halfLineWidth) {
		context.lineWidth = this.radius;
		adjustedRadius = this.radius / 2;
	} else {
		adjustedRadius = this.radius - halfLineWidth;
	}
	context.beginPath();
	context.arc(this.x, this.y, adjustedRadius, 0, 2 * Math.PI, false);
	context.closePath();
}

Circle.prototype.isHit = function (context, scale, x, y) {
	this.tracePath(context, scale);
	return context.isPointInPath(x,y);
}

Circle.prototype.toString = function(p) {
	var s = "Circle(" + Eden.edenCodeForValuesP(p, this.x, this.y, this.radius, this.fillcolour, this.outlinecolour);
	
	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
};

Circle.prototype.getEdenCode = Circle.prototype.toString;

Circle.prototype.imageMapArea = function () {
	return "shape=\"circle\" coords=\"" + this.x + "," + this.y + "," + this.radius + "\"";
}

Circle.prototype.centre = function () {
	return new Point(this.x, this.y);
}

}}$;

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Combobox = function (name, suggestions, x, y, width, placeholder, maxlength, enabled) {
	this.name = name;
	this.obsName = root.currentObservableName();
	this.suggestions = suggestions;
	this.x = x;
	this.y = y;
	this.width = width;
	this.placeholder = placeholder;
	this.maxlength = maxlength;
	this.enabled = enabled;
}

Combobox.prototype.hash = function () {
	return this.name+"$$"+
				(Array.isArray(this.suggestions)? this.suggestions.join("$$") : "") +
				this.x+"$$"+
				this.y+"$$"+
				this.width+"$$"+
				this.placeholder+"$$"+
				this.maxlength+"$$"+
				this.enabled;
};

}}$;

/**
 * Creates a Combobox (drop down selection)
 * @param [name] defaults to the observable name
 * @param suggestions list of strings to be suggested
 * @param x
 * @param y
 * @param [width]
 * @param [placeholder] string to display before choice is made. Defaults to observable name.
 * @param [maxlength] Maximum length allowed in input
 * @param [enabled] defaults to true.
 * 
 * #canvas #combobox #input #select
 */

func Combobox { ${{
	var argsProcessed;

	var name;
	if (typeof(arguments[0]) == "string") {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("Combobox: Every combobox must have a name."), "error");
			return undefined;
		}
	}

	var suggestions = arguments[argsProcessed];
	argsProcessed++;
	var x = arguments[argsProcessed];
	argsProcessed++;
	var y = arguments[argsProcessed];
	argsProcessed++;
	var width, placeholder, maxlength;

	var arg = arguments[argsProcessed];
	var argType = typeof(arg);
	if (arg === undefined || argType == "number") {
		width = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}
	if (arg === undefined || argType == "string") {
		placeholder = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}
	if (arg === undefined || argType == "number") {
		maxlength = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
	}
	var enabled = arg;

	return new Combobox(name, suggestions, x, y, width, placeholder, maxlength, enabled);
}}$; }


${{

Combobox.prototype.makeOptionsHTML = function() {
	var html = "";
	for (var i = 0; i < this.suggestions.length; i++) {
		html = html + '\n<option value="' + this.suggestions[i] + '"/>';
	}
	return html;
}

Combobox.prototype.draw = function(context) {
	var input, suggestions;
	var me = this;
	var name = this.name;
	var valueSym = root.lookup(name + '_value');

	if (this.elements === undefined) {

		var disabled = this.enabled === false? 'disabled="disabled"' : '';
		var placeholder = ' placeholder="' + (this.placeholder === undefined? name : this.placeholder) + '"';
		var maxlength = this.maxlength !== undefined? ' maxlength="' + this.maxlength + '"' : '';
		var inputJQ = $('<input type="text" list="combobox-' + name + '" ' + disabled +
			placeholder + maxlength + ' class="canvashtml-item"/>');

		input = inputJQ.get(0);
		var suggestionsJQ = $('<datalist id="combobox-' + this.name + '"></datalist>');
		suggestions = suggestionsJQ.get(0);
		suggestionsJQ.html(this.makeOptionsHTML(this.values));

		var initialValue = valueSym.value();
		if (initialValue !== undefined) {
			input.value = initialValue;
		}
		valueSym.addJSObserver("updateCombobox", function (symbol, value) {
			input.value = value;
		});

		inputJQ.on("input", function(event) {
			valueSym.assign(event.target.value, root.scope, EdenSymbol.hciAgent, true);
		})
		.on("mousedown", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseDownZone").assign(undefined, root.scope, EdenSymbol.hciAgent, mouseFollow);
		})
		.on("mouseup", function () {
			edenUI.plugins.Canvas2D.endClick();
		})
		.on("mouseenter", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		});

		this.elements = [input, suggestions];

	} else {

		//Case when the user has performed direct assignment to one or more JavaScript properties.
		input = this.elements[0];
		suggestions = this.elements[1];
		$(suggestions).html(this.makeOptionsHTML());

		input.value = valueSym.value();

		if (this.enabled === false) { 
			input.disabled = true;
		} else {
			input.disabled = false;
		}

	}
};

Combobox.prototype.scale = function (scale, zoom, origin) {
	var style = this.elements[0].style;
	style.left = Math.round((this.x + origin.x) * scale) + "px";
	style.top =  Math.round((this.y + origin.y) * scale) + "px";
	if (this.width !== undefined) {
		style.width = Math.round(this.width * scale - 6) + "px";
	}
	style.fontSize = zoom + "em";
};

Combobox.prototype.toString = function() {
	if (this.name == this.obsName) {
		return "Combobox(" + Eden.edenCodeForValues(this.suggestions, this.x, this.y, this.enabled) + ")";
	} else {
		return "Combobox(" + Eden.edenCodeForValues(this.name, this.suggestions, this.x, this.y,
			this.maxlength, this.enabled) + ")";
	}
};

Combobox.prototype.getEdenCode = Combobox.prototype.toString;

}}$;

## Copyright (c) 2016, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt
##
## Functions for drawing contour lines (iso-lines).
##

${{
	/**Creates an object that holds the boundaries of a two or three dimensional space in which a
	 * function will be evaluated at various discrete points and used to form a line (or a surface).
	 * If zMin and zMax are both left undefined then the space is two-dimensional, otherwise
	 * it is three-dimensional.
	 */
	window.EuclideanSpace = function (xMin, yMin, zMin, xMax, yMax, zMax) {
		this.xMin = xMin;
		this.yMin = yMin;
		this.zMin = zMin;
		this.xMax = xMax;	
		this.yMax = yMax;
		this.zMax = zMax;
	}

	EuclideanSpace.prototype.toString = function () {
		if (this.zMin === undefined && this.zMax === undefined) {
			return "EuclideanSpace(" + Eden.edenCodeForValues(this.xMin, this.yMin, this.xMax,
				this.yMax) + ")";
		} else {
			return "EuclideanSpace(" + Eden.edenCodeForValues(this.xMin, this.yMin, this.zMin,
				this.xMax, this.yMax, this.zMax) + ")";		
		}
	}

	EuclideanSpace.prototype.getEdenCode = EuclideanSpace.prototype.toString;

	/**Creates an abstract representation of a two-dimensional shape produced by evaluating a
	 * function at discrete points.  The vertices are expressed in an abstract space ranging from
	 * (0, 0) to (numX - 1, numY - 1), where numX and numY are the number of points to evaluate the
	 * function for in each direction.  That is, numX and numY control the image resolution.
	 * @param {TwoDScalarField} field An object that provides the function values (possibly from an
	 * internal cache).
	 * @param {Number} isoValue The threshold value that determines which function values fall
	 * inside the boundary of the shape.
	 * @param {Number} t The time instant at which to evaluate the function.  May be omitted if the
	 * function is time invariant.
	 */
	window.ContourData = function (field, isoValue, t) {
		this.field = field;
		this.isoValue = isoValue;
		this.t = t;
		if (field instanceof TwoDScalarField) {
			//Compute and store vertices, ready to be plotted later (after simple translation and scaling).
			var fieldValues = field.getValues(isoValue, t);
			this.paths = this.computePaths(fieldValues);
		}
	}

	/**Translates and scales the vertices from the abstract shape to fit the location and dimensions
	 * of the output space on the canvas.
	 * @return {Array<Array<Point>>} An array of paths, each path represented as an array of Points.
	 */
	ContourData.prototype.scalePaths = function (x, y, width, height, scale, lineWidth) {
		var paths = this.paths;
		var halfLineWidth = lineWidth / 2;
		x = x + halfLineWidth;
		y = y + halfLineWidth;
		if (this.paths !== undefined) {
			var scaledPaths = new Array(paths.length);
			/* If the points are connected with straight lines then the nature of the algorithm
			 * prevents the vertices from being less than 0.5 units away from the edge of the space,
			 * except as a result of the linear interpolation post processing step, which we decide
			 * not to apply to the edge points.  This decision means that if a value above the iso
			 * threshold is yielded when applying the function to a point on the edge of the input
			 * space then the perimeter of the shape also extends hard up the edge of the visual
			 * space.  From this idea we get the values 2 and 0.5 below.
			 */
			var cellRenderWidth = (width - (lineWidth + 1) / scale) / (this.field.numX - 2);
			var cellRenderHeight = (height - (lineWidth + 1) / scale) / (this.field.numY - 2);
			for (var i = 0; i < paths.length; i++) {
				var path = paths[i];
				var scaledPath = new Array(path.length);
				for (var j = 0; j < path.length; j++) {
					var p = path[j];
					var sx = Math.round((x + (p.x - 0.5) * cellRenderWidth) * scale) / scale;
					var sy = Math.round((y + (p.y - 0.5) * cellRenderHeight) * scale) / scale;
					scaledPath[j] = new Point(sx, sy);
				}
				scaledPaths[i] = scaledPath;
			}
			return scaledPaths;
		} else {
			return [];
		}
	}

	ContourData.prototype.toString = function () {
		return "ContourData(" + Eden.edenCodeForValues(this.field, this.isoValue, this.t) + ")";
	}

	ContourData.prototype.getEdenCode = ContourData.prototype.toString;

	/**Computes the locations of the vertices in the abstract space and the correct order to
	 * traverse them in order to plot the perimeter of the shape.
	 * @param {Array<Array<Number>>} An array of function result values (i.e. the raw values and
	 * not the TwoDScalarField object that represents all of information about the field (including
	 * the algorithm for computing the values)).
	 * @return {Array<Array<Point>>} An array of paths, each path represented as an array of Points.
	 */
	ContourData.prototype.computePaths = function (field) {
//console.log("Field values");
//console.log(field);
		if (field === undefined) {
			return [];
		}
		var fieldObj = this.field;
		var isoValue = this.isoValue;
		var t = this.t;

		//Compute which cells have values above the threshold.
		var thresholdValues = new Array(field.length);
		for (var i = 0; i < field.length; i++) {
			var inputColumn = field[i];
			var thresholdColumn = new Array(inputColumn.length);
			thresholdValues[i] = thresholdColumn;
			for (var j = 0; j < inputColumn.length; j++) {
				thresholdColumn[j] = inputColumn[j] >= isoValue? 1 : 0;
			}
		}

		//Compute patterns.
		var numColumns = fieldObj.numX - 1;
		var numRows = fieldObj.numY - 1;
		var completed = new Array(numColumns);
		var patterns = new Array(numColumns);
		for (var i = 0; i < numColumns; i++) {
			completed[i] = new Array(numRows);
			patterns[i] = new Array(numRows);
		}

		var middleValue;
		var allInside = true;
		for (var i = 0; i < numColumns; i++) {
			var columnComplete = completed[i];
			var patternColumn = patterns[i];
			for (var j = 0; j < numRows; j++) {
				var pattern =
					15 -
					(thresholdValues[i][j] * 8 + 
					thresholdValues[i+1][j] * 4 +
					thresholdValues[i+1][j+1] * 2 +
					thresholdValues[i][j+1]);
				if (pattern == 5 || pattern == 10) {
					middleValue = fieldObj.middleValue(i, j, t);
					if (middleValue >= isoValue) {
						//Case "-5" is similar to Case 10, and Case "-10" like Case 5.
						pattern = - pattern;
					}
				} // end resolve ambiguity
				patternColumn[j] = pattern;
				var isInside = (pattern == 0);
				columnComplete[j] = Number(isInside || pattern == 15);
				allInside = allInside && isInside;
			} //end scan down a column
		} //end scan across columns
//console.log("Patterns");
//console.log(patterns);

		/* Traverse the grid.  For each point not yet marked as complete, trace a path (part or all
		 * of the shape's perimeter) beginning from that point.
		 */
		var shapes = [];
		this.shapes = shapes;
		var shape;
		if (allInside) {
			var shape = new Array(4);
			shape[0] = new Point(0.5, 0.5);
			shape[1] = new Point(numColumns - 0.5, 0.5);
			shape[2] = new Point(numColumns - 0.5, numRows - 0.5);
			shape[3] = new Point(0.5, numRows - 0.5);
			shapes.push(shape);
		} else {
			for (var i = 0; i < numColumns; i++) {
				var columnComplete = completed[i];
				for (var j = 0; j < numRows; j++) {
					if (columnComplete[j] < 1) {
						shape = this.computePathFromPoint(field, patterns, completed, i, j);
						shapes.push(shape);
						foundPath = true;
					}
				}
			}
		}
		return shapes;
	}

	ContourData.prototype.computePathFromPoint = function(field, patterns, completed, beginI, beginJ) {
		var fieldObj = this.field;
		var maxCol = fieldObj.numX - 2;
		var maxRow = fieldObj.numY - 2;
		var isoValue = this.isoValue;

		var prevI, prevJ;
		var i = beginI;
		var j = beginJ;

		var points = [];
		var sum, outX, outY, nextI, nextJ;
		var val;

//console.log("Begin path");
		do {
			var pattern = patterns[i][j];
//console.log("(" + i + ", " + j + ") " + pattern);
			switch (pattern) {
			case 14:
				val = field[i][j+1] - isoValue;
				sum = 1 + val;
				if (prevJ == j) {
					outX = 1 - 0.5 / sum;
					outY = 1;
					nextI = 0;
					nextJ = 1;
				} else {
					outX = 0;
					outY = 1 - (0.5 + val) / sum;
					nextI = -1;
					nextJ = 0;
				}
				completed[i][j] = 1;
				break;
			case 13:
				val = field[i+1][j+1] - isoValue;
				sum = 1 + val;
				if (prevJ == j) {
					outX = 1 - (0.5 + val) / sum;
					outY = 1;
					nextI = 0;
					nextJ = 1;
				} else {
					outX = 1;
					outY = 1 - (0.5 + val) / sum;
					nextI = 1;
					nextJ = 0;
				}
				completed[i][j] = 1;
				break;
			case 11:
				val = field[i+1][j] - isoValue;
				sum = 1 + val;
				if (prevJ == j) {
					outX = 1 - (0.5 + val) / sum;
					outY = 0;
					nextI = 0;
					nextJ = -1;
				} else {
					outX = 1;
					outY = 1 - 0.5 / sum;
					nextI = 1;
					nextJ = 0;
				}
				completed[i][j] = 1;
				break;
			case 7:
				val = field[i][j] - isoValue;
				sum = 1 + val;
				if (prevJ == j) {
					outX = 1 - 0.5 / sum;
					outY = 0;
					nextI = 0;
					nextJ = -1;
				} else {
					outX = 0;
					outY = 1 - 0.5 / sum;
					nextI = -1;
					nextJ = 0;
				}
				completed[i][j] = 1;
				break;
			case 1:
				if (prevJ == j) {
					val = field[i+1][j+1] - isoValue;
					sum = 1 + val;
					outX = 1 - (0.5 + val) / sum;
					outY = 1;
					nextI = 0;
					nextJ = 1;
				} else {
					val = field[i][j] - isoValue;
					sum = 1 + val;
					outX = 0;
					outY = 1 - 0.5 / sum;
					nextJ = 0;
					nextI = -1;
				}
				completed[i][j] = 1;
				break;
			case 2:
				if (prevJ == j) {
					val = field[i][j+1] - isoValue;
					sum = 1 + val;
					outX = 1 - 0.5 / sum;
					outY = 1;
					nextI = 0;
					nextJ = 1;
				} else {
					val = field[i+1][j] - isoValue;
					sum = 1 + val;
					outX = 1;
					outY = 1 - 0.5 / sum;
					nextI = 1;
					nextJ = 0;
				}
				completed[i][j] = 1;
				break;
			case 4:
				if (prevJ == j) {
					val = field[i][j] - isoValue;
					sum = 1 + val;
					outX = 1 - 0.5 / sum;
					outY = 0;
					nextI = 0;
					nextJ = -1;
				} else {
					val = field[i+1][j+1] - isoValue;
					sum = 1 + val;
					outX = 1;
					outY = 1 - (0.5 + val) / sum;
					nextI = 1;
					nextJ = 0;
				}
				completed[i][j] = 1;
				break;
			case 8:
				if (prevJ == j) {
					val = field[i+1][j] - isoValue;
					sum = 1 + val;
					outX = 1 - (0.5 + val) / sum;
					outY = 0;
					nextI = 0;
					nextJ = -1;
				} else {
					val = field[i][j+1] - isoValue;
					sum = 1 + val;
					outX = 0;
					outY = 1 - (0.5 + val) / sum;
					nextI = -1;
					nextJ = 0;
				}
				completed[i][j] = 1;
				break;
			case 12:
				if (prevI == i - 1) {
					val = field[i+1][j+1] - isoValue;
					outX = 1;
					nextI = 1;
				} else {
					val = field[i][j+1] - isoValue;
					outX = 0;
					nextI = -1;
				}
				sum = 1 + val;
				outY = 1 - (0.5 + val) / sum;
				nextJ = 0;
				completed[i][j] = 1;
				break;
			case 9:
				if (prevJ == j - 1) {
					val = field[i+1][j+1] - isoValue;
					outY = 1;
					nextJ = 1;
				} else {
					val = field[i+1][j] - isoValue;
					outY = 0;
					nextJ = -1;
				}
				sum = 1 + val;
				outX = 1 - (0.5 + val) / sum;
				nextI = 0;
				completed[i][j] = 1;
				break;
			case 3:
				if (prevI == i - 1) {
					val = field[i+1][j] - isoValue;
					outX = 1;
					nextI = 1;
				} else {
					val = field[i][j] - isoValue;
					outX = 0;
					nextI = -1;
				}
				sum = 1 + val;
				outY = 1 - 0.5 / sum;
				nextJ = 0;
				completed[i][j] = 1;
				break;
			case 6:
				if (prevJ == j - 1) {
					val = field[i][j+1] - isoValue;
					outY = 1;
					nextJ = 1;
				} else {
					val = field[i][j] - isoValue;
					outY = 0;
					nextJ = -1;
				}
				sum = 1 + val;
				outX = 1 - 0.5 / sum;
				nextI = 0;
				completed[i][j] = 1;
				break;
			case 5:
				switch (prevJ - j) {
				case 0:
					if (prevI == i + 1) {
						val = field[i+1][j+1] - isoValue;
						sum = 1 + val;
						outX = 1 - (0.5 + val) / sum;
						outY = 1;
						nextJ = 1;
						completed[i][j] = completed[i][j] + 0.4;
					} else {
						val = field[i][j] - isoValue;
						sum = 1 + val;
						outX = 1 - 0.5 / sum;
						outY = 0;
						nextJ = -1;
						completed[i][j] = completed[i][j] + 0.6;
					}
					nextI = 0;
					break;
				case 1:
					val = field[i+1][j+1] - isoValue;
					sum = 1 + val;
					outX = 1;
					outY = 1 - (0.5 + val) / sum;
					nextI = 1;
					nextJ = 0;
					completed[i][j] = completed[i][j] + 0.4;
					break;
				case -1:
					val = field[i][j] - isoValue;
					sum = 1 + val;
					outX = 0;
					outY = 1 - 0.5 / sum;
					nextI = -1;
					nextJ = 0;
					completed[i][j] = completed[i][j] + 0.6;
					break;
				default:
					if (completed[i][j] == 0.4) {
						val = field[i][j] - isoValue;
						sum = 1 + val;
						outX = 0;
						outY = 1 - 0.5 / sum;
						nextI = -1;
						nextJ = 0;
						completed[i][j] = 1;
					} else {
						val = field[i+1][j+1] - isoValue;
						sum = 1 + val;
						outX = 1;
						outY = 1 - (0.5 + val) / sum;
						nextI = 1;
						nextJ = 0;
						completed[i][j] = completed[i][j] + 0.4;
					}
				}
				break;
			case 10:
				switch (prevJ - j) {
				case 0:
					if (prevI == i + 1) {
						val = field[i+1][j] - isoValue;
						sum = 1 + val;
						outX = 1 - (0.5 + val) / sum;
						outY = 0;
						nextJ = -1;
						completed[i][j] = completed[i][j] + 0.6;
					} else {
						val = field[i][j+1] - isoValue;
						sum = 1 + val;
						outX = 1 - 0.5 / sum;
						outY = 1;
						nextJ = 1;
						completed[i][j] = completed[i][j] + 0.4;
					}
					nextI = 0;
					break;
				case 1:
					val = field[i][j+1] - isoValue;
					sum = 1 + val;
					outX = 0;
					outY = 1 - (0.5 + val) / sum;
					nextI = -1;
					nextJ = 0;
					completed[i][j] = completed[i][j] + 0.4;
					break;
				case -1:
					val = field[i+1][j] - isoValue;
					sum = 1 + val;
					outX = 1;
					outY = 1 - 0.5 / sum;
					nextI = 1;
					nextJ = 0;
					completed[i][j] = completed[i][j] + 0.6;
					break;
				default:
					if (completed[i][j] == 0.4) {
						val = field[i+1][j] - isoValue;
						sum = 1 + val;
						outX = 1 - (0.5 + val) / sum;
						outY = 0;
						nextJ = -1;
						completed[i][j] = 1;
					} else {
						val = field[i][j+1] - isoValue;
						sum = 1 + val;
						outX = 1 - 0.5 / sum;
						outY = 1;
						nextJ = 1;
						completed[i][j] = completed[i][j] + 0.4;					
					}
					nextI = 0;
				}
				break;
			case -5:
				switch (prevJ - j) {
				case 0:
					if (prevI == i + 1) {
						val = field[i][j] - isoValue;
						sum = 1 + val;
						outX = 1 - 0.5 / sum;
						outY = 0;
						nextJ = -1;
						completed[i][j] = completed[i][j] + 0.6;
					} else {
						val = field[i+1][j+1] - isoValue;
						sum = 1 + val;
						outX = 1 - (0.5 + val) / sum;
						outY = 1;
						nextJ = 1;
						completed[i][j] = completed[i][j] + 0.4;
					}
					nextI = 0;
					break;
				case 1:
					val = field[i][j] - isoValue;
					sum = 1 + val;
					outX = 0;
					outY = 1 - 0.5 / sum;
					nextI = -1;
					nextJ = 0;
					completed[i][j] = completed[i][j] + 0.4;
					break;
				case -1:
					val = field[i+1][j+1] - isoValue;
					sum = 1 + val;
					outX = 1;
					outY = 1 - (0.5 + val) / sum;
					nextI = 1;
					nextJ = 0;
					completed[i][j] = completed[i][j] + 0.6;
					break;
				default:
					if (completed[i][j] == 0.4) {
						val = field[i][j] - isoValue;
						sum = 1 + val;
						outX = 1 - 0.5 / sum;
						outY = 0;
						nextJ = -1;
						completed[i][j] = 1;
					} else {
						val = field[i+1][j+1] - isoValue;
						sum = 1 + val;
						outX = 1 - (0.5 + val) / sum;
						outY = 1;
						nextJ = 1;
						completed[i][j] = completed[i][j] + 0.4;					
					}
					nextI = 0;
				}
				break;
			}

			if (i == 0) {
				if (outX < 0.5) {
					outX = 0.5;
				}
			} else if (i == maxCol) {
				if (outX > 0.5) {
					outX = 0.5;
				}
			}
			if (j == 0) {
				if (outY < 0.5) {
					outY = 0.5;
				}
			} else if (j == maxRow) {
				if (outY > 0.5) {
					outY = 0.5;
				}
			}
			points.push(new Point(i + outX, j + outY));

			nextI = i + nextI;
			nextJ = j + nextJ;

			var overflowX = 0, overflowY = 0;
			var prevVal;
			if (nextI < 0) {
				prevVal = field[0][j] - isoValue;
				if (prevVal >= 0) {
					//Traverse up to find the first point in column 0 that is outside of the shape.
					overflowY = -1;
				} else {
					//Traverse down to find the first point in column 0 that is outside of the shape.
					overflowY = 1;
				}
			} else if (nextI > maxCol) {
				prevVal = field[maxCol+1][j] -isoValue;
				if (prevVal >= 0) {
					//Traverse up to find the first point in the rightmost column that is outside of the shape.
					overflowY = -1;
				} else {
					//Traverse down to find the first point in the rightmost column that is outside of the shape.
					overflowY = 1;
				}
			} else if (nextJ < 0) {
				prevVal = field[i][0] - isoValue;
				if (prevVal >= 0) {
					//Traverse left to find the first point in row 0 that is outside of the shape.
					overflowX = -1;
				} else {
					//Traverse right to find the first point in row 0 that is outside of the shape.
					overflowX = 1;
				}
			} else if (nextJ > maxRow) {
				prevVal = field[i][maxRow+1] - isoValue;
				if (prevVal >= 0) {
					//Traverse left to find the first point in the bottommost row that is outside of the shape.
					overflowX = -1;
				} else {
					//Traverse right to find the first point in the bottommost row that is outside of the shape.
					overflowX = 1;
				}
			}

			var check, put, prev, inCoord;
			while (overflowX != 0 || overflowY != 0) {
				if (overflowY == -1) {
					//Traverse 1 step upwards.
					nextJ--;
					if (nextI < 0) {
						check = 0;
						put = 0;
						prev = -1;
					} else {
						check = maxCol + 1;
						put = maxCol;
						prev = maxCol + 1;
					}
					if (nextJ >= 0) {
						val = field[check][nextJ] - isoValue;
						if (val < 0) {
							sum = 1 + prevVal;
							inCoord = 1 - (0.5 + prevVal) / sum;
							nextI = put;
							i = prev;
							j = nextJ;
							points.push(new Point(put + 0.5, nextJ + inCoord));
							overflowY = 0;
						}
					} else {
						//Top-left or top-right corner reached.  Start traversing right/left.
						points.push(new Point(put + 0.5, 0.5));
						overflowX = check == 0? 1 : -1;
						overflowY = 0;
						val = 0;
					}
				} else if (overflowY == 1) {
					//Traverse 1 step downwards.
					nextJ++;
					if (nextI < 0) {
						check = 0;
						put = 0;
						prev = -1;
					} else {
						check = maxCol + 1;
						put = maxCol;
						prev = maxCol + 1;
					}
					if (nextJ <= maxRow + 1) {
						val = field[check][nextJ] - isoValue;
						if (val < 0) {
							sum = 1 + prevVal;
							inCoord = 1 - 0.5 / sum;
							nextI = put;
							nextJ--;
							i = prev;
							j = nextJ;
							points.push(new Point(put + 0.5, nextJ + inCoord));
							overflowY = 0;
						}
					} else {
						//Bottom-left or bottom-right corner reached.  Start traversing right/left.
						points.push(new Point(0.5, maxRow + 0.5));
						overflowX = check == 0? 1 : -1;
						overflowY = 0;
						val = 0;
					}
				} else if (overflowX == -1) {
					//Traverse 1 step left.
					nextI--;
					if (nextJ < 0) {
						check = 0;
						put = 0;
						prev = -1;
					} else {
						check = maxRow + 1;
						put = maxRow;
						prev = maxRow + 1;
					}
					if (nextI >= 0) {
						val = field[nextI][check] - isoValue;
						if (val < 0) {
							sum = 1 + prevVal;
							inCoord = 1 - (0.5 + prevVal) / sum;
							nextJ = put;
							i = nextI;
							j = prev;
							points.push(new Point(nextI + inCoord, put + 0.5));
							overflowX = 0;
						}
					} else {
						//Top-left or bottom-left corner reached.  Start traversing down/up.
						points.push(new Point(0.5, put + 0.5));
						overflowX = 0;
						overflowY = check == 0? 1 : -1;
						val = 0;
					}
				} else {
					//Traverse 1 step right.
					nextI++;
					if (nextJ < 0) {
						check = 0;
						put = 0;
						prev = -1;
					} else {
						check = maxRow + 1;
						put = maxRow;
						prev = maxRow + 1;
					}
					if (nextI <= maxCol + 1) {
						val = field[nextI][check] - isoValue;
						if (val < 0) {
							sum = 1 + prevVal;
							inCoord = 1 - 0.5 / sum;
							nextI--;
							nextJ = put;
							i = nextI;
							j = prev;
							points.push(new Point(nextI + inCoord, put + 0.5));
							overflowX = 0;
						}
					} else {
						//Top-right or bottom-right corner reached.  Start traversing down/up.
						points.push(new Point(maxCol + 0.5, put + 0.5));
						overflowX = 0;
						overflowY = check == 0? 1 : -1;
						val = 0;
					}					
				}

				prevVal = val;
			}

			prevI = i;
			prevJ = j;
			i = nextI;
			j = nextJ;
		} while (i != beginI || j != beginJ);
		return points;
	}

	window.TwoDScalarField = function (ptr, space, numX, numY, tMin, tMax, numT, existsBefore, existsAfter) {
		if (numX !== undefined) {
			numX = Math.ceil(numX);
		}
		if (numY !== undefined) {
			numY = Math.ceil(numY);
		}
		if (numT !== undefined) {
			numT = Math.ceil(numT);
		}

		this.ptr = ptr;
		this.space = space;
		this.numX = numX;
		this.numY = numY;
		this.tMin = tMin;
		this.tMax = tMax;
		this.numT = numT;
		this.existsBefore = existsBefore;
		this.existsAfter = existsAfter;

		if (space !== undefined) {
			this.cellWidth = (space.xMax - space.xMin) / numX;
			this.cellHeight = (space.yMax - space.yMin) / numY;
		}
	}

	TwoDScalarField.prototype.toString = function () {
		var s = "ScalarField2D(" + Eden.edenCodeForValues(this.ptr, this.space, this.numX, this.numY);

		if (this.tMin !== undefined || this.tMax !== undefined || this.numT !== undefined ||
		 this.existsBefore !== undefined || this.existsAfter !== undefined) {
			s = s + ", " + Eden.edenCodeForValues(this.tMin, this.tMax, this.numT, this.existsBefore, this.existsAfter);
		}
		s = s + ")";
		return s;
	}

	TwoDScalarField.prototype.getEdenCode = TwoDScalarField.prototype.toString;


	window.KeyFrame2DScalarField = function (fPtr, space, numX, numY, tMin, tMax, numT, existsBefore, existsAfter) {
		TwoDScalarField.call(this, fPtr, space, numX, numY, tMin, tMax, numT, existsBefore, existsAfter);
		var f = fPtr.value();
		this.f = f;
		var keyFrames = new Array(this.numT);
		this.keyFrames = keyFrames;
		var minVals = new Array(this.numT);
		this.minVals = minVals;
		var maxVals = new Array(this.numT);
		this.maxVals = maxVals;
		var xMin = space.xMin;
		var yMin = space.yMin;
		var cellWidth = this.cellWidth;
		var cellHeight = this.cellHeight;
		var timeBetweenKeyframes = (tMax - tMin) / (this.numT - 1);
		
		for (var k = 0; k < this.numT; k++) {
			var minVal = Infinity;
			var maxVal = -Infinity;
			var t = tMin + k * timeBetweenKeyframes;
			var field = new Array(this.numX);
			keyFrames[k] = field;

			for (var i = 0; i < this.numX; i++) {
				var column = new Array(this.numY);
				field[i] = column;
				var x = xMin + (i + 0.5) * cellWidth;
			
				for (var j = 0; j < this.numY; j++) {
					var y = yMin + (j + 0.5) * cellHeight;
					var value = f(x, y, t);
					column[j] = value;
					if (value < minVal) {
						minVal = value;
					} else if (value > maxVal) {
						maxVal = value;
					}
				}
			}
			minVals[k] = minVal;
			maxVals[k] = maxVal;
		}
	}

	KeyFrame2DScalarField.prototype = new TwoDScalarField();

	KeyFrame2DScalarField.prototype.middleValue = function (i, j, t) {
		return this.f(
			this.space.xMin + (i + 1) * this.cellWidth,
			this.space.yMin + (j + 1) * this.cellHeight,
			t);
	}

	KeyFrame2DScalarField.prototype.getValues = function (threshold, t) {
		var tMin = this.tMin;
		var tMax = this.tMax;

		if (t !== undefined && (
		 (t >= tMin || this.existsBefore) &&
		 (t <= tMax || this.existsAfter))) {
			var frameNumber = (t - tMin) / (tMax - tMin) * (this.numT - 1);
			var frameNumberBefore = Math.floor(frameNumber);
			var frameNumberAfter = Math.ceil(frameNumber);

			if (frameNumberBefore == frameNumberAfter) {
				return this.keyFrames[frameNumberBefore];
			} else {
				var numX = this.numX;
				var numY = this.numY;
				var values = new Array(numX);
				var proportionAfter = frameNumber - frameNumberBefore;
				var proportionBefore = frameNumberAfter - frameNumber;
				var keyFrameBefore = this.keyFrames[frameNumberBefore];
				var keyFrameAfter = this.keyFrames[frameNumberAfter];
				var beforeMin = this.minVals[frameNumberBefore];
				var beforeMax = this.maxVals[frameNumberBefore];
				var afterMin = this.minVals[frameNumberAfter];
				var afterMax = this.maxVals[frameNumberAfter];
				var weightedMin = beforeMin * proportionBefore + afterMin * proportionAfter;
				var weightedMax = beforeMax * proportionBefore + afterMax * proportionAfter;
				
				for (var i = 0; i < numX; i++) {
					var column = new Array(numY);
					var columnBefore = keyFrameBefore[i];
					var columnAfter = keyFrameAfter[i];
					values[i] = column;
					for (var j = 0; j < numY; j++) {
						var value1, distance1, value2, distance2;
						value1 = columnBefore[j];
						if (value1 >= threshold) {
							distance1 = (value1 - threshold) / (beforeMax - threshold);
						} else {
							distance1 = -(threshold - value1) / (threshold - beforeMin);
						}
						value2 = columnAfter[j];
						if (value2 >= threshold) {
							distance2 = (value2 - threshold) / (afterMax - threshold);
						} else {
							distance2 = -(threshold - value2) / (threshold - afterMin);
						}
						var sumDistance = distance1 * proportionBefore + distance2 * proportionAfter;
						if (sumDistance >= 0) {
							column[j] = threshold + sumDistance * (weightedMax - threshold);
						} else {
							column[j] = threshold + sumDistance * (threshold - weightedMin);
						}
					}
				}
				return values;
			}
		} else {
			return undefined;
		}
	}


	window.Static2DScalarField = function (fPtr, space, numX, numY, tMin, tMax, numT, existsBefore, existsAfter) {
		TwoDScalarField.call(this, fPtr, space, numX, numY, tMin, tMax, numT, existsBefore, existsAfter);
		var f = fPtr.value();
		this.f = f;
		var field = new Array(this.numX);
		this.field = field;
		var xMin = space.xMin;
		var yMin = space.yMin;
		var cellWidth = this.cellWidth;
		var cellHeight = this.cellHeight;
		var t;
		if (tMin !== undefined && tMax !== undefined) {
			t = (tMin + tMax) / 2;
		} else if (tMin !== undefined) {
			t = tMin;
		} else if (tMax !== undefined) {
			t = tMax;
		} else {
			t = 0;
		}
		this.t = t;

		for (var i = 0; i < this.numX; i++) {
			var column = new Array(this.numY);
			field[i] = column;
			var x = xMin + (i + 0.5) * cellWidth;
		
			for (var j = 0; j < this.numY; j++) {
				var y = yMin + (j + 0.5) * cellHeight;
				column[j] = f(x, y, t);
			}
		}
	}

	Static2DScalarField.prototype = new TwoDScalarField();

	Static2DScalarField.prototype.middleValue = function (i, j) {
		return this.f(
			this.space.xMin + (i + 1) * this.cellWidth,
			this.space.yMin + (j + 1) * this.cellHeight,
			this.t);
	}

	Static2DScalarField.prototype.getValues = function (threshold, t) {
		var tMin = this.tMin;
		var tMax = this.tMax;

		if (t === undefined || (
		 (t >= tMin || tMin === undefined || this.existsBefore !== false) &&
		 (t <= tMax || tMax === undefined || this.existsAfter !== false))) {
			return this.field;
		} else {
			 return undefined;
		}
	}


	window.Explicit2DScalarField = function (listPtr, space, numX, numY, tMin, tMax, numT, existsBefore, existsAfter) {
		var transposed = listPtr instanceof Symbol? listPtr.value() : undefined;
		var numRows;
		if (Array.isArray(transposed)) {
			numRows = transposed.length;
			if (numX === undefined) {
				numX = transposed[0].length;
			}
		} else {
			numRows = 0;
		}
		if (numY === undefined) {
			numY = numRows;
		}
		TwoDScalarField.call(this, listPtr, space, numX, numY, tMin, tMax, numT, existsBefore, existsAfter);
		var field = new Array(numX);
		for (var i = 0; i < numX; i++) {
			var column = new Array(numY);
			field[i] = column;
			for (var j = 0; j < numY && j < numRows; j++) {
				var row = transposed[j];
				var numCols = Array.isArray(row)? row.length : 0;
				if (i < numCols) {
					column[j] = row[i];
				} else {
					column[j] = -Infinity;
				}
			}
			for (var j = numRows; j < numY; j++) {
				column[j] = -Infinity;
			}
		}
		this.field = field;
	}

	Explicit2DScalarField.prototype = new TwoDScalarField();

	Explicit2DScalarField.prototype.middleValue = function (i, j) {
		var field = this.field;
		return (field[i][j] + field[i+1][j] + field[i][j+1] + field[i+1][j+1]) / 4;
	}

	Explicit2DScalarField.prototype.getValues = function (threshold, t) {
		var tMin = this.tMin;
		var tMax = this.tMax;

		if (t === undefined || (
		 (t >= tMin || tMin === undefined || this.existsBefore !== false) &&
		 (t <= tMax || tMax === undefined || this.existsAfter !== false))) {
			return this.field;
		} else {
			 return undefined;
		}
	}


	window.ContourLine = function (x, y, width, height, isoLine, fillcolour, outlinecolour, drawingOptions) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		this.line = isoLine;
		this.fillcolour = fillcolour;
		this.outlinecolour = outlinecolour;
		this.drawingOptions = drawingOptions;
	}

	ContourLine.prototype.draw = function (context, scale) {

		this.tracePath(context, scale);

		if (this.fillcolour !== undefined) {
			edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
			context.fill("evenodd");
		}

		if (this.outlinecolour !== undefined) {
			context.strokeStyle = this.outlinecolour;
			context.stroke();
		}
	}

	ContourLine.prototype.tracePath = function (context, scale) {
		if (!(this.line instanceof ContourData)) {
			return;
		}

		var lineWidth;
		if (this.drawingOptions !== undefined) {
			lineWidth = this.drawingOptions.lineWidth || edenUI.plugins.Canvas2D.defaultLineWidth;
		} else {
			lineWidth = edenUI.plugins.Canvas2D.defaultLineWidth;
		}
		if (this.outlinecolour === undefined) {
			lineWidth = 0;
		} else if (lineWidth % 2 == 1) {
			context.translate(0.5 / scale, 0.5 / scale);
		}

		var paths = this.line.scalePaths(this.x, this.y, this.width, this.height, scale, lineWidth);
		context.beginPath();
		for (var i = 0; i < paths.length; i++) {
			var path = paths[i];
			var point = path[0];
			var startX = point.x;
			var startY = point.y;
			context.moveTo(startX, startY);
			for (var j = 1; j < path.length; j++) {
				point = path[j];
				context.lineTo(point.x, point.y);
			}
			context.lineTo(startX, startY);
		}
	}

	ContourLine.prototype.isHit = function (context, scale, x, y) {
		this.tracePath(context, scale);
		return context.isPointInPath(x,y);
	}

	ContourLine.prototype.toString = function () {
		return "ContourLine(" + Eden.edenCodeForValues(this.x, this.y, this.width, this.height,
			this.line, this.fillcolour, this.outlinecolour, this.drawingOptions) + ")";
	}

	ContourLine.prototype.getEdenCode = ContourLine.prototype.toString;
	
}}$;
/**
 * Creates a EuclideanSpace object
 * @param xMin
 * @param yMin
 * @param [zMin]
 * @param xMax
 * @param yMax
 * @param [zMax]
 * #euclideanspace #contour
 */
func EuclideanSpace {
	${{
		var xMin, yMin, zMin, xMax, yMax, zMax;
		if (arguments.length > 4) {
			xMin = arguments[0];
			yMin = arguments[1];
			zMin = arguments[2];
			xMax = arguments[3];
			yMax = arguments[4];
			zMax = arguments[5];
		} else {
			xMin = arguments[0];
			yMin = arguments[1];
			xMax = arguments[2];
			yMax = arguments[3];
		}
		return new EuclideanSpace(xMin, yMin, zMin, xMax, yMax, zMax);
	}}$;
}

/**
 * 
 * Creates object to hold Scalar Field values
 * For more details, please see: 
 * <a target="_blank" href="http://jseden.dcs.warwick.ac.uk/latest-master/index-dev.html?import=plugins/canvas/contourLine/guide">Contour Line Guide</a>
 * @param dataPtr
 * @param space
 * @param numX
 * @param numY
 * @param [tmin
 * @param [tmax]]
 * #scalarfield #contour
 */

func ScalarField2D {
	${{
		var dataPtr = arguments[0];
		var space = arguments[1];
		var numX = arguments[2];
		var numY = arguments[3];

		var tMin, tMax, numT, existsBefore, existsAfter;
		var numArgs = arguments.length;
		var argsProcessed;

		if (numArgs > 5) {
			tMin = arguments[4];
			tMax = arguments[5];
			argsProcessed = 6;
			if (numArgs == 9 || typeof(arguments[argsProcessed]) == "number") {
				numT = arguments[6];
				argsProcessed++;
			} else if (tMin === undefined || tMax === undefined || tMin === tMax) {
				numT = 1;
			} else {
				numT = 2;
			}
			existsBefore = numArgs > argsProcessed? arguments[argsProcessed] : tMin === undefined;
			argsProcessed++;
			existsAfter = numArgs > argsProcessed? arguments[argsProcessed] : tMax === undefined;
		} else if (numArgs > 4) {
			tMin = arguments[4];
			tMax = tMin;
			numT = 1;
			existsBefore = true;
			existsAfter = true;
		}

		var dataSource = dataPtr instanceof Symbol? dataPtr.value() : undefined;

		if (Array.isArray(dataSource)) {
			return new Explicit2DScalarField(dataPtr, space, numX, numY, tMin, tMax, numT, existsBefore, existsAfter);
		} else if (tMin === undefined || tMax === undefined || tMin === tMax || numT === 1) {
			return new Static2DScalarField(dataPtr, space, numX, numY, tMin, tMax, numT, existsBefore, existsAfter);
		} else {
			return new KeyFrame2DScalarField(dataPtr, space, numX, numY, tMin, tMax, numT, existsBefore, existsAfter);
		}
	}}$;
}

/**
 * 
 * Applies a threshold and traces the outline of a shape.
 * For more details, please see: 
 * <a target="_blank" href="http://jseden.dcs.warwick.ac.uk/latest-master/index-dev.html?import=plugins/canvas/contourLine/guide">Contour Line Guide</a>
 * @param scalar_field_2d ScalarField object providing the function values
 * @param [iso_value The threshold value that determines which function values fall inside the boundary of the shape
 * @param [time_value]] The time instant at which to evaluate the function.  May be omitted if the function is time invariant.
 *
 * #contour
 */

func ContourData {
	${{
		var field = arguments[0];
		var isoValue = arguments[1];
		if (isoValue === undefined) {
			isoValue = 0;
		}
		var t = arguments[2];
		return new ContourData(field, isoValue, t);
	}}$;
}

/**
 * Creates a contoured shape object with size, position, colour, etc. from the mathematical description (ContourData).
 * For more details, please see: 
 * <a target="_blank" href="http://jseden.dcs.warwick.ac.uk/latest-master/index-dev.html?import=plugins/canvas/contourLine/guide">Contour Line Guide</a>
 * 
 * @param x
 * @param y
 * @param width
 * @param height
 * @param contour_data A contourData object
 * @param [fill_colour
 * @param [outline_colour]]
 * @param [drawing_options] A drawingOptions object
 * 
 * #canvas #contour #line #drawingOptions
 * 
 */
func ContourLine {
	${{
		var x = arguments[0];
		var y = arguments[1];
		var width = arguments[2];
		var height = arguments[3];
		var line = arguments[4];

		var fillcolour, outlinecolour, drawingOptions;
		var lastArg = arguments[arguments.length - 1];
		var processUpTo;
		if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
			drawingOptions = lastArg;
			processUpTo = arguments.length - 2;
		} else {
			processUpTo = arguments.length - 1;
		}
		if (processUpTo >= 5) {
			fillcolour = arguments[5];
			if (processUpTo == 6) {
				outlinecolour = arguments[6];
			}
		}
		if (fillcolour === undefined && outlinecolour === undefined) {
			outlinecolour = "black";
		}
		return new ContourLine(x, y, width, height, line, fillcolour, outlinecolour, drawingOptions);
	}}$;
}

${{
	Curve = function (x1, y1, x2, y2, r, elasticity, theta1, theta2, mid, overshoot, dirSwitch, colours, drawingOptions) {
		this.x1 = x1;
		this.y1 = y1;
		this.x2 = x2;
		this.y2 = y2;
		this.r = r;
		this.elasticity = elasticity;
		this.theta1 = theta1;
		this.theta2 = theta2;
		this.mid = mid;
		this.overshoot = overshoot;
		this.dirSwitch = dirSwitch;
		this.colours = colours;
		this.drawingOptions = drawingOptions;

		elasticity = elasticity * 0.94;
		var xDistance = x2 - x1;
		var yDistance = y2 - y1;
		this.theta3 = Math.atan2(yDistance, xDistance);
		this.fullLength = Math.sqrt(xDistance * xDistance + yDistance * yDistance);
		this.length1 = mid * this.fullLength;
		var length2 = this.fullLength - this.length1;

		var radiansPerUnit = Math.PI / root.lookup("semicircleAngle").value();
		this.delta1 = elasticity * this.length1;
		this.delta2 = elasticity * length2;
		var fullTurn = 2 * Math.PI;

		if (theta1 === undefined) {
			this.deltaX1 = 0;
			this.deltaY1 = 0;
		} else {
			var theta1Normalized = (theta1 * radiansPerUnit) % fullTurn;
			if (theta1Normalized < 0) {
				theta1Normalized = theta1Normalized + fullTurn;
			}
			var tanTheta1 = Math.abs(Math.tan(theta1Normalized));

			if (theta1Normalized > fullTurn/4 && theta1Normalized <= fullTurn * 3/4) {
				this.deltaX1 = -overshoot;
			} else {
				this.deltaX1 = Math.abs(this.length1 - this.delta1);
			}

			this.deltaY1 = Math.abs(this.deltaX1) * tanTheta1;
			if (theta1Normalized > fullTurn/2) {
				this.deltaY1 = -this.deltaY1;
			} else if (this.deltaY1 > r) {
				this.deltaY1 = r;
				this.deltaX1 = r / tanTheta1;
			}
		}

		if (theta2 === undefined) {
			this.deltaX2 = 0;
			this.deltaY2 = 0;
		} else {
			var theta2Normalized = (theta2 * radiansPerUnit) % fullTurn;
			if (theta2Normalized < 0) {
				theta2Normalized = theta2Normalized + fullTurn;
			}
			var tanTheta2 = Math.abs(Math.tan(theta2Normalized));

			if (theta2Normalized > fullTurn/4 && theta2Normalized <= fullTurn * 3/4) {
				this.deltaX2 = -overshoot;
			} else {
				this.deltaX2 = Math.abs(length2 - this.delta2);
			}

			this.deltaY2 = Math.abs(this.deltaX2) * tanTheta2;
			if (theta2Normalized > fullTurn/2) {
				this.deltaY2 = -this.deltaY2;
			} else if (this.deltaY2 > r) {
				this.deltaY2 = r;
				this.deltaX2 = r / tanTheta2;
			}
		}

		if (dirSwitch) {
			this.radius = -r;
			this.deltaY1 = -this.deltaY1;
			this.deltaY2 = -this.deltaY2;
		} else {
			this.radius = r;
		}
	}

}}$;

/**
 * Create a Curve
 * 
 * @param x1
 * @param y1
 * @param x2
 * @param y2
 * @param radius
 * @param curviness
 * @param [start_angle
 * @param [end_angle
 * @param [skew Between 0 and 1
 * @param [overshoot]]]]
 * @param [is_flipped]
 * @param [colour(s)]
 * @param [drawing_options]
 * 
 * #canvas #curve #drawingOptions
 */

func Curve {
	${{
		var x1 = arguments[0];
		var y1 = arguments[1];
		var x2 = arguments[2];
		var y2 = arguments[3];
		var r = arguments[4];
		var elasticity = arguments[5];

		var direction, theta1, theta2, mid = 0.5, overshoot = 150, direction, colours, drawingOptions;
		var lastArg = arguments[arguments.length - 1];
		var processUpTo;
		if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg)) {
			drawingOptions = lastArg;
			processUpTo = arguments.length - 2;
			lastArg = arguments[processUpTo];
		} else {
			processUpTo = arguments.length - 1;
		}
		if (typeof(lastArg) == "string") {
			colours = [lastArg];
			processUpTo--;
		} else if (Array.isArray(lastArg)) {
			colours = lastArg;
			processUpTo--;
		} else {
			colours = ["black"];
		}
		lastArg = arguments[processUpTo];
		if (typeof(lastArg) == "boolean") {
			direction = lastArg;
			processUpTo--;
		}
		if (processUpTo > 5) {
			theta1 = arguments[6];
			if (processUpTo > 6) {
				theta2 = arguments[7];
				if (processUpTo > 7) {
					mid = arguments[8];
					if (processUpTo > 8) {
						overshoot = arguments[9];
					}
				}
			} else {
				theta2 = theta1;
			}
		}
		return new Curve(x1, y1, x2, y2, r, elasticity, theta1, theta2, mid, overshoot, direction, colours, drawingOptions);
	}}$;
}
semicircleAngle ~> [Curve];

${{
	Curve.prototype.draw = function (context, scale) {
		if (this.colours.length == 1) {
			context.strokeStyle = this.colours[0];
		} else {
			var gradient = context.createLinearGradient(0, 0, this.fullLength, 0);
			for (var i = 0; i < this.colours.length; i++) {
				gradient.addColorStop(i / (this.colours.length - 1), this.colours[i]);
			}
			context.strokeStyle = gradient;
		}

		context.translate(this.x1, this.y1);
		context.rotate(this.theta3);
		context.beginPath();
		context.moveTo(0, 0);
		context.bezierCurveTo(this.deltaX1, this.deltaY1, this.length1 - this.delta1, this.radius, this.length1, this.radius);
		context.bezierCurveTo(this.length1 + this.delta2, this.radius, this.fullLength - this.deltaX2, this.deltaY2, this.fullLength, 0);
		context.stroke();

		if (this.drawingOptions !== undefined && this.drawingOptions.arrowhead instanceof Arrowhead) {
			var gradient1, gradient2, t, x1, y1;
			if (this.deltaX1 == 0 && this.deltaY1 == 0) {
				t = 0.01;
				x1 = 3 * (1 - t) * t * t * (this.length1 - this.delta1) + t * t * t * this.length1;
				y1 = 3 * (1 - t) * t * t * this.radius + t * t * t * this.radius;
				gradient1 = y1 / x1;
			} else {
				gradient1 = this.deltaY1 / this.deltaX1;
			}
			if (this.deltaX2 == 0 && this.deltaY2 == 0) {
				t = 0.99;
				x1 = (1 - t) * (1 - t) * (1 - t) * this.length1 +
					3 * (1 - t) * (1 - t) * t * (this.length1 + this.delta2) +
					3 * (1 - t) * t * t * this.fullLength +
					t * t * t * this.fullLength;
				y1 = (1 - t) * (1 - t) * (1 - t) * this.radius + 3 * (1 - t) * (1 - t) * t * this.radius;
				gradient2 = -y1 / (this.fullLength - x1);
			} else {
				gradient2 = -this.deltaY2 / this.deltaX2;
			}
			this.drawingOptions.arrowhead.draw(context, scale, 0, 0, gradient1, false, this.fullLength, 0, gradient2, false);
		}
	};

	Curve.prototype.toString = function () {
		return "Curve(" + Eden.edenCodeForValues(this.x1, this.y1, this.x2, this.y2, this.r, this.elasticity, this.theta1, this.theta2, this.mid, this.overshoot, this.dirSwitch, this.colours, this.drawingOptions) + ")";
	}
	
	Curve.prototype.getEdenCode = Curve.prototype.toString;
}}$;
## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Div = function (html, x, y, width, height, id, classNames, style) {
	this.html = html;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.name = id;
	this.obsName = root.currentObservableName();
	this.classNames = classNames;
	this.style = style;

	//Separate font-size from other CSS information.
	var styleType = typeof(style);
	var matcher, matcher2;
	this.fontSizeSpecified = false;
	if (styleType == "string") {
		matcher = style.match(/(^|;)\s*font-size:\s*([^;]*)(;|$)/);
		if (matcher !== null) {
			matcher2 = matcher[2].match(/^(\d+(\.\d+)?)([a-z%]+)\s*$/);
			if (matcher2 !== null) {
				this.fontSizeNumber = Number(matcher2[1]);
				this.fontSizeUnits = matcher2[3];
				this.fontSizeSpecified = true;
			}
		} else {
			matcher = style.match(/(^|;)\s*font:([^\/;]+\s+)?(\d+(\.\d+)?)([a-z%]+)(\/|\s|;|$)/);
			if (matcher !== null) {
				this.fontSizeNumber = Number(matcher[3]);
				this.fontSizeUnits = matcher[5];
				this.fontSizeSpecified = true;
			}
		}
	} else if (styleType == "object") {
		var propertyValue = style.fontSize || style["font-size"];
		if (propertyValue) {
			matcher2 = propertyValue.match(/^(\d+(\.\d+)?)([a-z%]+)\s*$/);
			if (matcher2 !== null) {
				this.fontSizeNumber = Number(matcher2[1]);
				this.fontSizeUnits = matcher2[3];
				this.fontSizeSpecified = true;
			}
		} else {
			propertyValue = style.font;
			if (propertyValue) {
				matcher = style.match(/([^\/;]+\s+)?(\d+(\.\d+)?)([a-z%]+)(\/|\s|;|$)/);
				if (matcher !== null) {
					this.fontSizeNumber = Number(matcher[2]);
					this.fontSizeUnits = matcher[4];
					this.fontSizeSpecified = true;
				}
			}
		}
	}
}

Div.prototype.hash = function () {
	return this.x+"$$"+
		this.y+"$$"+
		this.width+"$$"+
		this.height+"$$"+
		this.html+"$$"+
		this.name+"$$"+
		this.classNames+"$$"+
		Eden.edenCodeForValue(this.style);
};
}}$;

/**
 * Create a Div tag to display HTML
 * 
 * @param html
 * @param x X-coordinate
 * @param y Y-coordinate
 * @param [width Width in pixels or as a string or undefined
 * @param [height]] Height in pixels or as a string or undefined
 * @param [id]
 * @param [css_class_list]
 * @param [style] An optional CSS style string
 * #canvas #div #html #css
 */

func Div { ${{
	var html = arguments[0];
	var x = arguments[1];
	var y = arguments[2];
	var width, height;   //Number of pixels, string (e.g. "50%") or undefined (automatic)
	var id, classNames;
	var style = "";
	
	var argsProcessed = 3;
	var argType = typeof(arguments[3]);
	
	if (argType == "number" || argType == "undefined") {
		width = arguments[3];
		argsProcessed++;
		
		argType = typeof(arguments[4]);
		if (argType == "number" || argType == "undefined") {
			height = arguments[4];
			argsProcessed++;
		}
	}

	if (arguments.length > argsProcessed) {
		if (arguments.length == argsProcessed + 3) {
			id = arguments[argsProcessed];
			classNames = arguments[argsProcessed + 1];
			style = arguments[argsProcessed + 2];
		} else {
			if (Array.isArray(arguments[argsProcessed])) {
				classNames = arguments[argsProcessed];
				if (arguments.length == argsProcessed + 2) {
					style = arguments[argsProcessed + 1];
				}
			} else if (arguments.length == argsProcessed + 2) {
				id = arguments[argsProcessed];
				if (Array.isArray(arguments[argsProcessed + 1])) {
					classNames = arguments[argsProcessed + 1];
				} else {
					style = arguments[argsProcessed + 1];
				}
			} else {
				argType = typeof(arguments[argsProcessed]);
				if ((argType == "string" && arguments[argsProcessed].indexOf(":") !== -1) ||
					argType == "object") {
					style = arguments[argsProcessed];
				} else {
					id = arguments[argsProcessed];
				}
			}
		}
	}	
	return new Div(html, x, y, width, height, id, classNames, style);
}}$; }

${{

Div.prototype.draw = function(context) {

  if (this.elements === undefined) {
	var me = this;

	var divElement = document.createElement("div");
	if (this.name !== undefined) {
		divElement.id = this.name;
	}

	divElement.addEventListener("click", function(event) {
		var script = event.target.getAttribute("data-jseden");
		if (!event.target.className.includes("disabled") && script !== null && script != "") {
			eden.execute2(script);
		}
	});

	if (Array.isArray(this.classNames)) {
		divElement.setAttribute("class", "canvashtml-item canvashtml-div-item " + this.classNames.join(" "));
	} else {
		divElement.setAttribute("class", "canvashtml-item canvashtml-div-item");
	}

	if (this.style != "") CSSUtil.setStyle(divElement, this.style);
	divElement.innerHTML = this.html;

	if (this.name !== undefined) {
		divElement.onmousedown = function (event) {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseDownZone").assign(event.target.id, root.scope, EdenSymbol.hciAgent, mouseFollow);
		};
		divElement.onmouseup = function (event) {
			edenUI.plugins.Canvas2D.endClick();
		};
		divElement.onmouseenter = function (event) {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseZone").assign(event.target.id, root.scope, EdenSymbol.hciAgent, mouseFollow);
		};
		edenUI.plugins.Canvas2D.initZoneFromName(name, "Div")
	}

	//Create object properties that record the automatically generated width and/or height.
	if (this.width === undefined || this.name !== undefined) {
		var objectElement = document.createElement("object");
		objectElement.setAttribute("style", "display: block; position: absolute; top: 0px; left: 0px; " + 
			"height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;");

		objectElement.onload = function () {
			me.resize();
		}

		objectElement.type = "text/html";
		objectElement.data = "about:blank";
		divElement.appendChild(objectElement);
	}

	this.elements = [divElement];
  }
};

Div.prototype.resize = function () {
	var scale = this.cachedScale;
	if (scale === undefined) {
		//Not yet added drawn onto a canvas.
		return;
	}

	var element = this.elements[0];
	var style = element.style;
	//style.transform = "scale("+scale+")";
	var autoWidth = this.width === undefined;
	var autoHeight = this.height === undefined;

	/*if (autoWidth) {
		var savedHeight = style.height;
		style.width = "auto";
		style.height = "auto";
		var contentWidth = element.clientWidth;
		style.width = contentWidth + "px";
		style.height = savedHeight;
		var scrollBarSize = element.offsetWidth - element.clientWidth;
		if (scrollBarSize > 0) {
			scrollBarSize = scrollBarSize + 2;
			style.width = String(contentWidth + scrollBarSize) + "px";
		} else {
			style.width = "auto";
		}
	}*/

	if (this.name !== undefined) {
		var agent = root.lookup("Div");
		var widthSymName = this.name + "_width";
		var heightSymName = this.name + "_height";

		if (autoWidth || widthSymName in root.symbols) {
			root.lookup(widthSymName).assign(element.offsetWidth / scale, root.scope, agent);
		}
		if (autoHeight || heightSymName in root.symbols) {
			root.lookup(heightSymName).assign(element.offsetHeight / scale, root.scope, agent);
		}
	}
}

Div.prototype.scale = function (scale, zoom , origin) {
	var style = this.elements[0].style;
	style.left = Math.round((this.x + origin.x) * scale) + "px";
	style.top = Math.round((this.y + origin.y) * scale) + "px";

	if (this.width !== undefined) {
		style.width = Math.round(this.width) + "px";
	}
	if (this.height !== undefined) {
		style.height = Math.round(this.height) + "px";
	}
	/*if (this.fontSizeSpecified) {
		style.fontSize = String(this.fontSizeNumber * zoom) + this.fontSizeUnits;
	} else {
		if (zoom == 1) {
			style.fontSize = ""; //Could be specified by a CSS class.
		} else {
			style.fontSize = zoom + "em";
		}
	}*/
	//if (scale != this.cachedScale) {
		style.transform = "scale("+zoom+")";
	//}
	this.cachedScale = scale;
	this.resize();
};

Div.prototype.toString = function() {
	return this.getEdenCode();
};

Div.prototype.getEdenCode = function () {
	var s = "Div(" + Eden.edenCodeForValues(this.html, this.x, this.y, this.width, this.height);

	if (this.name !== undefined) {
		s = s + ", \"" + this.name + "\"";
	}
	if (this.classNames !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.classNames);
	}
	if (this.style != "") {
		s = s + ", \"" + this.style + "\"";
	}
	s = s + ")";
	return s;
};

}}$;

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
DropDownList = function (name, values, labels, x, y, enabled) {
	this.name = name;
	this.obsName = root.currentObservableName();
	this.values = values;
	this.labels = labels;
	this.x = x;
	this.y = y;
	this.enabled = enabled;
}

DropDownList.prototype.hash = function () {
	return this.name+"$$"+
				(Array.isArray(this.values)? this.values.join("$$") : "") +
				(Array.isArray(this.labels)? this.labels.join("$$") : "") +
				this.x+"$$"+
				this.y+"$$"+
				this.enabled;
};

}}$;


/**
 * Creates a DropDown list, allowing for the selection
 * @param [name] Prefix for _value observable. Default is the name of the observable being defined.
 * @param values A list of options
 * @param [labels] A list of labels to display, if not supplied, the list of values will be used
 * @param x X-coordinate
 * @param y Y-coordinate
 * @param [enabled] Boolean to determine if list selection is enabled
 * #canvas #dropdown #input #select
 */
func DropDownList { ${{
	var argsProcesed;

	var name;
	if (typeof(arguments[0]) == "string") {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("DropDownList: Every DropDownList must have a name."), "error");
			return undefined;
		}
	}

	var values = arguments[argsProcessed];
	argsProcessed++;
	var labels;
	if (Array.isArray(arguments[argsProcessed])) {
		labels = arguments[argsProcessed];
		argsProcessed++;
	} else {
		labels = values;
	}
	var x = arguments[argsProcessed];
	argsProcessed++;
	var y = arguments[argsProcessed];
	argsProcessed++;
	var enabled = arguments[argsProcessed];

	return new DropDownList(name, values, labels, x, y, enabled);
}}$; }


${{

DropDownList.prototype.makeOptionsHTML = function() {
	var html = "";
	for (var i = 0; i < this.values.length; i++) {
		html = html + '\n<option value="' + this.values[i] + '">' + this.labels[i] + '</option>';
	}
	return html;
}

DropDownList.prototype.draw = function(context) {
	var dropDownList;
	var me = this;
	var name = this.name;
	var valueSym = root.lookup(name + '_value');

	if (this.elements === undefined) {

		var disabled = this.enabled === false? 'disabled="disabled"' : '';
		var dropDownListJQ = $('<select ' + disabled + ' class="canvashtml-item"></select>');
		dropDownListJQ.html(this.makeOptionsHTML(this.values));

		dropDownList = dropDownListJQ.get(0);
		var initialValue = valueSym.value();
		if (initialValue === undefined) {
			valueSym.assign(me.values[0], root.scope, root.lookup("DropDownList"), true);
		} else {
			dropDownList.value = initialValue;
		}
		valueSym.addJSObserver("updateDropDownList", function (symbol, value) {
			dropDownList.value = value;
		});

		dropDownListJQ.change(function(event) {
			valueSym.assign(event.target.value, root.scope, EdenSymbol.hciAgent, true);
		})
		.on("mousedown", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseDownZone").assign(undefined, root.scope, EdenSymbol.hciAgent, mouseFollow);
		})
		.on("mouseup", function () {
			edenUI.plugins.Canvas2D.endClick();
		})
		.on("mouseenter", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		});

		this.elements = [dropDownList];

	} else {

		//Case when the user has performed direct assignment to one or more JavaScript properties.
		dropDownList = this.elements[0];
		$(dropDownList).html(this.makeOptionsHTML());

		dropDownList.value = valueSym.value();

		if (this.enabled === false) { 
			dropDownList.disabled = true;
		} else {
			dropDownList.disabled = false;
		}

	}
};

DropDownList.prototype.scale = function (scale, zoom, origin) {
	var style = this.elements[0].style;
	style.left = Math.round((this.x + origin.x) * scale) + "px";
	style.top =  Math.round((this.y + origin.y) * scale) + "px";
	style.fontSize = zoom + "em";
};

DropDownList.prototype.toString = function() {
	if (this.name == this.obsName) {
		return "DropDownList(" + Eden.edenCodeForValues(this.values, this.labels, this.x,
			this.y, this.enabled) + ")";
	} else {
		return "DropDownList(" + Eden.edenCodeForValues(this.name, this.values, this.labels, this.x,
			this.y, this.enabled) + ")";
	}
};

DropDownList.prototype.getEdenCode = DropDownList.prototype.toString;

}}$;

## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Ellipse = function(x, y, xradius, yradius, fillcolour, outlinecolour, drawingOptions) {
	this.x = x;
	this.y = y;
	this.xradius = xradius;
	this.yradius = yradius;
	this.fillcolour = fillcolour;
	this.outlinecolour = outlinecolour;
	this.drawingOptions = drawingOptions;
	this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Ellipse");
	this.obsName = root.currentObservableName();
}
}}$;

/**
 * Create an Ellipse
 * 
 * @param x Centre X-coordinate
 * @param y Centre Y-coordinate
 * @param x_radius Ellipse x-axis radius from centre
 * @param y_radius Ellipse y-axis radius from centre
 * @param [fill_colour Fill colour for the ellipse on the canvas
 * @param [outline_colour]] Outline colour of the ellipse on the canvas
 * @param [drawing_options] A drawingOptions object
 * 
 * #canvas #ellipse #drawingOptions
 */

func Ellipse { ${{
	var x = arguments[0];
	var y = arguments[1];
	var xradius = arguments[2];
	var yradius = arguments[3];
	var fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 4) {
		fillcolour = arguments[4];
		if (processUpTo == 5) {
			outlinecolour = arguments[5];
		}
	}

	if (fillcolour === undefined && outlinecolour === undefined) {
		outlinecolour = "black";
	}
	return new Ellipse(x, y, xradius, yradius, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

Ellipse.prototype.draw = function (context) {
	if (this.xradius > 0 && this.yradius > 0) {

		var scaleOutline;
		if (this.outlinecolour === undefined || this.outlinecolour == "transparent") {
			scaleOutline = false;
		} else if (this.drawingOptions === undefined || !("scaleOutline" in this.drawingOptions)) {
			scaleOutline = (this.fillcolour !== undefined && this.fillcolour != "transparent");
		} else {
			scaleOutline = this.drawingOptions.scaleOutline;
		}
		if (!scaleOutline) {
			context.save();
		}

		var lineWidth = this.tracePath(context, scaleOutline);

		if (this.fillcolour !== undefined) {
			edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
			context.fill();
		}

		if (!scaleOutline) {
			context.restore();
			context.lineWidth = lineWidth;
		}
		if (this.outlinecolour !== undefined) {
			context.strokeStyle = this.outlinecolour;
			context.stroke();
		}

	}
};

Ellipse.prototype.tracePath = function (context, scaleOutline) {
	var scaleFactor = this.yradius / this.xradius;
	var lineWidth;
	if (this.outlinecolour !== undefined && this.outlinecolour != "transparent") {
		if (scaleOutline) {
			lineWidth = context.lineWidth;
		} else {
			lineWidth = context.lineWidth / scaleFactor;
		}
	} else {
		lineWidth = 0;
	}

	var adjustedXRadius;
	//Not sure what to do when xradius is bigger than 1/2 line width but less than line width, but it isn't correct atm.
	if (this.xradius <= context.lineWidth / 2) {
		lineWidth = this.xradius;
		context.lineWidth = lineWidth;
		adjustedXRadius = this.xradius / 2;
	} else {
		adjustedXRadius = this.xradius - lineWidth / 2;
	}
	context.scale(1, scaleFactor);
	context.beginPath();
	context.arc(this.x, this.y / scaleFactor, adjustedXRadius, 0, 2 * Math.PI, false);
	context.closePath();
	return lineWidth;
}

Ellipse.prototype.isHit = function (context, scale, x, y) {
	this.tracePath(context, false);
	return context.isPointInPath(x,y);
}

Ellipse.prototype.toString = function() {
	var s = "Ellipse(" + Eden.edenCodeForValues(this.x, this.y, this.xradius, this.yradius, this.fillcolour, this.outlinecolour);
	
	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
};

Ellipse.prototype.getEdenCode = Ellipse.prototype.toString;

}}$;

## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

##Taints the canvas if the file is located on another domain.

${{
FillPattern = function (url) {
	this.image = new Image();
	this.canvasesToRepaint = {};
	this.loaded = false;
	
	var me = this;
	
	this.image.onload = function(){
		me.loaded = true;
		for (var viewName in me.canvasesToRepaint) {
			edenUI.plugins.Canvas2D.drawPicture(viewName);
		}
	}
	this.image.src = url;
};
}}$;

/**
 * Create FillPattern object based on an image
 * @param url URL of the image
 */

func FillPattern {
	${{
		return new FillPattern(arguments[0]);
	}}$;
}

${{
	FillPattern.prototype = new EdenUI.plugins.Canvas2D.FillStyle();
	
	FillPattern.prototype.getColour = function (context) {
		return context.createPattern(this.image, 'repeat');
	}

	FillPattern.prototype.toString = function() {
		return "FillPattern(\"" + this.image.src + "\")";
	}

	FillPattern.prototype.getEdenCode = FillPattern.prototype.toString;

}}$;
## Copyright (c) 2016, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt
/**
 * The FlowLayout function has a picture list parameter and itself appears in the picture list.
 * Items within its local picture list behave differently to other items. Their positions are
 * determined automatically!
 * FlowLayout works in the same way that words are conventionally set out in paragraphs. FlowLayout is
 * the paragraph and its items are the words. The items are placed one after another, left to right,
 * wrapping onto another line if necessary.
 * At present only HTML items are supported (so use Div instead of Text, HTMLImage instead of Image).
 * 
 * @param x x-position
 * @param y y-position
 * @param [width]
 * @param items List of items to be displayed
 * @param [drawingOptions] List of drawing options 
 * 
 * #flowlayout #canvas #picture #drawingoptions
 */
func FlowLayout {
${{
	var x = arguments[0];
	var y = arguments[1];
	var width, content, drawingOptions;

	var argsProcessed = 2;
	var arg = arguments[2];

	if (Array.isArray(arg)) {
		content = arg;
		argsProcessed++;
	} else {
		width = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		content = arg;
		argsProcessed++;
	}

	arg = arguments[argsProcessed];

	if (typeof(arg) == "object") {
		drawingOptions = arg;
	}

	return new FlowLayout(x, y, width, content, drawingOptions);
}}$;
}

${{
	FlowLayout = function(x, y, width, content, drawingOptions) {
		this.obsName = root.currentObservableName();
		this.x = x;
		this.y = y;
		this.width = width;
		this.content = content;
		this.drawingOptions = drawingOptions;
	};

	FlowLayout.defaultSpacing = 14;
	FlowLayout.defaultVerticalSpacing = 9;

	FlowLayout.prototype.hash = function () {
		var hash = this.x + "$$" +
			this.y + "$$" +
			this.width + "$$";

		if (Array.isArray(this.content)) {
			for (var i = 0; i < this.content.length; i++) {
				var item = this.content[i];
				if (item.elements === undefined) {
					return hash + Math.random();
				} else {
					hash = hash + item.hash() + "$$";
				}
			}
		}
		
		if (this.drawingOptions !== undefined) {
			hash = hash +
				this.drawingOptions.align + "$$" +
				this.drawingOptions.valign + "$$" +
				this.drawingOptions.spacing + "$$" +
				this.drawingOptions.vspacing;
		}

		return hash;
	};

	FlowLayout.prototype.toString = function () {
		return "FlowLayout(" + Eden.edenCodeForValues(this.x, this.y, this.width, this.content,
			this.drawingOptions) + ")";
	};

	FlowLayout.prototype.draw = function (context, scale, viewName) {
		if (this.elements === undefined && Array.isArray(this.content)) {
			var me = this;

			var container = $(
				'<div class="canvashtml-item canvashtml-flow-layout-item" ' +
				'style="left: ' + this.x + 'px; top: ' + this.y + 'px"' +
				'></div>'
			);
			
			if (this.drawingOptions !== undefined) {
				var align = this.drawingOptions.align;
				if (align == "right") {
					container.css("justify-content", "flex-end");
				} else if (align == "centre" || align == "center") {
					container.css("justify-content", "center");
				} else if (align == "justify") {
					container.css("justify-content", "space-between");
				}
				var vAlign = this.drawingOptions.valign;
				if (vAlign == "bottom") {
					container.css("align-items", "flex-end");
				} else if (vAlign == "baseline") {
					container.css("align-items", "baseline");
				} else if (vAlign !== "top") {
					container.css("align-items", "center");
				}
			} else {
				container.css("align-items", "center");			
			}

			for (var i = 0; i < this.content.length; i++) {
				var item = this.content[i];
				item.draw(context, scale, viewName);
				var childContainer = $('<div class="canvashtml-flow-layout-child"></div>');
				childContainer.append(item.elements);
				container.append(childContainer);
			}

			var objectElement = document.createElement("object");
			objectElement.setAttribute("style", "display: block; position: absolute; top: 0px; left: 0px; " + 
				"height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;");

			objectElement.onload = function () {
				me.resize();
			}
			objectElement.type = "text/html";
			objectElement.data = "about:blank";
			container.append(objectElement);

			this.elements = container;
		}
	}

	FlowLayout.prototype.resize = function () {
		var scale = this.cachedScale;
		if (scale === undefined) {
			//Not yet added drawn onto a canvas.
			return;
		}

		var element = this.elements[0];
		var style = element.style;
		var autoWidth = this.width === undefined;

		var agent = root.lookup("FlowLayout");
		var widthSymName = this.obsName + "_width";
		var heightSymName = this.obsName + "_height";

		var spacing, vSpacing;
		if (this.drawingOptions !== undefined) {
			spacing = this.drawingOptions.spacing;
			vSpacing = this.drawingOptions.vspacing;
		}
		if (spacing === undefined) {
			spacing = FlowLayout.defaultSpacing;
		}
		if (vSpacing === undefined) {
			vSpacing = FlowLayout.defaultVerticalSpacing;
		}

		if (autoWidth || widthSymName in root.symbols) {
			root.lookup(widthSymName).assign((element.offsetWidth - spacing) / scale, agent);
		}

		root.lookup(heightSymName).assign((element.offsetHeight - vSpacing) / scale, agent);
	};

	FlowLayout.prototype.scale = function(scale, zoom, origin) {
		if (!Array.isArray(this.content)) {
			return;
		}

		var align, vAlign, spacing, vSpacing;
		if (this.drawingOptions !== undefined) {
			align = this.drawingOptions.align;
			vAlign = this.drawingOptions.valign;
			spacing = this.drawingOptions.spacing;
			vSpacing = this.drawingOptions.vspacing;
		}
		if (spacing === undefined) {
			spacing = FlowLayout.defaultSpacing;
		}
		if (vSpacing === undefined) {
			vSpacing = FlowLayout.defaultVerticalSpacing;
		}

		var container = this.elements;
		var children = container.children();

		var actualLeft, actualTop;
		var padLeft, padRight, padTop, padBottom;

		if (align == "centre" || align == "center") {
			//Place padding on both sides (left and right)
			padLeft = spacing / 2;
			padRight = spacing / 2;
			actualLeft = this.x - this.width / 2 - spacing / 2;
		} else {
			//Place padding on the left side.
			padLeft = spacing;
			padRight = 0;
			actualLeft = this.x - spacing;
		}

		if (vAlign === undefined || vAlign == "middle") {
			//Place padding on both sides (top and bottom)
			padTop = vSpacing / 2;
			padBottom = vSpacing / 2;
			actualTop = this.y - vSpacing / 2;
		} else {
			//Place padding on the top side
			padTop = vSpacing;
			padBottom = 0;
			actualTop = this.y - vSpacing;
		}

		var containerStyle = container[0].style;
		if (this.width !== undefined) {
			actualWidth = this.width + spacing;
			containerStyle.width = Math.round(actualWidth * scale) + "px";
		}
		if (align == "centre" || align == "center") {
			containerStyle.left = "calc(" + Math.round((this.x + origin.x) * scale) + "px - 50%)";
			containerStyle.width = "100%";
		} else {
			containerStyle.left = Math.round((actualLeft + origin.x) * scale) + "px";
		}
		containerStyle.top =  Math.round((actualTop + origin.y) * scale) + "px";

		for (var i = 0; i < this.content.length; i++) {
			var item = this.content[i];
			var childStyle = children[i].style;
			childStyle.paddingRight = Math.ceil((padRight + item.x) * scale) + "px";
			childStyle.paddingBottom = Math.ceil((padBottom + item.y) * scale) + "px";
			item.scale(scale, zoom, origin);
		}
		children.css("padding-left", Math.floor(padLeft * scale) + "px");
		children.css("padding-top", Math.floor(padTop * scale) + "px");

		this.cachedScale = scale;
		this.resize();
	};

	FlowLayout.prototype.getEdenCode = FlowLayout.prototype.toString;
}}$;
## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

/** Returns a GreyPixelList drawable.  The ptrToData argument should be a pointer to a list of
 * integers.  The first element represents the grey shade of the top-left pixel (0-255) and the
 * subsequent elements represent successive pixels, first along the top row going from left to right
 * and then along the second row, etc.  The data list should contain data for an exact number of rows
 * of the specified width.  The image can be tinted in a particular colour using the optional
 * redMultiply, greenMultiply, blueMultiply, redAdd, greenAdd and blueAdd parameters.
 * redOfResultingPixel = redMultiply * grayscaleValue + redAdd
 * greenOfResultingPixel = greenMultiply * grayscaleValue + redAdd
 * blueOfResultingPixel = blueMultiply * grayscaleValue + blueAdd
 *
 * The resulting red, green and blue values from the above calculations are clipped so that the final
 * values rendered all lie within the range 0 to 255.  This can be used to create effects, for
 * example, multipliers greater than 1 increase the contrast of the image.  Usage of the undefined
 * value in the list of grayscale values causes the relevant pixel to be white and uneffected by the
 * tinting process.
 *
 * The multipliers all default to 1 and the additions all default to adding nothing, i.e. a pure
 * grayscale image is created without a tint.
 * 
 * Example:
 * ````
 * func greyMap {
 *		auto data, i, j, v;
 *		data = [];
 *		for (j = 0; j <= 255; j++) {
 *			for (i = 0; i <= 255; i++) {
 *					v = sqrt((i - 128) * (i - 128) + (j - 128) * (j - 128));
 *					if (v > 115) {
 *						append data, @;
 *					} else {
 *						append data, ((i - 128) * (i - 128) + (j - 128) * (j - 128)) % 256;
 *					}
 *			}
 *		}
		return data;
 *	}
 *	pixelData is greyMap();
 *	pixels is GreyPixelList(&pixelData, mousePosition.x - 128, mousePosition.y - 128, 256);
 *	picture is [pixels];
 *  ````
 *  @param [name]
 *  @param ptrToData Pointer to the pixel data
 *  @param x x-position
 *  @param y y-position
 *  @param width
 *  @param [redMultiply]
 *  @param [blueMultiply]
 *  @param [greenMultiply]
 *  @param [redAdd]
 *  @param [blueAdd]
 *  @param [greenAdd]
 *  @return GreyPixelList drawable
 */

func GreyPixelList {
	${{
		var name;
		var argsProcessed;
		if (typeof(arguments[0]) == "string") {
			name = arguments[0];
			argsProcessed = 1;
		} else {
			argsProcessed = 0;
		}
		var ptrToData = arguments[argsProcessed];
		argsProcessed++;
		var x = arguments[argsProcessed];
		argsProcessed++;
		var y = arguments[argsProcessed];
		argsProcessed++;
		var width = arguments[argsProcessed];
		argsProcessed++;
		var redMultiply = arguments[argsProcessed];
		if (redMultiply === undefined) redMultiply = 1;
		argsProcessed++;
		var greenMultiply = arguments[argsProcessed];
		if (greenMultiply === undefined) greenMultiply = 1;
		argsProcessed++;
		var blueMultiply = arguments[argsProcessed];
		if (blueMultiply === undefined) blueMultiply = 1;
		argsProcessed++;
		var redAdd = arguments[argsProcessed];
		if (redAdd === undefined) redAdd = 0;
		argsProcessed++;
		var greenAdd = arguments[argsProcessed];
		if (greenAdd === undefined) greenAdd = 0;
		argsProcessed++;
		var blueAdd = arguments[argsProcessed];
		if (blueAdd === undefined) blueAdd = 0;
		argsProcessed++;
		return new GreyPixelList(name, ptrToData, x, y, width, redMultiply, greenMultiply, blueMultiply, redAdd, greenAdd, blueAdd);
	}}$;
}

${{
GreyPixelList = function(name, ptrToData, x, y, width, redMultiply, greenMultiply, blueMultiply, redAdd, greenAdd, blueAdd) {
	this.name = edenUI.plugins.Canvas2D.initZoneFromName(name, "GreyPixelList");
	this.obsName = root.currentObservableName();
	this.ptr = ptrToData;
	this.data = ptrToData instanceof Symbol? ptrToData.value() : [];
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = this.data.length / width;
	this.redMultiply = redMultiply;
	this.greenMultiply = greenMultiply;
	this.blueMultiply = blueMultiply;
	this.redAdd = redAdd;
	this.greenAdd = greenAdd;
	this.blueAdd = blueAdd;
}

GreyPixelList.prototype.draw = function(context) {
	var imageData = context.createImageData(this.width, this.height);
	var imageArr = imageData.data;
	var dataArr = this.data;
	var dataArrayLen = dataArr.length;
	var imageArrayLen = dataArrayLen * 4;
	var offset;
	
	offset = 0;
	for (var i = 0; i < dataArrayLen; i++) {
		imageArr[offset] = this.redMultiply * dataArr[i] + this.redAdd;
		offset = offset + 4;
	}

	offset = 1;
	for (var i = 0; i < dataArrayLen; i++) {
		imageArr[offset] = this.greenMultiply * dataArr[i] + this.greenAdd;
		offset = offset + 4;
	}

	offset = 2;
	for (var i = 0; i < dataArrayLen; i++) {
		imageArr[offset] = this.blueMultiply * dataArr[i] + this.blueAdd;
		offset = offset + 4;
	}

	offset = 3;
	for (var i = 0; i < dataArrayLen; i++) {
		if (dataArr[i] !== undefined) {
			imageArr[offset] = 255;
		}
		offset = offset + 4;
	}

	context.putImageData(imageData, this.x, this.y);
}

GreyPixelList.prototype.isHit = function (context, scale, x, y) {
	return x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height &&
	this.data[(y - this.y) * this.width + x - this.x] !== undefined;
}


GreyPixelList.prototype.toString = function() {
	var s = "GreyPixelList(";
	if (this.name !== undefined) {
		s = s + Eden.edenCodeForValue(this.name) + ", ";
	}
	s = s + Eden.edenCodeForValues(this.ptr, this.x, this.y, this.width, this.redMultiply,
		this.redAdd, this.greenMultiply, this.greenAdd, this.blueMultiply, this.blueAdd) + ")";
	return s;
}

GreyPixelList.prototype.getEdenCode = GreyPixelList.prototype.toString;

}}$;

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

##Doesn't taint the canvas if the url is located on another domain.

${{
HTMLImage = function (name, x, y, width, height, asPercent, scaleFactor, url, imageMap) {
	this.name = name;
	this.obsName = root.currentObservableName();
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.asPercent = asPercent;
	this.scaleFactor = scaleFactor;
	this.scaledWidth = width;
	this.scaledHeight = height;
	this.url = url;
	this.imageMap = imageMap;	
}

HTMLImage.prototype.hash = function () {
	return this.name+"$$"+
				this.x+"$$"+
				this.y+"$$"+
				this.width+"$$"+
				this.height+"$$"+
				this.isPercent+"$$"+
				this.scaleFactor+"$$"+
				this.url+"$$"+
				this.imageMap;
};
}}$;

/**
 * Create drawable image for a canvas
 * 
 * @param name Name for click events
 * @param x X-coordinate
 * @param y Y-coordinate
 * @param [width Width in virtual pixel units
 * @param [height] Height in virtual pixel units
 * @param [sizeIsPercentage] Whether width and height are in pixel or percentage units
 * @param [at_scale]] The value of _view_xxx_scale needed to make 1 virtual pixel equal 1 real pixel
 * @param url Source file for the image
 * @param [zones] List of two element lists. The first element of each is the name of an image area. The second is a Circle, Rectangle or Polygon object.
 * 
 * #canvas #image #htmlimage
 */
func HTMLImage { ${{
	var numArgs = arguments.length;
	var argsProcessedFirst, arg, argType;
	
	var name;
	if (typeof(arguments[0]) == "string") {
		name = arguments[0];
		argsProcessedFirst = 1;
	} else {
		argsProcessedFirst = 0;
	}

	var x = arguments[argsProcessedFirst];
	argsProcessedFirst++;
	var y = arguments[argsProcessedFirst];
	argsProcessedFirst++;

	var width, height, asPercent, url, imageMap;
	var scaleFactor = 1;
	var argsLeft = numArgs - argsProcessedFirst;

	if (numArgs == 9 || Array.isArray(arguments[numArgs - 1])) {
		imageMap = arguments[numArgs - 1];
		url = arguments[numArgs - 2];
		argsLeft = argsLeft - 2;
	} else {
		url = arguments[numArgs - 1];
		argsLeft--;
	}


	if (argsLeft > 0) {
		arg = arguments[argsProcessedFirst];
		argType = typeof(arg);
		if (argType == "number" || arg === undefined) {
			width = arg;
			argsProcessedFirst++;
			argsLeft--;
			arg = arguments[argsProcessedFirst];
			argType = typeof(arg);
		}
	}
	if (argsLeft > 0 && (argType == "number" || arg === undefined)) {
		height = arg;
		argsProcessedFirst++;
		argsLeft--;
		arg = arguments[argsProcessedFirst];
		argType = typeof(arg);
	}
	if (argsLeft > 0 && (argType == "boolean" || arg === undefined)) {
		asPercent = arg;
		argsProcessedFirst++;
		argsLeft--;
		arg = arguments[argsProcessedFirst];
		argType = typeof(arg);
	}
	if (argsLeft > 0 && argType == "number") {
		scaleFactor = arg;
	}

	return new HTMLImage(name, x, y, width, height, asPercent, scaleFactor, url, imageMap);
}}$; }

${{
HTMLImage.prototype.draw = function(context) {
  if (this.elements === undefined) {
	var id = "canvas_" + this.name;
	var name = this.name;
	var me = this;

	var html = '<img class="canvashtml-item"';
	if (this.imageMap !== undefined) {
		html = html + ' usemap="#' + id + '-map" draggable="false" class="noselect"';
	}
	html = html + '/>';
	var imageJQ = $(html);

	if (this.scaledWidth === undefined || this.scaledHeight === undefined || this.asPercent) {
		imageJQ.on("load", function (event) {
			var image = event.target;
			var canvasName = edenUI.plugins.Canvas2D.canvasNameFromElement(image);
			var canvasScale = root.lookup("_view_" + canvasName + "_scale").value() * root.lookup("_view_" + canvasName + "_zoom").value();

			if (me.asPercent) {
				if (me.width !== undefined) {
					me.scaledWidth = me.width / 100 * image.naturalWidth;
				}
				if (me.height !== undefined) {
					me.scaledHeight = me.height / 100 * image.naturalHeight;
				}
			}
			if (me.scaledWidth === undefined && me.scaledHeight === undefined) {
				me.scaledWidth = image.naturalWidth;
				me.scaledHeight = image.naturalHeight;
			} else if (me.scaledWidth === undefined) {
				me.scaledWidth = image.naturalWidth * me.scaledHeight / image.naturalHeight;
			}
			if (me.scaledHeight === undefined) {
				me.scaledHeight = image.naturalHeight * me.scaledWidth / image.naturalWidth;
			}
			image.width = Math.round(me.scaledWidth * canvasScale / me.scaleFactor);
			image.height = Math.round(me.scaledHeight * canvasScale / me.scaleFactor);
		});
	}
	imageJQ[0].src = this.url;
	this.elements = [imageJQ.get(0)];

	imageJQ.on("mousemove", function (event) {
		var image = event.target;
		var canvasName = edenUI.plugins.Canvas2D.canvasNameFromElement(image);
		var canvasScale = root.lookup("_view_" + canvasName + "_scale").value() * root.lookup("_view_" + canvasName + "_zoom").value();
		var mouseFollow = root.lookup("mouseFollow").value();
		var imagePos = $(this).offset();
		var x = (event.pageX - Math.round(imagePos.left)) / canvasScale;
		var y = (event.pageY - Math.round(imagePos.top)) / canvasScale;
		root.lookup("mousePosition").assign(new Point(x, y), root.scope, EdenSymbol.hciAgent, mouseFollow);
	});

	if (name !== undefined) {
		edenUI.plugins.Canvas2D.initZoneFromName(name, "HTMLImage");
		imageJQ.on("mousedown", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseDownZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		})
		.on("mouseup", function () {
			edenUI.plugins.Canvas2D.endClick();
		})
		.on("mouseenter", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		});
	}
	
	if (this.imageMap !== undefined) {
		var mapJQ = $("<map name=\"" + id + "-map\" id=\"" + id + "-map\"></map>");

		var setAreaEvents = function (area, regionName) {
			area.on("mouseenter", function (event) {
				var followMouse = root.lookup("mouseFollow").value();
				root.lookup("mouseZone").assign(regionName, root.scope, EdenSymbol.hciAgent, followMouse);
			})
			.on("mousedown", function (event) {
				var followMouse = root.lookup("mouseFollow").value();
				root.lookup("mouseDownZone").assign(regionName, root.scope, EdenSymbol.hciAgent, followMouse);

			}).on("mouseup", function (event) {
				edenUI.plugins.Canvas2D.endClick();
			});
		};

		for (var i = this.imageMap.length - 1; i >= 0; i--) {
			var shape = this.imageMap[i];
			var regionName;
			if (shape.drawingOptions !== undefined) {
				regionName = shape.drawingOptions.name;
			} else {
				regionName = undefined;
			}
			var areaJQ = $('<area ' + shape.imageMapArea() + '/>');
			if (regionName !== undefined) {
				setAreaEvents(areaJQ, regionName);
			} else if (name !== undefined) {
				setAreaEvents(areaJQ, name);
			}
			mapJQ.append(areaJQ);

			if (eden.isValidIdentifier(regionName)) {
				var clickSym = root.lookup(regionName + "_click");
				if (clickSym.value() === undefined) {
					clickSym.assign(false, root.scope, root.lookup("HTMLImage"));
				}
			}
		}
		this.elements.push(mapJQ.get(0));
	}
  }
};

HTMLImage.prototype.scale = function (scale, zoom, origin) {
	var imageElem = this.elements[0];
	var style = imageElem.style;
	style.left = Math.round((this.x + origin.x) * scale) + "px";
	style.top =  Math.round((this.y + origin.y) * scale) + "px";
	imageElem.width = Math.round(this.scaledWidth * scale / this.scaleFactor);
	imageElem.height = Math.round(this.scaledHeight * scale / this.scaleFactor);
};

HTMLImage.prototype.toString = function() {
  return "HTMLImage(" + Eden.edenCodeForValues(this.name, this.x, this.y, this.width, this.height, this.url, this.imageMap) + ")";
};

HTMLImage.prototype.getEdenCode = HTMLImage.prototype.toString;

}}$;

func imageWithZones {
	para p1, p2, p3, p4;
	auto name, width, height, url, imageMap, testing, items, argsProcessed;
	auto i, shape, zoneName, centre;
	items = [];
	if (isString(p2)) {
		name = p1;
		url = p2;
		argsProcessed = 2;
	} else if (isList(p2)) {
		url = p1;
		argsProcessed = 1;
	} else if (isString(p1)) {
		name = p1;
		width = p2;
		height = p3;
		url = p4;
		argsProcessed = 4;
	} else {
		width = p1;
		height = p2;
		url = p3;
		argsProcessed = 3;
	}
	imageMap = ${{arguments[argsProcessed]}}$;
	testing = ${{arguments[argsProcessed + 1]}}$;

	if (testing) {
		append items, Image(name, 0, 0, width, height, url);
		for (i = 1; i <= imageMap#; i++) {
			shape = imageMap[i];
			append items, shape;
			zoneName = shape["drawingOptions"] == @? @ : shape["drawingOptions"]["name"];
			if (zoneName != @) {
				centre = shape["centre"]();
				append items, Div(zoneName, centre["x"] - 5.5 * zoneName#, centre["y"] - 15, @, @, "color: white; background-color: black; font-size: 20px; font-family: monospace");
			}
		}
	} else {
		append items, HTMLImage(name, 0, 0, width, height, url, imageMap);
	}
	return items;
}

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Line = function(x1, y1, x2, y2, colours, drawingOptions) {
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	var align, valign, shift;
	if (drawingOptions !== undefined) {
		align = drawingOptions.align;
		valign = drawingOptions.valign;
	}
	if (this.x1 == this.x2) {
		if (align == "left") {
			shift = -1;
		} else if (align == "right") {
			shift = 1;
		} else {
			shift = 0;
		}
		this.xShift1 = shift;
		this.xShift2 = shift;
		this.yShift1 = 0;
		this.yShift2 = 0;
	} else if (this.y1 == this.y2) {
		if (valign == "top") {
			shift = -1;
		} else if (valign == "bottom") {
			shift = 1;
		} else {
			shift = 0;
		}
		this.xShift1 = 0;
		this.xShift2 = 0;
		this.yShift1 = shift;
		this.yShift2 = shift;
	} else {
		this.xShift1 = this.x2 > this.x1? 1 : -1;
		this.xShift2 = -this.xShift1;
		this.yShift1 = this.y2 > this.y1? 1 : -1;
		this.yShift2 = -this.yShift1;
	}
	this.colours = colours;
	this.drawingOptions = drawingOptions;
}
}}$;

#! Create a drawable line for display on the canvas. See [drawing options](@external CanvasExamples > drawingoptions) for more styling options.
#
# ##Usage Example
#  `Line(startx, starty, endx, endy, "green");`
#  `Line(x1,y1,x2,y2,"red",Object("lineWidth", 10));`
#
# @param x1 Start x-position
# @param y1 Start y-position
# @param x2 End x-position
# @param y2 End y-position
# @param [colour(s)] A HTML colour value for the whole line or a list of HTML colour values to create a gradient
# @param [drawing_options] list of drawing options
# 
#  #canvas #line #drawingoptions #draw
func Line {
${{
	var x1 = arguments[0];
	var y1 = arguments[1];
	var x2 = arguments[2];
	var y2 = arguments[3];
	var colours, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 4) {
		colours = arguments[4];
	}

	if (colours === undefined) {
		colours = ["black"];
	} else if (!Array.isArray(colours)) {
		colours = [colours];
	} else if (colours.length == 0) {
		colours = ["black"];
	}
	return new Line(x1, y1, x2, y2, colours, drawingOptions);
}}$; };

${{

Line.prototype.draw = function(context, scale) {
	context.beginPath();
	var xShift1, xShift2, yShift1, yShift2;
	if (this.drawingOptions !== undefined) {
		var width = (context.lineWidth / 2 + 0.5 / scale) / Math.SQRT2;
		xShift1 = this.xShift1 * width;
		xShift2 = this.xShift2 * width;
		yShift1 = this.yShift1 * width;
		yShift2 = this.yShift2 * width;
		if ((this.xShift1 == 0 || this.yShift1 == 0) && this.drawingOptions.lineWidth % 2 == 1) {
			context.translate(0.5 / scale, 0.5 / scale);
		}
	} else {
		xShift1 = 0;
		xShift2 = 0;
		yShift1 = 0;
		yShift2 = 0;
	}
	var x1 = this.x1 + xShift1;
	var y1 = this.y1 + yShift1;
	var x2 = this.x2 + xShift2;
	var y2 = this.y2 + yShift2;

	if (this.colours.length == 1) {
		context.strokeStyle = this.colours[0];
	} else {
		var colourGradient = context.createLinearGradient(x1, y1, x2, y2);
		for (var i = 0; i < this.colours.length; i++) {
			colourGradient.addColorStop(i / (this.colours.length - 1), this.colours[i]);
		}
		context.strokeStyle = colourGradient;
	}

	context.moveTo(x1, y1);
	context.lineTo(x2, y2);
	context.stroke();

	if (this.drawingOptions !== undefined && this.drawingOptions.arrowhead instanceof Arrowhead) {
		var gradient = (y2 - y1) / (x2 - x1);
		var reversed = x1 > x2;
		this.drawingOptions.arrowhead.draw(context, scale, x1, y1, gradient, reversed, x2, y2, gradient, reversed);
	}
};

Line.prototype.toString = function(p) {
	var s = "Line(" + Eden.edenCodeForValuesP(p,this.x1, this.y1, this.x2, this.y2) + ", ";

	if (this.colours.length > 1) {
		s = s + Eden.edenCodeForValue(this.colours, undefined, p);
	} else {
		s = s + Eden.edenCodeForValue(this.colours[0], undefined, p);	
	}

	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions, undefined, p);
	}
	
	s = s + ")";
	return s;
};

Line.prototype.getEdenCode = Line.prototype.toString;

}}$;

func distanceMoved {
	${{
		var from, to;
		if (arguments.length == 1) {
			if (arguments[0] instanceof Line) {
				var line = arguments[0];
				from = new Point(line.x1, line.y1);
				to = new Point(line.x2, line.y2);
			} else {
				to = arguments[0];
				from = new Point(0, 0);
			}
		} else if (arguments.length == 2) {
			from = arguments[0];
			to = arguments[1];
			if (from === undefined) {
				return undefined;
			} else if (!(from instanceof Point)) {
				eden.error(new Error("distanceMoved: The first argument must be a Point, not a " + typeof(from)), "error");
				return undefined;
			}
		} else {
			eden.error(new Error("distanceMoved: This function requires at least 1 argument and at most 2 arguments"), "error");
			return undefined;
		}
		if (to === undefined) {
			return undefined;
		} else if (!(to instanceof Point)) {
			eden.error(new Error("distanceMoved: The destination point must be a Point or a Line, not a " + typeof(to)), "error");
			return undefined;
		}
		if (from.x == undefined || from.y == undefined || to.x == undefined || to.y == undefined) {
			return undefined;
		}
		var xDist = to.x - from.x;
		var yDist = to.y - from.y;
		return Math.sqrt(xDist * xDist + yDist * yDist);
	}}$;
}

func angleTurned {
	${{
		var from, to;
		if (arguments[0] instanceof Folder) {
			//Probably not an actual function call but semicircleAngle observable changed.
			return undefined;
		} else if (arguments.length == 1) {
			to = arguments[0];
			from = new Point(0, 0);
		} else if (arguments.length == 2) {
			from = arguments[0];
			to = arguments[1];
			if (from === undefined) {
				return undefined;
			} else if (!(from instanceof Point)) {
				eden.error(new Error("angleTurned: The first argument must be a Point, not a " + typeof(from)), "error");
				return undefined;
			}
		} else {
			eden.error(new Error("angleTurned: This function requires at at least 1 argument and most 2 arguments"), "error");
			return undefined;
		}
		if (to === undefined) {
			return undefined;
		} else if (!(to instanceof Point)) {
			eden.error(new Error("angleTurned: The destination point must be a Point, not a " + typeof(to)), "error");
			return undefined;
		}
		if (from.x == undefined || from.y == undefined || to.x == undefined || to.y == undefined) {
			return undefined;
		}
		var relativeX = to.x - from.x;
		var relativeY = to.y - from.y;
		return Math.atan2(relativeY, relativeX) * root.lookup("semicircleAngle").value() / Math.PI;
	}}$;
}
semicircleAngle ~> [angleTurned];

# Copyright (c) 2015, Empirical Modelling Group
# All rights reserved.
#
# See LICENSE.txt


#! Creates a LinearGradient that can be used to colour shapes.
# @param x1 X-coordinate for start
# @param y1 Y-coordinate for start
# @param x2 X-coordinate for end
# @param y2 Y-coordinate for end
# @param [start_colour Start Colour
# @param end_colour] End Colour
# @param [extra_colour_stops] A list of two item lists.  The first element of each is a point along the gradient (0.0-1.0).  The second is the colour.
# 
# Usage example: 
# 
# 	`x = 50;`
# 	`y = 50;`
# 	`width = 400;`
# 	`height = 250;`
# 	`gradient is LinearGradient(x, y, x + width, y + height, "cyan", "blue");`
# 	`rect is Rectangle(x, y, width, height, gradient);`
# 	`picture is [rect];`
#
#  #canvas #colour #gradient #lineargradient #library
func LinearGradient {
	${{
		var x1 = arguments[0];
		var y1 = arguments[1];
		var x2 = arguments[2];
		var y2 = arguments[3];
		var colourStops;
		if (Array.isArray(arguments[4])) {
			colourStops = arguments[4];
		} else {
			if (Array.isArray(arguments[6])) {
				colourStops = arguments[6];
			} else {
				colourStops = [];
			}
			
			var start_colour = arguments[4];
			if (typeof(start_colour) != "string") {
				start_colour = "black";
			}
			
			var end_colour = arguments[5];
			if (typeof(end_colour) != "string") {
				end_colour = "white";
			}
			
			colourStops.push([0, start_colour]);
			colourStops.push([1, end_colour]);
		}
		return new LinearGradient(x1, y1, x2, y2, colourStops);
	}}$;
}

${{
	LinearGradient = function(x1, y1, x2, y2, colourStops) {
		this.x1 = x1;
		this.y1 = y1;
		this.x2 = x2;
		this.y2 = y2;
		this.colourStops = colourStops;
	}
	
	LinearGradient.prototype = new EdenUI.plugins.Canvas2D.FillStyle();
	
	LinearGradient.prototype.getColour = function (context) {
		var gradient = context.createLinearGradient(this.x1, this.y1, this.x2, this.y2);
		var colourStop;
		for (var i = 0; i < this.colourStops.length; i++) {
			colourStop = this.colourStops[i];
			gradient.addColorStop(colourStop[0], colourStop[1]);
		}
		return gradient;
	};

	LinearGradient.prototype.toString = function() {
		return "LinearGradient(" + Eden.edenCodeForValues(this.x1, this.y1, this.x2, this.y2, this.colourStops) + ")";
		
	};

	LinearGradient.prototype.getEdenCode = LinearGradient.prototype.toString;

}}$;

## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
LineSequence = function(vertices, colours, drawingOptions) {
	this.vertices = vertices;
	this.colours = colours;
	this.drawingOptions = drawingOptions;

	this.minX = this.vertices[0].x;
	this.minY = this.vertices[0].y;
	this.maxX = this.minX, this.maxY = this.minY;
	for (var i = 1; i < this.vertices.length; i++) {
		var vertex = this.vertices[i];
		if (vertex.x < this.minX) {
			this.minX = vertex.x;
		} else if (vertex.x > this.maxX) {
			this.maxX = vertex.x;
		}
		if (vertex.y < this.minY) {
			this.minY = vertex.y;
		} else if (vertex.y > this.maxY) {
			this.maxY = vertex.y;
		}
	}
}
}}$;

#! Creates a sequence of joined lines for display on the canvas from a list of Points. This produces a better visual result than just using normal lines. See [drawing options](@external CanvasExamples > drawingoptions) for more style options.
# 
# ##Usage Example
#  `LineSequence(pointslist, "blue");`
#  `LineSequence([Point(ax,ay),Point(bx,by),Point(cx,cy)]);`
#
# @param points List of coordinates in the form Point(x, y) from the top left corner of the canvas
# @param [colour(s)] Colour of the line as a HTML colour value, or a list of such colour values
# @param [drawing_options] List of drawingOptions
# 
#  #canvas #line #linesequence #drawingoptions #draw
func LineSequence {
${{
	var vertices = arguments[0];
	var colours, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo == 1) {
		colours = arguments[1];
	}

	if (colours === undefined) {
		colours = ["black"];
	} else if (!Array.isArray(colours)) {
		colours = [colours];
	} else if (colours.length == 0) {
		colours = ["black"];
	}

	return new LineSequence(vertices, colours, drawingOptions);
}}$; };

${{
LineSequence.prototype.draw = function(context, scale) {
	if (this.drawingOptions !== undefined && this.drawingOptions.lineWidth % 2 == 1) {
		context.translate(0.5 / scale, 0.5 / scale);
	}

	context.beginPath();
	var maxVertex = this.vertices.length - 1;
	if (this.colours.length == 1) {
		context.strokeStyle = this.colours[0];
	} else {
		var gradient = context.createLinearGradient(this.minX, this.minY, this.maxX, this.maxY);
		for (var i = 0; i < this.colours.length; i++) {
			gradient.addColorStop(i / (this.colours.length - 1), this.colours[i]);
		}
		context.strokeStyle = gradient;
	}

	context.moveTo(this.vertices[0].x, this.vertices[0].y);
	for (var i = 1; i <= maxVertex; i++) {
		context.lineTo(this.vertices[i].x, this.vertices[i].y);
	}
	
	context.stroke();

	if (this.drawingOptions !== undefined && this.drawingOptions.arrowhead instanceof Arrowhead) {
		var vertex0 = this.vertices[0];
		var vertex1 = this.vertices[1];
		var vertexN = this.vertices[maxVertex];
		var vertexNMinus1 = this.vertices[maxVertex - 1];
		var gradient1 = (vertex1.y - vertex0.y) / (vertex1.x - vertex0.x);
		var gradient2 = (vertexN.y - vertexNMinus1.y) / (vertexN.x - vertexNMinus1.x);
		var reverse1 = vertex0.x > vertex1.x;
		var reverse2 = vertexNMinus1.x > vertexN.x;
		this.drawingOptions.arrowhead.draw(context, scale, vertex0.x, vertex0.y, gradient1, reverse1,
			vertexN.x, vertexN.y, gradient2, reverse2);
	}	
};

LineSequence.prototype.toString = function() {
	var s = "LineSequence(" + Eden.edenCodeForValue(this.vertices) + ",";
	
	if (this.colours.length > 1) {
		s = s + Eden.edenCodeForValue(this.colours);
	} else {
		s = s + Eden.edenCodeForValue(this.colours[0]);	
	}

	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
};

LineSequence.prototype.getEdenCode = LineSequence.prototype.toString;

}}$;

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Pixel = function(x, y, colour) {
  this.x = x;
  this.y = y;
  this.colour = colour;
}
}}$;

/*
 * Creates a pixel that can be displayed on a canvas
 * 
 * @param x x-position
 * @param y y-position
 * @param colour colour
 * 
 */
func Pixel { ${{
  var x = arguments[0];
  var y = arguments[1];
  var colour = arguments[2];
  return new Pixel(x, y, colour);
}}$; };

${{
Pixel.prototype.toString = function() {
  return "Pixel("+ Eden.edenCodeForValues(this.x, this.y, this.colour) + ")";
};

Pixel.prototype.getEdenCode = Pixel.prototype.toString;
}}$;

${{
Pixel.prototype.draw = function(context) {
  context.fillStyle = this.colour;
  context.fillRect( this.x, this.y, 1, 1);
};
}}$;
## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Polygon = function(vertices, fillcolour, outlinecolour, drawingOptions, centreY) {
	this.vertices = vertices;
	this.fillcolour = fillcolour;
	this.outlinecolour = outlinecolour;
	this.drawingOptions = drawingOptions;
	this.centreY = centreY; //Used by RegularPolygon
	this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Polygon");
	this.obsName = root.currentObservableName();
}
}}$;

#! Creates a Polygon object for display on a canvas. You give a list of points and it will draw lines between them and then, optionally, fill the area inside. It will automatically join the last point to the first to close the shape. See [drawing options](@external CanvasExamples > drawingoptions) for more style options.
#
# ##Usage Example
#   `Polygon(pointslist, "green", "black");`
#	`Polygon([Point(10,10),Point(20,20),Point(10,20)]);`
#
# @param points List of coordinates in the form {x, y} from the top left corner of the canvas
# @param [fill_colour Colour of the polygon (fill) in HTML form
# @param [outline_colour]]
# @param [drawing_options] List of drawing options
# 
#  #canvas #polygon #drawingoptions #shape #area #triangle #octagon #hexagon #pentagon #poly #draw
func Polygon {
${{
	var vertices = arguments[0];
	if (vertices[0].x != vertices[vertices.length - 1].x || vertices[0].y != vertices[vertices.length - 1].y) {
		vertices.push(vertices[0]);
	}

	var fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 1) {
		fillcolour = arguments[1];
		if (processUpTo == 2) {
			outlinecolour = arguments[2];
		}
	}

	if (outlinecolour === undefined) {
		if (fillcolour === undefined) {
			outlinecolour = "black";
		}
	}

	return new Polygon(vertices, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

Polygon.prototype.draw = function (context, scale) {
	if (this.drawingOptions !== undefined && this.drawingOptions.lineWidth % 2 == 1) {
		context.translate(0.5 / scale, 0.5 / scale);
	}

	this.tracePath(context, scale);

	if (this.fillcolour !== undefined) {
		edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
		context.fill();
	}
	
	if (this.outlinecolour !== undefined) {
		context.strokeStyle = this.outlinecolour;
		context.stroke();
	}
};

Polygon.prototype.tracePath = function (context, scale) {
	context.beginPath();
	if (scale < 0 && this.centreY !== undefined) {
		var a = 2 * this.centreY;
		context.moveTo(this.vertices[0].x, a - this.vertices[0].y);
		for (var i = 1; i < this.vertices.length; i++) {
			context.lineTo(this.vertices[i].x, a - this.vertices[i].y);
		}
	} else {
		context.moveTo(this.vertices[0].x, this.vertices[0].y);
		for (var i = 1; i < this.vertices.length; i++) {
			context.lineTo(this.vertices[i].x, this.vertices[i].y);
		}
	}
	context.closePath();
}

Polygon.prototype.isHit = function (context, scale, x, y) {
	this.tracePath(context, scale);
	return context.isPointInPath(x,y);
}

Polygon.prototype.toString = function() {
	var s = "Polygon(" + Eden.edenCodeForValues(this.vertices, this.fillcolour, this.outlinecolour);

	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
};

Polygon.prototype.getEdenCode = Polygon.prototype.toString;

Polygon.prototype.imageMapArea = function () {
	var s = "shape=\"poly\" coords=\"";
	for (var i = 0; i < this.vertices.length; i++) {
		var vertex = this.vertices[i];
		s = s + vertex.x + "," + vertex.y + ",";
	}
	s = s.slice(0, -1);
	s = s + "\"";
	return s;
}

Polygon.prototype.centre = function () {
	var centreX = 0, centreY = 0;
	for (var i = 0; i < this.vertices.length; i++) {
		centreX = centreX + this.vertices[i].x;
		centreY = centreY + this.vertices[i].y;
	}
	centreX = centreX / this.vertices.length;
	centreY = centreY / this.vertices.length;
	return new Point(centreX, centreY);
}

}}$;

## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

##Example:

/*
 * Creates a radial gradient that can be used to colour shapes
 * 
 * @param x
 * @param y
 * @param [r radius
 * @param [colourStops]] List of colourStops
 * 
 * ```
 * g is RadialGradient(300, 240, 230, [[0, "red"], [0.5, "orange"], [1, "cyan"]]);
 * c is Circle(300,240,230,g);
 * picture is [c];
 * ```
 */
	
func RadialGradient {
	${{
		var x1, y1, r1, x2, y2, r2, colourStops;
		x1 = arguments[0];
		y1 = arguments[1];
		
		switch (arguments.length) {
			case 4:
				r1 = 0;
				x2 = x1;
				y2 = y1;
				r2 = arguments[2];
				colourStops = arguments[3];
				break;
		}
		return new RadialGradient(x1, y1, r1, x2, y2, r2, colourStops);
	}}$;
}

${{
	RadialGradient = function(x1, y1, r1, x2, y2, r2, colourStops) {
		this.x1 = x1;
		this.y1 = y1;
		this.r1 = r1;
		this.x2 = x2;
		this.y2 = y2;
		this.r2 = r2;
		this.colourStops = colourStops;
	}
	
	RadialGradient.prototype = new EdenUI.plugins.Canvas2D.FillStyle();

	RadialGradient.prototype.getColour = function (context) {
		var gradient = context.createRadialGradient(this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);
		var colourStop;
		for (var i = 0; i < this.colourStops.length; i++) {
			colourStop = this.colourStops[i];
			gradient.addColorStop(colourStop[0], colourStop[1]);
		}
		return gradient;
	};

	RadialGradient.prototype.toString = function() {
		return "RadialGradient(" + Eden.edenCodeForValues(this.x1, this.y1, this.r1, this.x2, this.y2, this.r2, this.colourStops) + ")";
		
	};

	RadialGradient.prototype.getEdenCode = RadialGradient.prototype.toString;

}}$;

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
RadioButtons = function (name, values, labels, x, y, width, horizontal, enabled) {
	this.name = name;
	this.obsName = root.currentObservableName();
	this.values = values;
	this.labels = labels;
	this.x = x;
	this.y = y;
	this.width = width;
	this.horizontal = horizontal;
    this.enabled = enabled;
}

RadioButtons.prototype.hash = function () {
	return this.name+"$$"+
				(Array.isArray(this.values)? this.values.join("$$") : "") +
				(Array.isArray(this.labels)? this.labels.join("$$") : "") +
				this.x+"$$"+
				this.y+"$$"+
				this.width+"$$"+
				this.horizontal+"$$"+
				this.enabled
};
}}$;

/**
 * Generates a set of radio buttons
 * 
 * @param [name] Prefix for _value observable.  Default is the name of the observable being defined.
 * @param values A list of strings providing the options
 * @param [labels]
 * @param x X-coordinate
 * @param y Y-coordinate
 * @param [width] Width in pixels
 * @param [is_horizontal
 * @param [enabled]] Boolean to determine if the radio buttons are enabled
 */
func RadioButtons { ${{
	var argsProcessed;

	var name;
	if (typeof(arguments[0]) == "string") {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("RadioButtons: Every group of radio buttons must have a name."), "error");
			return undefined;
		}
	}

	var values = arguments[argsProcessed];
	argsProcessed++;
	var labels;
	if (Array.isArray(arguments[argsProcessed])) {
		labels = arguments[argsProcessed];
		argsProcessed++;
	} else {
		labels = values;
	}
	var x = arguments[argsProcessed];
	argsProcessed++;
	var y = arguments[argsProcessed];
	argsProcessed++;
	var width;
	if (typeof(arguments[argsProcessed]) ==  "number" || arguments.length - argsProcessed > 2) {
		width = arguments[argsProcessed];
		argsProcessed++;
	}
	var horizontal = arguments[argsProcessed];
	argsProcessed++;
	var enabled = arguments[argsProcessed];

	return new RadioButtons(name, values, labels, x, y, width, horizontal, enabled);
}}$; }

${{

RadioButtons.prototype.makeHTML = function() {
	var build = "";
	var disabled = this.enabled === false? ' disabled="disabled"' : '';

	for (var i = 0; i < this.values.length; i++) {
		build = build + '<label><input type="radio" name="' + this.name +
			'" value="' + this.values[i] + '"' + disabled + '/> ' +
			this.labels[i] + '</label><br/>';
	}

	if (this.horizontal) {
		return '<form class="canvashtml-item canvas-horizontal-radio-buttons">' + build + '</form>';
	} else {
		return '<form class="canvashtml-item">' + build + '</form>';
	}
};

RadioButtons.prototype.draw = function (context) {

	if(this.elements === undefined) {
		var name = this.name;

		//Make the HTML
		var formJQ = $(this.makeHTML());

		var formElement = formJQ.get(0);
		var updateValue = function (buttonGroup, value) {
			for (var i = 0; i < buttonGroup.length; i++) {
				if (buttonGroup[i].value == value) {
					buttonGroup[i].checked = true;
					break;
				} else {
					//Possibility of having no radio button selected.
					buttonGroup[i].checked = false;
				}
			}
		
		};
		var valueSym = root.lookup(name + "_value");
		var initialValue = valueSym.value();
		if (initialValue !== undefined) {
			updateValue(formElement.elements, initialValue);
		}
		valueSym.addJSObserver("updateUI", function (symbol, value) {
			updateValue(formElement.elements, value);
		});

		formJQ.change(function(event) {
			root.lookup(name + "_value").assign(event.target.value, root.scope, EdenSymbol.hciAgent, true);
		})
		.on("mousedown", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseDownZone").assign(undefined, root.scope, EdenSymbol.hciAgent, mouseFollow);
		})
		.on("mouseup", function () {
			edenUI.plugins.Canvas2D.endClick();
		})
		.on("mouseenter", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		});

		this.elements = [formElement];
	}
};

RadioButtons.prototype.scale = function (scale, zoom, origin) {
	var elem = this.elements[0];
	var style = elem.style;
	style.left = Math.round((this.x + origin.x) * scale) + "px";
	style.top =  Math.round((this.y + origin.y) * scale) + "px";
	if (this.width === undefined) {
		style.width = "";
	} else {
		style.width = Math.round(this.width * scale) + "px";
	}
	style.fontSize = zoom + "em";
	var buttonSize = Math.round(13 * zoom) + "px";
	$(elem).find("input").css({width: buttonSize, height: buttonSize});
};

RadioButtons.prototype.toString = function() {
	if (this.name == this.obsName) {
		return "RadioButtons(" + Eden.edenCodeForValues(this.values, this.labels, this.x,
			this.y, this.width, this.horizontal, this.enabled) + ")";
	} else {
		return "RadioButtons(" + Eden.edenCodeForValues(this.name, this.values, this.labels, this.x,
			this.y, this.width, this.horizontal, this.enabled) + ")";
	}
};

RadioButtons.prototype.getEdenCode = RadioButtons.prototype.toString;

}}$;

/* Copyright (c) 2013, Empirical Modelling Group
 * All rights reserved.
 *
 * See LICENSE.txt
 */

ortho_factor = 1280;
ortho_aspect = 9/16;

#! Creates a rectangle that can be coloured and displayed on a canvas. See [drawing options](@external CanvasExamples > drawingoptions) for more style options.
#
# ##Usage Example
#  `Rectangle(x,y,width,height);`
#  `Rectangle(x,y,w,h, "green", "black", Object("lineWidth", 5));`
#
# @param x X-coordinate for top left
# @param y Y-coordinate for top left
# @param width
# @param height
# @param [fill_colour
# @param [outline_colour]] Colour of the rectangle outline in HTML form
# @param [drawing_options] List of drawing options
# 
#  #canvas #rectangle #drawingoptions #square #box #shape #draw
/*Rectangle is Plane::(Point3D::(($1 / (ortho_factor/2)) - 1.0,((-$2) / (ortho_factor/2)) + (ortho_aspect),-2.0),scale=Point3D::($3/ortho_factor,$4/ortho_factor,0.1),material=$5,ortho=true);
*/
func Rectangle {
	para x,y,width,height,fill,outline;
	return Plane::(Point3D::((x / (ortho_factor/2)) - 1.0,((-y) / (ortho_factor/2)) + (ortho_aspect),-2.0),scale=Point3D::(width/ortho_factor,height/ortho_factor,0.1),material=fill,ortho=true);
}



${{
	RegularPolygon = function (x, y, r, n, star, rotation, interiorOutline, fillcolour, outlinecolour, drawingOptions) {
		this.x = x;
		this.y = y;
		this.r = r;
		this.n = n;
		this.star = star;
		star = Math.floor(star);
		this.interiorOutline = interiorOutline;
		this.rotation = rotation;
		this.rotationInRadians = rotation * Math.PI / root.lookup("semicircleAngle").value();
		this.fillcolour = fillcolour;
		this.outlinecolour = outlinecolour;
		this.drawingOptions = drawingOptions;
		this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "RegularPolygon");
		this.obsName = root.currentObservableName();

		this.exteriorAngle = (2 * Math.PI) / n;
		this.vertices = [];
		var pointsDone = new Array(n);
		var px, py;
		var currentPolygonVertices, currentPoint;
		var nudge;
		if (drawingOptions !== undefined && drawingOptions.valign == "bottom") {
			if (drawingOptions.lineWidth !== undefined) {
				nudge = drawingOptions.lineWidth;
			} else {
				nudge = 2;
			}
		} else {
			nudge = 0;
		}
		var rotation2;
		if (n % 4 == 0) {
			rotation2 = -this.rotationInRadians - Math.PI * (0.5 - 1 / n);
		} else {
			rotation2 = -this.rotationInRadians - Math.PI * (0.5 - 2 / n); //Zero rotation means "pointing upwards"
		}
		for (var i = 0; i < n; i++) {
			var j = i;
			currentPolygonVertices = [];
			while (pointsDone[j] !== true) {
				px = x + r * Math.cos(rotation2 + j * this.exteriorAngle);
				py = y + r * Math.sin(rotation2 + j * this.exteriorAngle) + nudge;
				currentPoint = new Point(px, py);
				currentPolygonVertices.push(currentPoint);
				pointsDone[j] = true;
				j = (j + star) % n;
			}
			if (currentPolygonVertices.length > 0) {
				this.vertices = this.vertices.concat(currentPolygonVertices);
			}
		}
		if (outlinecolour === undefined && star % n != 0) {
			this.calculatePolygons(0);
		}
	}

	RegularPolygon.degenerateMonogramRadii = 7;

	RegularPolygon.prototype.calculatePolygons = function (lineWidth, scale) {
		var radius;
		var rotation;
		if (this.n % 4 == 0) {
			rotation = -this.rotationInRadians - Math.PI * (0.5 - 1 / this.n);
		} else {
			rotation = -this.rotationInRadians - Math.PI * (0.5 - 2 / this.n); //Zero rotation means "pointing upwards"
		}

		var nudge;
		if (this.drawingOptions !== undefined && this.drawingOptions.valign == "bottom") {
			nudge = lineWidth;
		} else {
			nudge = 0;
		}

		var px, py;
		var polygons = [];
		this.outlinePolygons = [];
		var star = Math.floor(this.star);
		if (star % this.n == 0) {
			var circlesRadius = RegularPolygon.degenerateMonogramRadii / scale + (this.outlinecolour === undefined? 0 : lineWidth * 2);
			radius = this.r - circlesRadius;
			for (var i = 0; i < this.n; i++) {
				px = this.x + radius * Math.cos(rotation + i * this.exteriorAngle);
				py = this.y + radius * Math.sin(rotation + i * this.exteriorAngle) + nudge;
				polygons.push(new Circle(px, py, circlesRadius, this.fillcolour, this.outlinecolour, this.drawingOptions));
			}
			this.filledPolygons = polygons;
			return;
		}

		radius = this.r - lineWidth / 2
		var separatePolygonsPossiblyNeeded;
		if (this.fillcolour !== undefined && this.fillcolour != "transparent" &&
			this.outlinecolour !== undefined &&
			this.n / star != 2
		) {
			separatePolygonsPossiblyNeeded = true;
		} else {
			separatePolygonsPossiblyNeeded = false;		
		}
		
		var pointsDone = new Array(this.n);
		var currentPolygonVertices, currentPoint;
		for (var i = 0; i < this.n; i++) {
			var j = i;
			currentPolygonVertices = [];
			while (pointsDone[j] !== true) {
				px = this.x + radius * Math.cos(rotation + j * this.exteriorAngle);
				py = this.y + radius * Math.sin(rotation + j * this.exteriorAngle) + nudge;
				currentPoint = new Point(px, py);
				currentPolygonVertices.push(currentPoint);
				pointsDone[j] = true;
				j = (j + star) % this.n;
			}
			if (currentPolygonVertices.length > 0) {
				polygons.push(new Polygon(currentPolygonVertices, this.fillcolour, this.outlinecolour, this.drawingOptions, this.y));
			}
		}
		if (separatePolygonsPossiblyNeeded) {
			if (polygons.length == 1) {
				if (!this.interiorOutline) {
					/* Case: single constituent polygon (e.g. five-pointed star) with an outline but
					 * not an outline drawn in inside the shape (i.e. a star or a pentagon rather
					 * than a pentagram).
					 * Solution: add extra polygons to over-paint those inside edges that we don't want.
					 * N.B. We can (and do) safely ignore these extra polygons when performing hit testing.
					 */
					var smallerRadius = this.r - lineWidth;
					currentPolygonVertices = [];
					i = 0;
					do {
						px = this.x + smallerRadius * Math.cos(rotation + i * this.exteriorAngle);
						py = this.y + smallerRadius * Math.sin(rotation + i * this.exteriorAngle);
						currentPoint = new Point(px, py);
						currentPolygonVertices.push(currentPoint);
						i = (i + star) % this.n;
					} while (i != 0);
					polygons.push(new Polygon(currentPolygonVertices, this.fillcolour, undefined, this.drawingOptions, this.y));
				} else {
					/* Case: the user wants to see the edges that intersect the interior of the
					 * polygon.
					 */
				}
				this.filledPolygons = polygons;
			} else {
				/* Case: multiple constituent polygons (specifically, more than 2).  Occurs when
				 * n / star is an integer greater than 2.
				 * Solution: Paint the fill and the outline as separate polygons.  The requirement
				 * to show or hide the interior edges determines whether the outlines are painted
				 * first or the fill is painted first.
				 */
				this.filledPolygons = [];
				for (var i = 0; i < polygons.length; i++) {
					this.filledPolygons.push(new Polygon(polygons[i].vertices, this.fillcolour, undefined, this.drawingOptions, this.y));
				}
				for (var i = 0; i < polygons.length; i++) {
					this.outlinePolygons.push(new Polygon(polygons[i].vertices, undefined, this.outlinecolour, this.drawingOptions, this.y));
				}
			}
		} else {
			/* Case: the outline doesn't have intersecting edges (or only degenerate ones, i.e. n / star = 2),
			 * or doesn't have an outline, or doesn't have a fill colour.
			 * N.B: n / star = 2 is the degenerate case when a polygon is reduced to being a set of unconnected lines.
			 * Solution: One set of polygons that paint either the fill or the outline (the shape doesn't have both).
			 */
			this.filledPolygons = polygons;
		}	
	}
}}$;

/**
 * Creates a polygon for display on a canvas
 * 
 * centre_x
 * centre_y
 * radius
 * n_sides Number of sides
 * [star_factor] Produces simple polygon if 1, if 2 it connects every other vertex, if 3 it connects every third vertex, etc.
 * [is_interior_outlined] true or false to draw internal lines in polygon (only has effect if fill colour is set).
 * [rotation] Rotation in degrees
 * [fill_colour Colour to fill the interior of the polygon with
 * [outline_colour]] Colour of the outline
 * [drawing_options] List of drawing options
 * 			
 * 
 * #canvas #drawingOptions #regularPolygon #polygon #drawingOptions
 */

func RegularPolygon {
	${{
		var maxArgs = 10;
		var numArgs = arguments.length;
		var x = arguments[0];
		var y = arguments[1];
		var r = arguments[2];
		var n = arguments[3];
		var star, rotation, interiorOutline;
		var fillcolour, outlinecolour, drawingOptions;
		var argsProcessed = 4;
		if (typeof(arguments[4]) == "number") {
			star = arguments[4];
			argsProcessed++;
		}
		if (numArgs - argsProcessed > maxArgs - 5) { argsProcessed = 5; }

		if (typeof(arguments[argsProcessed]) == "boolean") {
			interiorOutline = arguments[argsProcessed];
			argsProcessed++;
		}
		if (numArgs - argsProcessed > maxArgs - 6) { argsProcessed = 6; }

		if (typeof(arguments[argsProcessed]) == "number") {
				rotation = arguments[argsProcessed];
				argsProcessed++;
		}
		if (numArgs - argsProcessed > maxArgs - 7) { argsProcessed = 7; }

		var lastArg = arguments[numArgs - 1];
		var processUpTo;
		if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
			drawingOptions = lastArg;
			processUpTo = numArgs - 2;
		} else {
			processUpTo = numArgs - 1;
		}
		if (processUpTo >= argsProcessed) {
			fillcolour = arguments[argsProcessed];
			argsProcessed++;
			if (processUpTo == argsProcessed) {
				outlinecolour = arguments[argsProcessed];
			}
		}

		if (star === undefined) {
			star = 1;
		}

		if (rotation === undefined) {
			if (star <= -n || star >= n) {
				rotation = star;
				star = 1;
			} else {
				rotation = 0;
			}
		}

		if (outlinecolour === undefined) {
			if (fillcolour === undefined || interiorOutline) {
				outlinecolour = "black";
			}
		}
		if (interiorOutline === undefined) {
			interiorOutline = true;
		}

		if (drawingOptions !== undefined) {
			if (!("join" in drawingOptions)) {
				drawingOptions.join = "round";
			}
		}
		
		if (n === Infinity) {
			return new Circle(x, y, r, fillcolour, outlinecolour, drawingOptions);
		} else {
			return new RegularPolygon(x, y, r, n, star, rotation, interiorOutline, fillcolour, outlinecolour, drawingOptions);
		}
	}}$;
}
semicircleAngle ~> [RegularPolygon];

${{
RegularPolygon.prototype.draw = function (context, scale) {
	var lineWidth = context.lineWidth;
	if (!this.interiorOutline) {
		lineWidth = lineWidth * 2;
	}
	if (this.outlinecolour !== undefined || Math.floor(this.star) % this.n == 0) {
		if (lineWidth !== this.cachedPolygonLineWidth) {
			this.calculatePolygons(lineWidth, scale);
			this.cachedPolygonLineWidth = lineWidth;
		}
	}

	if (this.interiorOutline) {
		for (var i = 0; i < this.filledPolygons.length; i++) {
			this.filledPolygons[i].draw(context, scale);
		}
		for (var i = 0; i < this.outlinePolygons.length; i++) {
			this.outlinePolygons[i].draw(context, scale);
		}
	} else {
		context.lineWidth = lineWidth;
		for (var i = 0; i < this.outlinePolygons.length; i++) {
			this.outlinePolygons[i].draw(context, scale);
		}
		context.lineWidth = lineWidth / 2;
		for (var i = 0; i < this.filledPolygons.length; i++) {
			this.filledPolygons[i].draw(context, scale);
		}
	}
}

RegularPolygon.prototype.isHit = function (context, scale, x, y) {
	var hit;
	var star = Math.floor(this.star);
	var ratio = this.n / star;
	var limit;
	if (this.fillcolour !== undefined && this.fillcolour != "transparent" &&
		this.outlinecolour !== undefined &&
		ratio != 2 &&
		(star == 1 || ratio != Math.floor(ratio)) &&
		!this.interiorOutline
	) {
		limit = this.filledPolygons.length / 2;
	} else {
		limit = this.filledPolygons.length;
	}
	for (var i = 0; i < limit; i++) {
		hit = this.filledPolygons[i].isHit(context, scale, x, y);
		if (hit) {
			return true;
		}
	}
	return false;
};

RegularPolygon.prototype.toString = function () {
	var s = "RegularPolygon(" + Eden.edenCodeForValues(this.x, this.y, this.r, this.n, this.star,
		this.interiorOutline, this.rotation, this.fillcolour, this.outlinecolour);

	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	s = s + ")";
	return s;
}

RegularPolygon.prototype.getEdenCode = RegularPolygon.prototype.toString;
	
RegularPolygon.prototype.imageMapArea = function () {
	return this.filledPolygons[0].imageMapArea();
}

RegularPolygon.prototype.centre = function () {
	return new Point(this.x, this.y);
}

}}$;

## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{

	Rotation = function (angle, centre, origin, angle2, radius, items) {
		this.angle = angle;
		this.centre = centre;
		this.origin = origin;
		this.angle2 = angle2;
		this.radius = radius;
		this.items = items;

		var radiansPerUnit = Math.PI / root.lookup("semicircleAngle").value();
		if (angle2 === undefined) {
			this.radians2 = 0;
		} else {
			this.radians2 = -angle2 * radiansPerUnit;
		}
		if (angle === undefined) {
			this.radians = 0;
		} else {
			this.radians = -angle * radiansPerUnit - this.radians2;
		}
	}

	Rotation.prototype = new EdenUI.plugins.Canvas2D.Transform();
	
	Rotation.prototype.transform = function (context) {
		var origin = this.origin;
		var centre = this.centre;
		var radius = this.radius;

		context.translate(origin.x, origin.y);

		if (radius !== undefined) {
			context.rotate(this.radians2);
			context.translate(radius, 0);
		}
		context.rotate(this.radians);

		if (centre !== undefined) {
			context.translate(-centre.x, -centre.y);
		}
	}

	Rotation.prototype.getCSS = function (scale) {
		var origin = this.origin;
		var centre = this.centre;
		var radius = this.radius;

		var css, x, y, theta;

		x = origin.x * scale;
		y = origin.y * scale;
		css = "translate(" + x + "px, " + y + "px) ";

		if (radius !== undefined) {
			theta = this.radians2;
			x = radius * scale;
			css = css +  "rotate(" + theta + "rad) translateX(" + x + "px) ";
		}

		theta = this.radians;
		css = css + "rotate(" + theta + "rad) ";

		if (centre !== undefined) {
			x = -centre.x * scale;
			y = -centre.y * scale;
			css = css + "translate(" + x + "px, " + y + "px)";
		}

		return css;
	}

	Rotation.prototype.inverse = function (x, y) {
		var origin = this.origin;
		var centre = this.centre;
		var radius = this.radius;

		var invX = x - origin.x;
		var invY = y - origin.y;
		var temp, sin, cos;

		if (radius !== undefined) {
			sin = Math.sin(-this.radians2);
			cos = Math.cos(-this.radians2);
			temp = invX;
			invX = cos * invX - sin * invY;
			invY = sin * temp + cos * invY;
			invX = invX - radius;
		}

		sin = Math.sin(-this.radians);
		cos = Math.cos(-this.radians);
		temp = invX;
		invX = cos * invX - sin * invY;
		invY = sin * temp + cos * invY;

		if (centre !== undefined) {
			invX = invX + centre.x;
			invY = invY + centre.y;
		}
		return new Point(invX, invY);
	}

	Rotation.prototype.toString = function() {
		if (this.radius !== undefined && this.centre !== undefined) {
			return "CombinedRotation(" + Eden.edenCodeForValues(this.angle, this.centre, this.origin, this.angle2, this.radius, this.items) + ")";
		} else if (this.radius !== undefined) {
			return "RotateAboutPoint(" + Eden.edenCodeForValues(this.angle2, this.origin, this.radius, this.items) + ")";
		} else {
			return "RotateAboutCentre(" + Eden.edenCodeForValues(this.angle, this.centre, this.origin, this.items) + ")";
		}
	}

	Rotation.prototype.getEdenCode = Rotation.prototype.toString;

}}$;

func Rotate {
	para item, angle;
	
	${{
		if (item instanceof CanvasImage) {
			return new Rotation(angle, new Point(item.dx + item.dWidth/2, item.dy + item.dHeight/2), new Point(item.dx,item.dy), 0, undefined, [item]);
		}
	}}$;
}

func CombinedRotation {
	${{
		if (arguments[0] instanceof Folder) {
			//Probably not an actual function call but semicircleAngle observable changed.
			return undefined;
		}

		var angle, centre, origin, angle2, radius, items;
		angle = arguments[0];
		centre = arguments[1];
		origin = arguments[2];

		if (arguments.length == 6) {
			angle2 = arguments[3];
			radius = arguments[4];
			items = arguments[5];
		} else {
			angle2 = angle;
			radius = arguments[3];
			items = arguments[4];		
		}

		if (!(centre instanceof Point)) {
			eden.error(new Error("CombinedRotation: The centre of rotation must be a Point, not a " + typeof(centre)), "error");
			return undefined;
		}
		if (!(origin instanceof Point)) {
			eden.error(new Error("CombinedRotation: The centre of the circular orbit must be a Point, not a " + typeof(origin)), "error");
			return undefined;
		}
		return new Rotation(angle, centre, origin, angle2, radius, items);
	}}$;
}

func RotateAboutCentre {
	${{
		if (arguments[0] instanceof Folder) {
			//Probably not an actual function call but semicircleAngle observable changed.
			return undefined;
		}

		var angle = arguments[0];
		var centre = arguments[1];
		var origin = arguments[2];
		var items = arguments[3];

		if (!(centre instanceof Point)) {
			eden.error(new Error("RotateAboutCentre: The centre of rotation must be a Point, not a " + typeof(centre)), "error");
			return undefined;
		}
		if (!(origin instanceof Point)) {
			eden.error(new Error("RotateAboutCentre: The destination position must be a Point, not a " + typeof(origin)), "error");
			return undefined;
		}
		return new Rotation(angle, centre, origin, 0, undefined, items);
	}}$;
}

func RotateAboutPoint {
	${{
		if (arguments[0] instanceof Folder) {
			//Probably not an actual function call but semicircleAngle observable changed.
			return undefined;
		}

		var angle, origin, radius, centre, items;
		angle = arguments[0];
		origin = arguments[1];
		radius = arguments[2];

		if (arguments.length == 5) {
			centre = arguments[3];
			items = arguments[4];
			if (!(centre instanceof Point)) {
				eden.error(new Error("RotateAboutPoint: The centre point of the source picture must be a Point, not a " + typeof(centre)), "error");
				return undefined;
			}
		} else {
			items = arguments[3];
		}

		if (!(origin instanceof Point)) {
			eden.error(new Error("RotateAboutPoint: The centre of the circle must be a Point, not a " + typeof(origin)), "error");
			return undefined;
		}
		return new Rotation(0, centre, origin, angle, radius, items);
	}}$;
}

semicircleAngle ~> [CombinedRotation, RotateAboutCentre, RotateAboutPoint];

## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
RoundedRectangle = function(x, y, width, height, radius, fillcolour, outlinecolour, drawingOptions) {
	this.x1 = x;
	this.y1 = y;
	this.x2 = x + width;
	this.y2 = y + height;
	this.radius = radius;
	this.fillcolour = fillcolour;
	this.outlinecolour = outlinecolour;
	this.drawingOptions = drawingOptions;
	this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "RoundedRectangle");
	this.obsName = root.currentObservableName();
}
}}$;

#! Draws a rounded rectangle. See [drawing options](@external CanvasExamples > drawingoptions) for more style properties.
#
# ##Usage Example
#  `RoundedRectangle(x,y,width,height, 10);`
#
# @param x
# @param y
# @param width
# @param height
# @param radius
# @param [fillColour
# @param [outlineColour]]
# @param [drawingOptions]
# 
#  #canvas #roundedRectangle #rounded #rectangle #drawingOptions #shape #box #draw
func RoundedRectangle {
${{
	var x = arguments[0];
	var y = arguments[1];
	var width = arguments[2];
	var height = arguments[3];
	var radius = arguments[4];
	var fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 5) {
		fillcolour = arguments[5];
		if (processUpTo == 6) {
			outlinecolour = arguments[6];
		}
	}
	if (fillcolour === undefined && outlinecolour === undefined) {
		outlinecolour = "black";
	}
	return new RoundedRectangle(x, y, width, height, radius, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

RoundedRectangle.prototype.draw = function (context, scale) {

	this.tracePath(context, scale);

	if (this.fillcolour !== undefined) {
		edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
		context.fill();
	}
	if (this.outlinecolour !== undefined) {
		context.strokeStyle = this.outlinecolour;
		context.stroke();
	}
};

RoundedRectangle.prototype.tracePath = function (context, scale) {
	var halfLineWidth;
	if (this.outlinecolour !== undefined) {
		halfLineWidth = context.lineWidth / 2;
	} else {
		halfLineWidth = 0;
	}
	var x1 = this.x1 + halfLineWidth;
	var x2 = this.x2 - halfLineWidth;
	var y1 = this.y1 + halfLineWidth;
	var y2 = this.y2 - halfLineWidth;
	if (scale < 0) {
		var temp = y1 - (y2 - y1);
		y2 = y1;
		y1 = temp;
	}
	
	context.beginPath();
    context.moveTo(x1 + this.radius, y1);
    context.lineTo(x2 - this.radius, y1);
	context.arcTo(x2, y1, x2, y1 + this.radius, this.radius);
	context.lineTo(x2, y2 - this.radius);
	context.arcTo(x2, y2, x2 - this.radius, y2, this.radius);
	context.lineTo(x1 + this.radius, y2);
	context.arcTo(x1, y2, x1, y2 - this.radius, this.radius);
	context.lineTo(x1, y1 + this.radius);
	context.arcTo(x1, y1, x1 + this.radius, y1, this.radius);
	context.closePath();
};

RoundedRectangle.prototype.isHit = function (context, scale, x, y) {
	this.tracePath(context, scale);
	return context.isPointInPath(x,y);
}

RoundedRectangle.prototype.toString = function() {
	var s = "RoundedRectangle(" + Eden.edenCodeForValues(this.x1, this.y1) + ", ";
	
	if (this.x2 === undefined || this.x1 === undefined) {
		s = s + "@, ";
	} else {
		s = s + String(this.x2 - this.x1) + ", ";
	}
	if (this.y2 === undefined || this.y1 === undefined) {
		s = s + "@, ";
	} else {
		s = s + String(this.y2 - this.y1) + ", ";
	}
	s = s + Eden.edenCodeForValues(this.radius, this.fillcolour, this.outlinecolour);
	
	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
};

RoundedRectangle.prototype.getEdenCode = RoundedRectangle.prototype.toString;

}}$;

## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{

	Scaling = function (scaleX, scaleY, centreX, centreY, translateX, translateY, items) {
		this.scaleX = scaleX;
		this.scaleY = scaleY;
		this.centreX = centreX;
		this.centreY = centreY;
		this.translateX = translateX;
		this.translateY = translateY;
		this.items = items;
	}

	Scaling.prototype = new EdenUI.plugins.Canvas2D.Transform;

	Scaling.prototype.transform = function (context) {
		var translateX = this.translateX;
		if (translateX !== undefined) {
			context.translate(translateX, this.translateY);
		}

		context.scale(this.scaleX, this.scaleY);

		var centreX = this.centreX;
		if (centreX !== undefined) {
			context.translate(-centreX, -this.centreY);
		}
	}

	Scaling.prototype.getCSS = function (scale) {
		var x = this.translateX;
		var y = this.translateY;
		var css;
		if (x || y) {
			x = x * scale;
			y = y * scale;
			css = "translate(" + x + "px, " + y + "px) ";
		} else {
			css = "";
		}

		var scaleX = this.scaleX * scale;
		var scaleY = this.scaleY * scale;
		css = css + "scale(" + scaleX + ", " + scaleY + ") ";

		x = this.centreX;
		y = this.centreY;
		if (x || y) {
			x = -x / this.scaleX;
			y = -y / this.scaleY;
			css = css + "translate(" + x + "px, " + y + "px)";
		}
		return css;
	}

	Scaling.prototype.inverse = function (x, y) {
		var invX = x, invY = y;
		
		var translateX = this.translateX;
		if (translateX) {
			invX = invX - translateX;
			invY = invY - this.translateY;
		}

		invX = invX / this.scaleX;
		invY = invY / this.scaleY;

		var centreX = this.centreX;
		if (centreX) {
			invX = invX + centreX;
			invY = invY + this.centreY;
		}
		return new Point(invX, invY);
	}

	Scaling.prototype.toString = function () {
		return "Scale(" + Eden.edenCodeForValues(this.scaleX, this.scaleY, this.centreX,
			this.centreY, this.translateX, this.translateY, this.items) + ")";
	}

	Scaling.prototype.getEdenCode = Scaling.prototype.toString;

}}$;

func Scale {
	${{
		var scaleX, scaleY, centreX, centreY, translateX, translateY, items;

		var argNum = arguments.length - 1;
		var arg;

		items = arguments[argNum];
		argNum--;
		if (argNum > 0) {
			arg = arguments[argNum];
			if (arg instanceof Point) {
				translateX = arg.x;
				translateY = arg.y;
				argNum--;
			} else if (argNum >= 2) {
				translateY = arg;
				argNum--;
				translateX = arguments[argNum];
				argNum--;
			}
			if (argNum > 0) {
				arg = arguments[argNum];
				if (arg instanceof Point) {
					centreX = arg.x;
					centreY = arg.y;
					argNum--;
				} else if (argNum >= 2) {
					centreY = arg;
					argNum--;
					centreX = arguments[argNum];
					argNum--;
				}
			}
			if (argNum == 1) {
				scaleY = arguments[argNum];
			} else if (argNum > 0) {
				eden.error(new Error("Scale: invalid parameters."), "error");
				return undefined;
			}
		}

		scaleX = arguments[0];
		if (scaleY === undefined) {
			scaleY = scaleX;
		}

		return new Scaling(scaleX, scaleY, centreX, centreY, translateX, translateY, items);
	}}$;
}

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Sector = function(x, y, r, sAngle, eAngle, unitsInCircle, fillcolour, outlinecolour,drawingOptions) {
	this.x = x;
	this.y = y;
	this.r = r;
	this.sAngle = sAngle;
	this.eAngle = eAngle;
	this.unitsInCircle = unitsInCircle;
	var radiansPerUnit;
	if (unitsInCircle === undefined) {
		radiansPerUnit = Math.PI / root.lookup("semicircleAngle").value();
	} else {
		radiansPerUnit = (2 * Math.PI) / unitsInCircle;
	}
	this.sRadians = sAngle * radiansPerUnit;
	this.eRadians = eAngle * radiansPerUnit;

    this.fillcolour = fillcolour;
	this.outlinecolour = outlinecolour;
	this.drawingOptions = drawingOptions;
	this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Sector");
	this.obsName = root.currentObservableName();
}
}}$;

func Sector { ${{
	var x = arguments[0];
	var y = arguments[1];
	var r = arguments[2];
	var sAngle = arguments[3];
	var eAngle = arguments[4];
	var unitsInCircle, fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}

	var argsProcessed = 5;
	if (typeof(arguments[argsProcessed]) == "number") {
		unitsInCircle = arguments[argsProcessed];
		argsProcessed++;
	}
	if (argsProcessed <= processUpTo) {
		fillcolour = arguments[argsProcessed];
		argsProcessed++;
	}
	if (argsProcessed <= processUpTo) {
		outlinecolour = arguments[argsProcessed];
	}
	if (fillcolour === undefined && outlinecolour === undefined) {
		outlinecolour = "black";
	}
	return new Sector(x, y, r, sAngle, eAngle, unitsInCircle, fillcolour, outlinecolour, drawingOptions);
}}$; };
semicircleAngle ~> [Sector];

${{

Sector.prototype.draw = function (context, scale) {

	this.tracePath(context, scale);

	if (this.fillcolour !== undefined) {
		edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
		context.fill();
	}
	if (this.outlinecolour !== undefined) {
		context.strokeStyle = this.outlinecolour;
		context.stroke();
	}
};

Sector.prototype.tracePath = function (context, scale) {
	var anticlockwise;
	if (this.drawingOptions !== undefined && "direction" in this.drawingOptions) {
		switch (this.drawingOptions.direction) {
		case "anticlockwise":
		case "acw":
		case "ccw":
			anticlockwise = true;
			break;
		case "auto":
			anticlockwise = this.sAngle < this.eAngle;
			break;
		case "clockwise":
		case "cw":
			anticlockwise = false;
			break;
		default:
			//Invalid value specified.
			anticlockwise = true;
		}
	} else {
		//Default to "auto" 
		anticlockwise = this.sAngle < this.eAngle;
	}

	var sRadians = this.sRadians;
	var eRadians = this.eRadians;
	if (scale < 0) {
		sRadians = -sRadians;
		eRadians = -eRadians;
		anticlockwise = !anticlockwise;
	}
	var radius;
	if (this.outlinecolour === undefined) {
		radius = this.r;
	} else if (this.drawingOptions !== undefined && this.drawingOptions.lineWidth % 2 == 1) {
		context.translate(0.5 / scale, 0.5 / scale);
		radius = this.r - 0.5 * context.lineWidth - 0.5 / scale;
	} else {
		radius = this.r - 0.5 * context.lineWidth;
	}

	context.beginPath();
	context.arc(this.x, this.y, radius, -sRadians, -eRadians, anticlockwise);
	context.lineTo(this.x, this.y);
	context.closePath();
};

Sector.prototype.isHit = function (context, scale, x, y) {
	this.tracePath(context, scale);
	return context.isPointInPath(x,y);
}

Sector.prototype.toString = function() {
	var s = "Sector(" + Eden.edenCodeForValues(this.x, this.y, this.r, this.sAngle, this.eAngle,
		this.unitsInCircle, this.fillcolour, this.outlinecolour);

	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
}

Sector.prototype.getEdenCode = Sector.prototype.toString;

}}$;

## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

func Shadow {
	${{
		var colour, blur, xOffset, yOffset, scale;

		var processUpTo;
		var numArgs = arguments.length;
		var lastArg = arguments[numArgs - 1];
		if (lastArg === true || lastArg === false || numArgs == 5) {
			scale = lastArg;
			processUpTo = numArgs - 1;
		} else {
			processUpTo = numArgs;
		}

		var argsProcessed;
		if (typeof(arguments[0]) == "string" || (arguments[0] === undefined && processUpTo > 3)) {
			colour = arguments[0];
			argsProcessed = 1;
		} else {
			argsProcessed = 0;
		}
		if (colour == undefined) {
			colour = "#3b3b3b";
		}

		xOffset = arguments[argsProcessed];
		argsProcessed++;
		yOffset = arguments[argsProcessed];
		argsProcessed++;
		blur = arguments[argsProcessed];
		return new Shadow(colour, xOffset, yOffset, blur, scale);
	}}$;
}

${{
	function Shadow(colour, xOffset, yOffset, blur, scale) {
		this.colour = colour;
		this.blur = blur;
		this.xOffset = xOffset;
		this.yOffset = yOffset;
		this.scale = scale;
	}

	Shadow.prototype.toString = function() {
		return "Shadow(" + Eden.edenCodeForValues(this.colour, this.xOffset, this.yOffset, this.blur, this.scale) + ")";
	}

	Shadow.prototype.getEdenCode = Shadow.prototype.toString;

}}$;

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Slider = function(name, min, max, step, labelInterval, tickMarkInterval, labelDivisor, x, y, length, orientation, enabled) {
	this.name = name;
	this.obsName = root.currentObservableName();
	this.min = min;
	this.max = max;
	this.step = step;
	this.labelInterval = labelInterval;
	this.tickMarkInterval = tickMarkInterval;
	this.labelDivisor = labelDivisor;
	this.x = x;
	this.y = y;
	this.length = length;
	this.orientation = orientation;
	this.enabled = enabled;
}

Slider.prototype.hash = function () {
	return this.name+"$$"+
				this.min+"$$"+
				this.max+"$$"+
				this.step+"$$"+
				this.labelInterval+"$$"+
				this.tickMarkInterval+"$$"+
				this.labelDivisor+"$$"+
				this.x+"$$"+
				this.y+"$$"+
				this.length+"$$"+
				this.orientation+"$$"+
				this.enabled;
};
}}$;

/**
 * Create a slider input control
 * 
 * @param [name] Prefix for _value and _preview observables.  Default is the name of the observable being defined.
 * @param min Minimum value of the slider
 * @param max Maximum value of the slider
 * @param [step Step interval
 * @param [label_interval How frequently to display labels
 * @param [tick_mark_interval How frequently to display tick marks
 * @param [label_divisor]]]] Each label is divided by label_divisor before display 
 * @param x X-position
 * @param y Y-position
 * @param size Size in pixels
 * @param [orientation] Either "horizontal", "vertical", "up", or "down"
 * @param [enabled] Boolean True or False
 *
 * #canvas #input #slider
 * 
 */
func Slider { ${{
	var argsProcessed;

	var name;
	if (typeof(arguments[0]) == "string") {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("Slider: Every slider must have a name."), "error");
			return undefined;
		}
	}
	var min = arguments[argsProcessed];
	argsProcessed++;
	var max = arguments[argsProcessed];
	argsProcessed++;

	var step, labelInterval, labelDivisor, tickMarkInterval, x, y, length, orientation, enabled;
	var arg, argType;
	if (typeof(arguments[argsProcessed + 6]) == "number") {
		step = arguments[argsProcessed];
		labelInterval = arguments[argsProcessed + 1];
		tickMarkInterval = arguments[argsProcessed + 2];
		labelDivisor = arguments[argsProcessed + 3];
		argsProcessed = argsProcessed + 4;
	} else if (typeof(arguments[argsProcessed + 5]) == "number") {
		step = arguments[argsProcessed];
		labelInterval = arguments[argsProcessed + 1];
		tickMarkInterval = arguments[argsProcessed + 2];
		argsProcessed = argsProcessed + 3;
	} else if (typeof(arguments[argsProcessed + 4]) == "number") {
		step = arguments[argsProcessed];
		labelInterval = arguments[argsProcessed + 1];
		argsProcessed = argsProcessed + 2;
	} else if (typeof(arguments[argsProcessed + 3]) == "number") {
		step = arguments[argsProcessed];
		argsProcessed++;
	} else if (max - min > 1 && Math.floor(min) == min && Math.floor(max) == max) {
		step = 1;
	}
	x = arguments[argsProcessed];
	y = arguments[argsProcessed + 1];
	length = arguments[argsProcessed + 2];
	argsProcessed = argsProcessed + 3;
	arg = arguments[argsProcessed];
	argType = typeof(arg);
	if (arg === undefined || argType == "string") {
		orientation = arguments[argsProcessed];
		argsProcessed++;
		arg = arguments[argsProcessed];
	}
	enabled = arg;

	if (labelInterval !== undefined) {
		if (labelDivisor === undefined) {
			labelDivisor = 1;
		}
		if (tickMarkInterval === undefined) {
			tickMarkInterval = labelInterval;
		}
	}
	if (orientation === undefined) {
		orientation = "horizontal";
	}
	if (enabled === undefined) {
		enabled = true;
	}

	return new Slider(name, min, max, step, labelInterval, tickMarkInterval, labelDivisor, x, y, length, orientation, enabled);
}}$; }

${{

Slider.prototype.draw = function (context) {

	if (this.elements === undefined) {
		var name = this.name;
		var me = this;
		var agent = root.lookup("Slider");

		var cssClass;
		if (this.orientation == "down"){
			cssClass = "slider-down"
		} else if (this.orientation == "up" || this.orientation == "vertical") {
			cssClass = "slider-up"
		} else {
			cssClass = "slider-horizontal";
		}
		var disabled = this.enabled === false? "disabled=\"disabled\"" : "";
		var inputHTML = '<input ' +
			disabled +
			'type="range" ' +
			'min="' + this.min + '" ' +
			'max="' + this.max + '" ';
		if (this.step === undefined) {
			inputHTML = inputHTML + 'step="0.0000001"';		
		} else {
			inputHTML = inputHTML + 'step="' + this.step + '"';
		}
		inputHTML = inputHTML + '/>';
		var inputJQ = $(inputHTML);
		var inputElem = inputJQ.get(0);
		this.sliderElement = inputElem;

		var valueSym = root.lookup(name + "_value");
		var previewSym = root.lookup(name + "_preview");

		function setValue(obs, value, force) {
			if (typeof(value) != "number") {
				return;
			}
			var previewSym = root.lookup(name + "_preview");
			var previewValue = previewSym.value();
			if (previewValue !== value || force) {
				var roundedValue;
				if (value >= me.min && value <= me.max) {
					inputElem.value = value;
					roundedValue = parseFloat(inputElem.value);
					if (roundedValue != value) {
						//Value didn't match the step size.
						obs.assign(roundedValue, root.scope, agent);
					}
				} else {
					if (value < me.min) {
						inputElem.value = me.min;
					} else {
						inputElem.value = me.max;
					}
					if (me.step !== undefined) {
						roundedValue = Math.round(((value - me.min) / me.step).toPrecision(16)) * me.step + me.min;
						if (roundedValue != value) {
							obs.assign(roundedValue, root.scope, agent);
						}
					} else {
						roundedValue = value;
					}
				}
				if (previewValue != roundedValue) {
					previewSym.assign(roundedValue, root.scope, EdenSymbol.hciAgent);
				}
			}
		}

		valueSym.addJSObserver("updateUI", setValue);
		previewSym.addJSObserver("updateUI", function (obs, preview) {
			if (typeof(preview) != "number") {
				return;
			}
			var previewSym = root.lookup(name + "_preview");
			var valueSym = root.lookup(name + "_value");
			if (previewSym.last_modified_by !== EdenSymbol.hciAgent.name) {
				var roundedValue;
				if (preview >= me.min && preview <= me.max) {
					inputElem.value = preview;
					roundedValue = parseFloat(inputElem.value);
					if (roundedValue != preview) {
						//Value didn't match the step size.
						obs.assign(roundedValue, root.scope, agent);
					}
				} else {
					if (preview < me.min) {
						inputElem.value = me.min;
					} else {
						inputElem.value = me.max;
					}
					if (me.step !== undefined) {
						roundedValue = Math.round(((preview - me.min) / me.step).toPrecision(16)) * me.step + me.min;
						if (roundedValue != value) {
							obs.assign(roundedValue, root.scope, agent);
						}
					} else {
						roundedValue = preview;
					}
				}
				valueSym.assign(roundedValue, root.scope, agent);
			}
		});

		inputJQ
		.on("input", function(){
			root.lookup(name + "_preview").assign(parseFloat(this.value), root.scope, EdenSymbol.hciAgent, true);
		})
		.on("mousedown", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseDownZone").assign(undefined, root.scope, EdenSymbol.hciAgent, mouseFollow);
		})
		.on("mouseup", function () {
			root.lookup(name + "_value").assign(parseFloat(this.value), root.scope, EdenSymbol.hciAgent, true);
			edenUI.plugins.Canvas2D.endClick();
		})
		.on("keyup", function () {
			root.lookup(name + "_value").assign(parseFloat(this.value), root.scope, EdenSymbol.hciAgent, true);		
		})
		.on("mouseenter", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		});

		var outerDiv = $('<div class="' + cssClass + '" ></div>');
		if ((this.tickMarkInterval > 0 || this.labelInterval > 0) && this.max > this.min) {
			var innerDiv = $('<div style="position: relative; height: 100%"></div>');
			outerDiv.append(innerDiv);
			if (this.tickMarkInterval > 0) {
				for (var i = this.min; i <= this.max; i = i + this.tickMarkInterval) {
					var percentage = (i - this.min) / (this.max - this.min) * 100;
					//The offset is to get the centre of the slider thumb positioned exactly on the tick mark.
					var offset = Math.round((50 - percentage) / 100 * 10);
					var position = 'calc(' + percentage + '% + ' + offset + 'px)';
					var tickMark = $('<div"></div>');
					if (this.orientation == "horizontal") {
						tickMark.css("left", position);
					} else {
						tickMark.css("top", position);
					}
					if ((i - this.min) % this.labelInterval == 0) {
						tickMark.addClass("slider-major-tick-mark");
					} else {
						tickMark.addClass("slider-minor-tick-mark");
					}
					innerDiv.append(tickMark);
				}
			}
			inputJQ.css("width", "100%");
			innerDiv.append(inputJQ);
			if (this.labelInterval > 0) {
				if (this.orientation == "horizontal") {
					var labelWidth = 100 / ((this.max - this.min) / this.labelInterval);
					var halfLabelWidth = labelWidth / 2;
					for (var i = this.min; i <= this.max; i = i + this.labelInterval) {
						var percentage = (i - this.min) / (this.max - this.min) * 100 - halfLabelWidth;
						var offset = Math.round((50 - percentage) / 100 * 10);
						var labelText = i / this.labelDivisor;
						var label = $(
							'<div ' + 
								'class="slider-label" ' +
								'style="left: calc(' + percentage + '% + ' + offset + 'px); width: ' + labelWidth + '%"' +
							'>' +
								labelText +
							'</div>'
						);
						innerDiv.append(label);
					}
				} else {
					for (var i = this.max; i >= this.min; i = i - this.labelInterval) {
						var percentage = (this.max - i) / (this.max - this.min) * 100;
						var offset = Math.round((50 - percentage) / 100 * 10 + 1);
						var labelText;
						if (this.orientation == "down") {
							labelText = (this.max - i) / this.labelDivisor;
						} else {
							labelText = i / this.labelDivisor;
						}
						var label = $(
							'<div ' +
								'class="slider-label" ' +
								'style="top: calc(' + percentage + '% + ' + offset + 'px - 0.5em)"' +
							'>' +
								labelText +
							'</div>'
						);
						innerDiv.append(label);
					}
				}
			}
		} else {
			outerDiv.append(inputJQ);
		}
		this.elements = [outerDiv.get(0)];

		//Initialization
		var value = valueSym.value();
		var previewValue = previewSym.value();
		if (value === undefined) {
			if (previewValue === undefined) {
				var defaultValue = (this.max - this.min) / 2 + this.min;
				valueSym.assign(defaultValue, root.scope, agent);
				setValue(valueSym, defaultValue, true);
			} else {
				valueSym.assign(previewValue, root.scope, agent);
				setValue(valueSym, previewValue, true);
			}
		} else {
			setValue(valueSym, value, true);
		}
	}
};

Slider.prototype.scale = function (scale, zoom, origin) {
	if (!this.sliderElement) {
		return;
	}
	var slider = this.sliderElement;
	var sliderStyle = slider.style;
	var divStyle = this.elements[0].style;
	var width = Math.round(this.length * scale);
	var isVertical = this.orientation == "up" || this.orientation == "down" || this.orientation == "vertical";
	if (isVertical) {
		sliderStyle.left = Math.round(-this.length / 2 * scale) + "px";
		sliderStyle.top = Math.round((this.length / 2 - 10) * scale) + "px";
		sliderStyle.width = width + "px";
		divStyle.height = width + "px";
	} else {
		divStyle.width = width + "px";	
	}

	divStyle.fontSize = zoom + "em";
	divStyle.left = Math.round((this.x + origin.x) * scale) + "px";
	divStyle.top =  Math.round((this.y + origin.y) * scale) + "px";

	if (this.step == undefined) {
		slider.step = String((slider.max - slider.min) / (width  - 1)).slice(0, 16);
	}
};

Slider.prototype.toString = function() {
	if (this.name == this.obsName) {
		return "Slider(" + Eden.edenCodeForValues(this.min, this.max, this.step, this.labelInterval,
			this.tickMarkInterval, this.labelDivisor, this.x, this.y, this.length, this.orientation,
			this.enabled) + ")";
	} else {
		return "Slider(" + Eden.edenCodeForValues(this.name, this.min, this.max, this.step,
			this.labelInterval, this.tickMarkInterval, this.labelDivisor, this.x, this.y,
			this.length, this.orientation, this.enabled) + ")";
	}
};

Slider.prototype.getEdenCode = Slider.prototype.toString;

}}$;

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Text = function(text, x, y, size, fillcolour, outlinecolour, options, valign, align) {
	this.text = text;
	this.x = x;
	this.y = y;
	this.size = size;
	this.fillcolour = fillcolour;
	this.outlinecolour = outlinecolour;
	this.elements = [];

	var optionsType = typeof(options);
	var css;

	if (optionsType == "object") {

		this.drawingOptions = options;

		if (options.italic) {
			css = "italic ";
		} else {
			css = "";
		}
		if (options.smallCaps) {
			css = css + "small-caps ";
		}
		if (options.bold) {
			css = css + "bold ";
		}
		if (size !== undefined) {
			css = css + size + "px ";
		} else {
			css = css + edenUI.plugins.Canvas2D.defaultFontSizePx + "px ";
		}
		if (options.fontFace === undefined) {
			css = css + "sans-serif";
		} else {
			css = css + options.fontFace + ", sans-serif";
		}

	} else if (optionsType == "string") {

		this.drawingOptions = {align: align, valign: valign};
		css = options;

	} else {

		this.drawingOptions = {align: "top"};
		if (size !== undefined) {
			css = size + "px sans-serif";
		} else {
			css = edenUI.plugins.Canvas2D.defaultFontSizePx + "px sans-serif";
		}

	}

	if (this.drawingOptions.align == "centre") {
		this.drawingOptions.align = "center";
	}
	if (this.drawingOptions.valign == "baseline") {
		this.drawingOptions.valign = "alphabetic";
	}

	this.css = css;
	this.optionsType = optionsType;
	this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(options, "Text");
	this.obsName = root.currentObservableName();
}

Text.elements = {};

// RegExp groups: (valign) (align) (style) (size) (font)
Text.cssRegExp = new RegExp(
		"^\\s*(" +
		"?:(top|middle|baseline|alphabetic|ideographic|bottom)?\\s*" + 
		"(\\b(?:left|right|center|centre))?\\s*" +
		"((?:\\bitalic)?\\s*" +
		"(?:\\bsmall-caps)?\\s*" +
		"(?:\\bbold)?)\\s*" +
		"(\\b(?:smaller|larger|(?:\\d+(?:\\.\\d+)?[a-zA-Z%]+)))?\\s*" +
		"(\\b(?:.+,)?\\s*(?:(?:sans-)?serif|monospace|cursive|fantasy))?" +
		")\\s*$"
);

}}$;

#! Create a drawable text object for a canvas. See [drawing options](@external CanvasExamples > drawingoptions) for more font and style options.
# 
# ##Usage Example
#  `Text("Message", x, y);`
#  `Text("Hello", x, y, 20, "red");`
#
# @param text Text string to display
# @param x X-coordinate
# @param y Y-coordinate
# @param [size] Size in pixels, or can be specified as a string with a unit (e.g., "30pt", "2em", etc.)
# @param [fill_colour Text colour in HTML form
# @param [outline_colour]]
# @param [options] Options, in string or object format
# 
#  #canvas #text #label #draw
func Text {
	${{
		var text = arguments[0];
		var x = arguments[1];
		var y = arguments[2];
		var size, fillcolour, outlinecolour, options, valign, align;

		var numArgs = arguments.length;
		var argsLeft = numArgs - 3;
		var argsProcessed = 3;

		if (arguments[3] === undefined || typeof(arguments[3]) == "number") {
			size = arguments[3];
			argsProcessed++;
			argsLeft--;
		}

		var lastArg = arguments[numArgs - 1];
		var argType = typeof(lastArg);
		var match;

		if (argType == "string") {
			match = lastArg.match(Text.cssRegExp);
		}

		if (match) {
			argsLeft--;
			valign = match[1];
			align = match[2];
			if (match[3]) {
				// italic, bold, etc.
				options = match[3];
			} else {
				options = "";
			}
			if (match[4]) {
				// size
				options = options + " " + match[4];
			} else if (size !== undefined) {
				options = options + " " + size + "px";
			} else {
				options = options + " " + edenUI.plugins.Canvas2D.defaultFontSizePx + "px";
			}
			if (match[5]) {
				// font family
				options = options + " " + match[5];
			} else {
				options = options + " sans-serif";
			}

		} else if (argType == "object" && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
			argsLeft--;
			options = lastArg;
		}

		if (argsLeft > 0) {
			fillcolour = arguments[argsProcessed];
			argsLeft--;
			argsProcessed++;
			if (argsLeft > 0) {
				outlinecolour = arguments[argsProcessed];
			}
		}

		if (outlinecolour === undefined && fillcolour === undefined) {
			fillcolour = "black";
		}
		return new Text(text, x, y, size, fillcolour, outlinecolour, options, valign, align);
	}}$;
}

${{

Text.prototype.draw = function (context, scale, viewname, mvMatrix, shader, pMatrix, canvas, id) {
	var ele = null;

	if (!Text.elements[viewname]) Text.elements[viewname] = {};

	if (!Text.elements[viewname][id]) {
		ele = document.createElement("div");
		Text.elements[viewname][id] = ele;
		ele.style.position = "absolute";
		ele.style.background = "transparent";
		ele.style.padding = "0";
	} else {
		ele = Text.elements[viewname][id];
	}

	this.elements = [ele];

	ele.textContent = this.text;
	ele.style.top = this.y + "px";
	ele.style.left = this.x + "px";
	ele.style.fontSize = this.size+"px";
};

Text.prototype.scale = function (scale, zoom , origin) {
	var style = this.elements[0].style;
	style.left = Math.round((this.x + origin.x) * scale) + "px";
	style.top = Math.round((this.y + origin.y) * scale) + "px";

	if (this.width !== undefined) {
		style.width = Math.round(this.width) + "px";
	}
	if (this.height !== undefined) {
		style.height = Math.round(this.height) + "px";
	}
	/*if (this.fontSizeSpecified) {
		style.fontSize = String(this.fontSizeNumber * zoom) + this.fontSizeUnits;
	} else {
		if (zoom == 1) {
			style.fontSize = ""; //Could be specified by a CSS class.
		} else {
			style.fontSize = zoom + "em";
		}
	}*/
	//if (scale != this.cachedScale) {
		style.transform = "scale("+zoom+")";
	//}
	this.cachedScale = scale;
	//this.resize();
};

Text.prototype.isHit = function (context, scale, px, py) {
	var x = this.x + 1 / scale;
	var y = this.y + 1 / scale;
	var width, height;
	
	if (this.width === undefined) {
		var div = document.createElement("div");
		div.innerHTML = this.text;
		div.style.position = 'absolute';
		div.style.top  = '-9999px';
		div.style.font = this.css;
		document.body.appendChild(div);
		this.width = div.offsetWidth;
		this.height = div.offsetHeight;
		document.body.removeChild(div);
	}

	var lineWidth;
	if (this.outlinecolour !== undefined) {
		lineWidth = context.lineWidth;
	} else {
		lineWidth = 0;
	}
	width = this.width / scale + lineWidth;
	height = this.height / scale + lineWidth / 2;

	return px >= x && px < x + width && py >= y && py < y + height;
}

Text.prototype.toString = function() {
	var s = "Text(" + Eden.edenCodeForValues(this.text, this.x, this.y, this.size, this.fillcolour,
		this.outlinecolour);
	var optionsType = this.optionsType;

	if (optionsType == "string") {
		s = s + ", \"";
		if (this.drawingOptions.valign) {
			s = s + this.drawingOptions.valign + " ";
		}
		if (this.drawingOptions.align) {
			s = s + this.drawingOptions.align + " ";
		}
		s = s + this.css + "\")";
	} else if (optionsType == "object") {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions) + ")";
	}
	return s;
};

Text.prototype.getEdenCode = Text.prototype.toString;

Text.parseArgs = function () {
	var text = arguments[0];
	var size;
	var css, optionsObj, scale;

	var argsProcessed = 1;
	var arg = arguments[1];
	var argType = typeof(arg);

	if (arg === undefined || argType == "number") {
		size = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}

	if (argType == "string") {

		var match = arg.match(Text.cssRegExp);
		if (match) {
			if (match[3]) {
				// italic, bold, etc.
				css = match[3];
			} else {
				css = "";
			}
			if (match[4]) {
				// size
				css = css + " " + match[4];
			} else if (size !== undefined) {
				css = css + " " + size + "px";
			} else {
				css = css + " 1em";
			}
			if (match[5]) {
				// font family
				css = css + " " + match[5];
			} else {
				css = css + " sans-serif";
			}
		} else {
			css = arg;
		}

		argsProcessed++;
		arg = arguments[argsProcessed];

	} else if (argType == "object") {

		optionsObj = arg;
		if (arg.italic) {
			css = "italic ";
		} else {
			css = "";
		}
		if (arg.smallCaps) {
			css = css + "small-caps ";
		}
		if (arg.bold) {
			css = css + "bold ";
		}
		if (size) {
			css = css + size + "px ";
		} else {
			css = css + "1em ";
		}
		if (arg.fontFace === undefined) {
			css = css + "sans-serif";
		} else {
			css = css + arg.fontFace + ", sans-serif";
		}

		argsProcessed++;
		arg = arguments[argsProcessed];

	} else if (arg === undefined) {

		if (size !== undefined) {
			css = size + "px sans-serif";
		} else {
			css = edenUI.plugins.Canvas2D.defaultFontSizePx + "px sans-serif";
		}

		argsProcessed++;
		arg = arguments[argsProcessed];

	}

	scale = arg;
	if (scale === undefined) {
		scale = 1;
	}

	return [css, optionsObj, scale];
};

}}$;

func textWidth {
	${{
		var text = arguments[0];
		var options = Text.parseArgs.apply(undefined, arguments);
		var css = options[0];
		var optionsObj = options[1];
		var scale = options[2];

		//Find an existing canvas (any one).
		var canvas;
		for (var canvasName in canvases) {
			canvas =  canvases[canvasName];
			break;
		}
		if (canvas === undefined) {
			canvas = document.createElement("canvas");
		}

		var context = canvas.getContext("2d");
		context.save();
		edenUI.plugins.Canvas2D.configureContextDefaults(context, 1);
		edenUI.plugins.Canvas2D.configureContext(context, 1, 1, optionsObj);
		context.font = css;
		context.textBaseline = "top";
		var metrics = context.measureText(text);
		var lineWidth;
		if (this.outlinecolour !== undefined) {
			lineWidth = context.lineWidth;
		} else {
			lineWidth = 0;
		}
		var width = Math.ceil(metrics.width + lineWidth) / scale;
		context.restore();
		return width;
	}}$;
}

func textHeight {
	${{
		var text = arguments[0];
		var options = Text.parseArgs.apply(undefined, arguments);
		var fontCSS = options[0];
		var optionsObj = options[1];
		var scale = options[2];

		var lineWidth;
		if (optionsObj !== undefined) {
			lineWidth = optionsObj.lineWidth;
		}
		if (lineWidth === undefined) {
			lineWidth = 2;
		}

		var div = document.createElement("div");
		div.innerHTML = text;
		var style = div.style;
		style.position = 'absolute';
		style.top  = '-9999px';
		style.padding = "0pt";
		style.whiteSpace = "nowrap";
		style.lineHeight = "1";
		style.font = fontCSS;

		//Find an existing canvas (any one).
		var canvas, parent;
		for (var canvasName in canvases) {
			canvas =  canvases[canvasName];
			break;
		}
		if (canvas) {
			parent = canvas.parentNode;
		}
		if (!parent) {
			parent = document.body;
		}

		parent.appendChild(div);
		var height = div.scrollHeight;
		parent.removeChild(div);
		/* N.B. even when the vertical alignment is "top" Chrome still leaves a small top margin
		 * where as Firefox doesn't.
		 */
		return (height + lineWidth / 2) / scale;
	}}$;
}

## Copyright (c) 2016, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

func TableLayout {
${{
	var x = arguments[0];
	var y = arguments[1];
	var width, content, drawingOptions;

	var argsProcessed = 2;
	var arg = arguments[2];

	if (Array.isArray(arg)) {
		content = arg;
		argsProcessed++;
	} else {
		width = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		content = arg;
		argsProcessed++;
	}

	arg = arguments[argsProcessed];

	if (typeof(arg) == "object") {
		drawingOptions = arg;
	}

	return new TableLayout(x, y, width, content, drawingOptions);
}}$;
}

${{
	TableLayout = function (x, y, width, content, drawingOptions) {
		this.obsName = root.currentObservableName();
		this.x = x;
		this.y = y;
		this.width = width;
		this.content = content;
		this.drawingOptions = drawingOptions;

		var rows = [ [] ];
		var numRows = 1;
		if (Array.isArray(this.content)) {
			var maxCol = 0;
			for (var i = 0; i < this.content.length; i++) {
				var item = this.content[i];
				var columnNo = item.x;
				var rowNo = item.y;
				if (columnNo !== undefined && rowNo !== undefined) {
					columnNo--;
					rowNo--;
					if (rowNo > numRows - 1) {
						for (var j = numRows; j <= rowNo; j++) {
							rows[j] = [];
						}
						numRows = rowNo + 1;
					}
					var row = rows[rowNo];
					var numColumns = row.length;
					if (columnNo > numColumns - 1) {
						for (var j = numColumns; j <= columnNo; j++) {
							row[j] = [];
						}
						if (columnNo > maxCol) {
							maxCol = columnNo;
						}
					}
					var cell = row[columnNo];
					cell.push(item);
				}
			}
		}
		this.rows = rows;
		this.maxCol = maxCol;
	}

	TableLayout.prototype.hash = function () {
		var hash = this.x + "$$" +
			this.y + "$$" +
			this.width + "$$";

		if (Array.isArray(this.content)) {
			for (var i = 0; i < this.content.length; i++) {
				var item = this.content[i];
				if (item.elements === undefined) {
					return hash + Math.random();
				} else {
					hash = hash + item.hash() + "$$";
				}
			}
		}
		
		if (this.drawingOptions !== undefined) {

		}

		return hash;
	};

	TableLayout.prototype.toString = function () {
		return "TableLayout(" + Eden.edenCodeForValues(this.x, this.y, this.width, this.content,
			this.drawingOptions) + ")";
	};

	TableLayout.prototype.draw = function (context, scale, viewName) {
		if (this.elements === undefined && Array.isArray(this.content)) {
			var me = this;

			var tableJQ = $(
				'<table class="canvashtml-item canvashtml-table-layout-item" ' +
					'style="left: ' + this.x + 'px; top: ' + this.y + 'px"' +
				'></table>'				
			);

			for (var j = 0; j < this.rows.length; j++) {
				var rowItems = this.rows[j];
				var rowJQ = $('<tr class="canvashtml-table-layout-row"></tr>');
				tableJQ.append(rowJQ);
				var rowLength = rowItems.length;
				for (var i = 0; i < rowLength; i++) {
					var cellJQ = $('<td class="canvashtml-table-layout-cell"></td>');
					rowJQ.append(cellJQ);
					var cellItems = rowItems[i];
					var numItems = cellItems.length;
					for (var k = 0; k < numItems; k++) {
						var item = cellItems[k];
						item.draw(context, scale, viewName);
						cellJQ.append(item.elements);
						if (k != numItems - 1) {
							cellJQ.append('<br/>');
						}
					}
				}
				for (i = rowLength; i <= this.maxCol; i++) {
					rowJQ.append('<td class="canvashtml-table-layout-cell">&nbsp;</td>');
				}
			}

			this.elements = tableJQ;
		}
	}

	TableLayout.prototype.resize = function () {
		var scale = this.cachedScale;
		if (scale === undefined) {
			//Not yet added drawn onto a canvas.
			return;
		}

		var element = this.elements[0];
		var style = element.style;
		var autoWidth = this.width === undefined;

		var agent = root.lookup("TableLayout");
		var widthSymName = this.obsName + "_width";
		var heightSymName = this.obsName + "_height";

		if (autoWidth || widthSymName in root.symbols) {
			root.lookup(widthSymName).assign(element.offsetWidth / scale, agent);
		}
		root.lookup(heightSymName).assign(element.offsetHeight / scale, agent);	
	}

	TableLayout.prototype.scale = function (scale, zoom, origin) {
		if (!Array.isArray(this.content)) {
			return;
		}

		var container = this.elements;
		var containerStyle = container[0].style;
		if (this.width !== undefined) {
			containerStyle.width = Math.round(this.width * scale) + "px";
		}
		containerStyle.left = Math.round((this.x + origin.x) * scale) + "px";
		containerStyle.top =  Math.round((this.y + origin.y) * scale) + "px";

		var children = container.children();
		for (var i = 0; i < this.content.length; i++) {
			var item = this.content[i];
			item.scale(scale, zoom, origin);
		}

		this.cachedScale = scale;
		this.resize();
	}

	TableLayout.prototype.getEdenCode = TableLayout.prototype.toString;
}}$;
## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Textbox = function (name, x, y, width, height, placeholder, maxlength, enabled) {
	this.name = name;
	this.obsName = root.currentObservableName();
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.placeholder = placeholder;
	this.maxlength = maxlength;
    this.enabled = enabled;
}

Textbox.prototype.hash = function () {
	return this.name+"$$"+
				this.x+"$$"+
				this.y+"$$"+
				this.width+"$$"+
				this.height+"$$"+
				this.placeholder+"$$"+
				this.maxlength+"$$"+
				this.enabled;
};
}}$;

/**
 * Creates a text input box for drawing on the canvas
 * 
 * @param [name] Prefix for _value observable.  Default is the name of the observable being defined.
 * @param x X-position
 * @param y Y-position
 * @param [width
 * @param [height]]
 * @param [placeholder_text] Text to be displayed by default
 * @param [max_characters] Maximum number of characters allowed in input box
 * @param [enabled] Boolean (true or false) to enable or disable input
 * 
 * #canvas #input #text #textbox
 */

	
func Textbox { ${{
	var argsProcesssed;

	var name;
	if (typeof(arguments[0]) == "string") {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("Textbox: Every text box must have a name."), "error");
			return undefined;
		}
	}

	var x = arguments[argsProcessed];
	argsProcessed++;
	var y = arguments[argsProcessed];
	argsProcessed++;

	var width, height, placeholder, maxlength, enabled;
	var arg = arguments[argsProcessed];
	var argType = typeof(arg);

	if (arg === undefined || argType == "number") {
		width = arguments[argsProcessed];
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}

	if (arg === undefined || argType == "number") {
		height = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}
	if (arg === undefined || argType == "string") {
		placeholder = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}
	if (arg === undefined || argType == "number") {
		maxlength = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
	}
	enabled = arg;
	return new Textbox(name, x, y, width, height, placeholder, maxlength, enabled);
}}$; }

${{
Textbox.prototype.draw = function(context) {	

	if(this.elements === undefined) {
		var me = this;
		var name = this.name;

		var disabled = this.enabled === false? 'disabled="disabled"' : '';
		var placeholder;
		var maxlength = this.maxlength !== undefined? ' maxlength="' + this.maxlength + '"' : '';
		var jQuery;
		if (this.height === undefined) {
			placeholder = ' placeholder="' +
				(this.placeholder === undefined? name : this.placeholder) + '"';
			jQuery = $('<input type="text" ' + disabled + placeholder + maxlength + ' class="canvashtml-item" />');
		} else {
			// Placeholder text for textarea tag is buggy in IE11, so don't use it by default.
			placeholder = this.placeholder !== undefined && this.placeholder != ""?
				' placeholder="' + this.placeholder + '"' :
				'';
			jQuery = $('<textarea ' + disabled + placeholder + maxlength + ' class="canvashtml-item"></textarea>');
		}

		var element = jQuery.get(0);
		var valueSymbol = root.lookup(name + "_value");
		var value = valueSymbol.value();
		if (value === undefined) {
			valueSymbol.assign("", root.scope, root.lookup("Textbox"));
		} else {
			element.value = value;
		}
		valueSymbol.addJSObserver("updateTextbox", function (obs, value) {
			me.elements[0].value = value;
		});

		jQuery
		.on("input", function(event) {
			root.lookup(name + "_value").assign(event.target.value, root.scope, EdenSymbol.hciAgent, true);
		})
		.on("mousedown", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseDownZone").assign(undefined, root.scope, EdenSymbol.hciAgent, mouseFollow);
		})
		.on("mouseup", function () {
			edenUI.plugins.Canvas2D.endClick();
		})
		.on("mouseenter", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		});

		this.elements = [element];
  }
};

Textbox.prototype.scale = function (scale, zoom, origin) {
	var style = this.elements[0].style;
	style.left = Math.round((this.x + origin.x) * scale) + "px";
	style.top =  Math.round((this.y + origin.y) * scale) + "px";
	style.width = Math.round(this.width * scale - 6) + "px";
	if (this.height !== undefined) {
		var lineHeight = edenUI.plugins.Canvas2D.defaultLineHeight;
		var rows = Math.floor(Math.round(this.height * scale - 4) / (lineHeight * zoom));	//See css/eden.css
		if (rows == 0) {
			rows = 1;
		}
		style.height = (rows * lineHeight * zoom) + "px";
	}
	style.fontSize = (edenUI.plugins.Canvas2D.defaultFontSizePx * zoom) + "px";
};

Textbox.prototype.toString = function() {
	if (this.name == this.obsName) {
		return "Textbox(" + Eden.edenCodeForValues(this.x, this.y, this.width,
			this.height, this.placeholder, this.enabled) + ")";
	} else {
		return "Textbox(" + Eden.edenCodeForValues(this.name, this.x, this.y, this.width,
			this.height, this.placeholder, this.enabled) + ")";	
	}
};

Textbox.prototype.getEdenCode = Textbox.prototype.toString;

}}$;

## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{

	Translation = function (centreX, centreY, x, y, items) {
		this.centreX = centreX;
		this.centreY = centreY;
		this.x = x;
		this.y = y;
		this.items = items;
	}

	Translation.prototype = new EdenUI.plugins.Canvas2D.Transform;

	Translation.prototype.transform = function (context) {
		context.translate(this.x - this.centreX, this.y - this.centreY);
	}
	
	Translation.prototype.getCSS = function (scale) {
		var x = (this.x - this.centreX) * scale;
		var y = (this.y - this.centreY) * scale;
		return "translate(" + x + "px, " + y + "px)";
	}

	Translation.prototype.inverse = function (x, y) {
		return new Point(x - (this.x - this.centreX), y - (this.y - this.centreY));
	}

	Translation.prototype.toString = function () {
		return "Translate(" + Eden.edenCodeForValues(this.centreX, this.centreY, this.x, this.y, this.items) + ")";
	}

	Translation.prototype.getEdenCode = Translation.prototype.toString;

}}$;

func Translate {
	${{
		var centreX, centreY, x, y, items;
		var argNum = arguments.length - 1;
		if (argNum == 0) {
			eden.error(new Error("Translate: This function requires at least 2 arguments."), "error");
			return undefined;
		}
		items = arguments[argNum];
		argNum--;
		arg = arguments[argNum];
		if (arg instanceof Point) {
			x = arg.x;
			y = arg.y;
			argNum--;
		} else if (argNum >= 1) {
			y = arg;
			argNum--;
			x = arguments[argNum];
			argNum--;
		}
		if (argNum >= 0) {
			arg = arguments[argNum];
			if (arg instanceof Point) {
				centreX = arg.x;
				centreY = arg.y;
				argNum--;
			} else if (argNum >= 1) {
				centreY = arg;
				argNum--;
				centreX = arguments[argNum];
				argNum--;
			}		
		}
		if (argNum >= 0) {
			eden.error(new Error("Translate: invalid parameters."), "error");
			return undefined;
		}

		if (typeof(x) !== "number") {
			eden.error(new Error("Translate: The destination X coordinate must be a number, not a " + typeof(x)), "error");
			return undefined;
		}
		if (typeof(y) !== "number") {
			eden.error(new Error("Translate: The destination Y coordinate must be a number, not a " + typeof(y)), "error");
			return undefined;
		}
		if (centreX === undefined) {
			centreX = 0;
		}
		if (centreY === undefined) {
			centreY = 0;
		}
		return new Translation(centreX, centreY, x, y, items);
	}}$;
}

# Copyright (c) 2015, Empirical Modelling Group
# All rights reserved.
#
# See LICENSE.txt

#Bugs:
#Assigning to _chapters causes a jump back to the beginning of the current chapter.
#Triggered procedures are possibly called twice when making assignments?
#If _paused is defined by dependency and is true while seeking then the video starts playing while the mouse button is still held down.
#Attempting to play back video in reverse (vid_speed < 0) only works on Safari on Mac.  A workaround is possible.
#Loading a new video file will reset the playback speed to 1.
#Assigning "end" to _chapter gives improper _time.
#Todo:
#Add ability to set audio player width using _width
#Add a _duration observable (assigning prevents playing past that point).  Change .duration to .maximumDuration
#Add support for poster images.
#Add click in video area to play/pause.
#Add feedback for downloading issues.
#Add mode that draws the video onto the canvas.
#Useful site for extracting YouTube video URLs: http://www.downvids.net/
#Alternative site: http://www.youtubeinmp4.com/
#MP3 files: http://www.mfiles.co.uk/mp3-files.htm

#For a Video drawable named "vid", the following observables are available.  All are read/write.
#
#vid_url
#	The URL of the current video loaded into the video player.
#
#vid_position
#	A Point object representing the position of the video player on the canvas.
#
#vid_size
#	A Point object representing the width and height of the video as it is displayed on the canvas.
#
#vid_scale
#	A number representing the canvas scale factor used to express vid_size.
#
#vid_controls
#	Whether or not the built-in playback controls are available to the user or not.
#
#vid_paused
#	True if the video is not currently playing and false if it is playing or if it should be played
#	as soon as it has finished loading.  Note that if vid_paused is determined by dependency and the
#	user overrides this decision by pausing or resuming playback using the playback controls then
#	the value of vid_paused will not reflect the true status of the video playback.  Also, if
#	vid_paused is determined by dependency and equals true when the end of the video is reached then
#	the video will play again from the beginning.
#
#vid_time
#	The current temporal position of the video, accurate to the nearest second.  Cannot be set by
#	dependency unless the video is kept paused.
#
#vid_chapters and vid_chapter
#	If defined then vid_chapters should be an object where the keys are labels attributed to certain
#	sections of the video and the values are the times when these sections begin.  For example, if
#	vid_chapters is {lesson1: 60, lesson2: 900} then vid_chapter will contain the string "start"
#	during the first 60 seconds of playback, contain the string "lesson1" between 60 seconds through
#	to 15 minutes into the video, at which point the second lesson begins and vid_chapter will
#	become "lesson2".  When the video has finished playing vid_chapter will become "end".
#
#vid_speed
#	Determines the speed of video playback, e.g. 1 for normal speed or 2 to play back at double
#	speed.  Setting the speed to zero pauses the video and assigns the value true to vid_paused
#	unless vid_paused is calculated by dependency.  If vid_speed is set to zero then subsequently
#	assigning another value to vid_speed won't automatically resume playback unless vid_paused is
#	calculated by dependency.  If vid_speed is zero when the video becomes unpaused, either by
#	the value of vid_paused changing from true to false or by the user clicking on the play button,
#	then the speed will be reset to 1.
#
#vid_volume
#	The current volume level of the video's soundtrack, between 0 and 1.  If vid_volume is specified
#	by dependency and playback controls are enabled and the user uses them to adjust the volume
#	then then the dependency will be overwritten by an implicit assignment.
#
#Useful properties of the drawable object itself:
#
#.duration
#	The duration of the currently loaded video file (read-only).
#
#Useful methods of the drawable object itself:
#
#.unmute()
#	Restores the volume to its previous level if currently playing silently.

#Example:
/*
	vid_url = "...";
	vid is Video();
	picture is [vid];

	#Stop to complete an exercise 60 seconds into the video.
	exercisePoints = [60];
	exercisesCompleted = [false];
	exerciseNumber is positionInList(vid_time, exercisePoints);
	vid_controls is exerciseNumber == 0 || exercisesCompleted[exerciseNumber];
	vid_paused is vid_controls == false;
*/

func Video {
	${{
		var argsProcessed;

		var name;
		if (typeof(arguments[0]) == "string") {
			name = arguments[0];
			argsProcessed = 1;
		} else {
			name = root.currentObservableName();
			argsProcessed = 0;
			if (name === undefined) {
				eden.error(new Error("Video: Every video must have a name."), "error");
				return undefined;
			}
		}
		var preload;
		if (argsProcessed < arguments.length) {
			preload = arguments[argsProcessed];
		} else {
			preload = false;
		}
		return new Audiovisual(name, "Video", preload);
	}}$;
}

func Audio {
	${{
		var argsProcessed;

		var name;
		if (typeof(arguments[0]) == "string") {
			name = arguments[0];
			argsProcessed = 1;
		} else {
			name = root.currentObservableName();
			argsProcessed = 0;
			if (name === undefined) {
				eden.error(new Error("Audio: Every audio player must have a name."), "error");
				return undefined;
			}
		}
		var preload;
		if (argsProcessed < arguments.length) {
			preload = arguments[argsProcessed];
		} else {
			preload = false;
		}
		return new Audiovisual(name, "Audio", preload);
	}}$;
}

${{
	window.Audiovisual = function(name, type, preload) {
		this.name = name;
		this.obsName = root.currentObservableName();
		this.type = type;
		this.preload = preload;
		this.atEnd = false;
		
		Object.defineProperty(this, "duration", {
			enumerable: true,
			get: function () {
				if (this.elements === undefined || !this.elements[0].duration) {
					return 0;
				} else {
					return this.elements[0].duration;
				}
			}
		});
	}
	
	Audiovisual.prototype.hash = function () {
		return this.name;
	}

	function getMediaElement(audiovisual) {
		return audiovisual.elements[0];
	}

	function loadMedia(audiovisual) {
		var mediaElement = getMediaElement(audiovisual);
		mediaElement.autoplay = !root.lookup(audiovisual.name + "_paused").value();
		if (audiovisual.preload) {
			mediaElement.preload = "auto";
		} else {
			mediaElement.preload = "metadata";
		}
		mediaElement.load();
	}

	Audiovisual.prototype.reload = function () {
		var mediaElement = getMediaElement(this);
		var position = mediaElement.currentTime;
		loadMedia(this);
		mediaElement.currentTime = position;
	};

	Audiovisual.prototype.unmute = function () {
		getMediaElement(this).muted = false;
	}

	Audiovisual.prototype.draw = function (context) {
		if (this.elements === undefined ) {
			var me = this;
			var name = this.name;
			var agent = EdenSymbol.localJSAgent;
			root.beginAutocalcOff();

	//Create HTML tag

			var mediaElement = document.createElement(this.type.toLowerCase());


	//Symbols not unique to videos

			var chapterSym = root.lookup(name + "_chapter");
			var chapterMarksSym = root.lookup(name + "_chapters");
			var loopSym = root.lookup(name + "_looping");
			var pausedSym = root.lookup(name + "_paused");
			var positionSym = root.lookup(name + "_position");
			var speedSym = root.lookup(name + "_speed");
			var timeSym = root.lookup(name + "_time");
			var urlSym = root.lookup(name + "_url");
			var volumeSym = root.lookup(name + "_volume");


	//Chapters

			var chapterMarks, chapterNames, chapterIndex, nextChapterAt;
			var goToChapter = function () {
				var numChapters = chapterMarks.length;
				if (chapterIndex == -1) {
					if (numChapters > 0 && chapterMarks[0] == 0) {
						chapterIndex = 0;
					}
				}
				var chapterName;
				if (chapterIndex == -1) {
					chapterName = "start";
				} else if (chapterIndex == numChapters) {
					chapterName = "end";
					me.atEnd = true;
				} else {
					chapterName = chapterNames[chapterIndex];
				}
				if (chapterName != chapterSym.value()) {
					chapterSym.assign(chapterName, root.scope, EdenSymbol.defaultAgent);
				}
				if (chapterIndex < numChapters - 1) {
					nextChapterAt = chapterMarks[chapterIndex + 1];
				} else {
					nextChapterAt = undefined;
				}
			};
			var setChapters = function (symbol, chapters) {
				chapterMarks = [];
				chapterNames = [];
				chapterIndex = -1;
				nextChapterAt = undefined;
				
				if (chapters instanceof Object) {
					for (var chapterName in chapters) {
						var beginsAt = chapters[chapterName];
						var i = 0;
						while (i < chapterMarks.length) {
							if (beginsAt < chapterMarks[i]) {
								break;
							}
							i++;
						}
						chapterMarks.splice(i, 0, beginsAt);
						chapterNames.splice(i, 0, chapterName);
					}
					
					if (!me.atEnd) {
						var currentPos = timeSym.value();
						while (chapterIndex < chapterMarks.length - 1 &&
						 currentPos >= chapterMarks[chapterIndex + 1]) {
							chapterIndex++;
						}
						goToChapter();
					}
				}
			}; //end of function
			if (chapterMarksSym.value() === undefined && chapterMarksSym.definition === undefined) {
				chapterMarksSym.assign({}, root.scope, EdenSymbol.defaultAgent);
			}
			setChapters(chapterMarksSym, chapterMarksSym.value());
			chapterMarksSym.addJSObserver("setChapters", setChapters);

			chapterSym.addJSObserver("jumpToChapter", function (symbol, value) {
				var currentTime = mediaElement.currentTime;
				var numChapters = chapterMarks.length;
				var newTime;
				if (value == "start") {
					chapterIndex = -1;
					newTime = 0;
				} else if (value == "end") {
					chapterIndex = numChapters;
					newTime = mediaElement.duration;
				} else {
					var found = false;
					for (var i = 0; i < numChapters; i++) {
						if (value == chapterNames[i]) {
							chapterIndex = i;
							newTime = chapterMarks[chapterIndex];
							break;
						}
					}
				}
				if (newTime !== undefined) {
					timeSym.assign(newTime, root.scope, agent);
					mediaElement.currentTime = newTime;
					goToChapter();
				}
			});

	//Looping

			var initialLooping = loopSym.value();
			if (initialLooping === undefined && loopSym.definition === undefined) {
				loopSym.assign(false, root.scope, EdenSymbol.defaultAgent);
			} else if (initialLooping) {
				mediaElement.loop = true;
			}
			loopSym.addJSObserver("setLooping", function (sym, value) {
				mediaElement.loop = value;
			});


	//Playback controls

			if (this.type == "Video") {

				var controlsSym = root.lookup(name + "_controls");
				var controls = controlsSym.value();
				if (controls === undefined) {
					if (controlsSym.definition === undefined) {
						controlsSym.assign(true, root.scope, agent);
					} else {
						mediaElement.controls = true;
					}
				} else {
					mediaElement.controls = controls;
				}
				controlsSym.addJSObserver("showHideControls", function (symbol, showControls) {
					mediaElement.controls = showControls;
				});
			} else {
				mediaElement.controls = true;
			}


	//Position on screen

			mediaElement.className = "canvashtml-item";
			this.cachedOrigin = new Point(0, 0);
			this.cachedScaleFactor = 1;
			var position = positionSym.value();
			if (position === undefined) {
				position = new Point(0, 0);
				positionSym.assign(position, root.scope, EdenSymbol.defaultAgent);
			}
			positionSym.addJSObserver("reposition", function (sym, position) {
				me.doTranslation(position);
			});


	//Size

			this.cachedZoom = 1;
			if (this.type == "Video") {
				var sizeSym = root.lookup(name + "_size");
				var scaleSym = root.lookup(name + "_scale");
				var size = sizeSym.value();
				sizeSym.addJSObserver("resize", function (symbol, size) {
					var scale = scaleSym.value();
					if (scale !== undefined) {
						me.doScaling(size, scale);
					}
				});
				scaleSym.addJSObserver("resize", function (symbol, scale) {
					if (scale !== undefined) {
						me.doScaling(sizeSym.value(), scale);
					}
				});
				mediaElement.addEventListener("loadedmetadata", function (event) {
					if (sizeSym.value() === undefined) {
						root.beginAutocalcOff();
						scaleSym.assign(1, root.scope, agent);
						sizeSym.assign(new Point(mediaElement.videoWidth, root.scope, mediaElement.videoHeight), agent);
						root.endAutocalcOff();
					}
				});

			} else {
			
			}


	//Paused or playing

			var beginPaused = pausedSym.value();
			if (beginPaused === undefined && pausedSym.definition === undefined) {
				pausedSym.assign(true, root.scope, agent);
			} else if (beginPaused == false) {
				mediaElement.autoplay = true;
			}
			pausedSym.addJSObserver("pausePlay", function (symbol, pause) {
				if (pause) {
					mediaElement.pause();
				} else {
					me.atEnd = false;
					mediaElement.play();
				}
			});
			mediaElement.addEventListener("pause", function (event) {
				if (pausedSym.definition === undefined && pausedSym.value() != true) {
					pausedSym.assign(true, root.scope, agent);
				}
			});
			mediaElement.addEventListener("playing", function (event) {
				if (pausedSym.definition === undefined  && pausedSym.value() != false) {
					pausedSym.assign(false, root.scope, agent);
				}
				if (speedSym.value() == 0) {
					mediaElement.defaultPlaybackRate = 1;
					mediaElement.playbackRate = 1;
				}
			});


	//Seeking and time moving forward

			var time = timeSym.value();
			if (time !== undefined) {
				mediaElement.currentTime = parseFloat(time);
			} else if (timeSym.definition === undefined) {
				timeSym.assign(0, root.scope, EdenSymbol.defaultAgent);
			}

			function findChapter() {
				var oldChapterIndex  = chapterIndex;
				var numChapters = chapterMarks.length;
				if (me.atEnd) {
					//Seeked to the end (and not looping)
					chapterIndex = numChapters;
				} else {
					var currentTime = mediaElement.currentTime;
					if (nextChapterAt !== undefined && currentTime >= nextChapterAt) {
						//Seeking forward
						while (chapterIndex < numChapters - 1 && currentTime >= chapterMarks[chapterIndex + 1]) {
							chapterIndex++;
						}
					} else {
						//Seeking backward
						if (chapterIndex == numChapters) {
							chapterIndex--;
						}
						while (chapterIndex >= 0 && chapterMarks[chapterIndex] > currentTime) {
							chapterIndex--;
						}
					}
				}

				if (chapterIndex != oldChapterIndex) {
					goToChapter();
				}
			}

			timeSym.addJSObserver("seek", function (symbol, seconds) {
				if (symbol.origin !== EdenSymbol.localJSAgent) {
					mediaElement.currentTime = seconds;
				}
			});
			mediaElement.addEventListener("timeupdate", function (event) {
				if (mediaElement.paused) {
					return;
				}
				var currentTime = mediaElement.currentTime;
				var newTimeIndex = Math.floor(currentTime);
				if (newTimeIndex != me.timeIndex) {
					timeSym.assign(newTimeIndex, root.scope, EdenSymbol.localJSAgent);
					me.timeIndex = newTimeIndex;					
				}
				if (nextChapterAt !== undefined && currentTime >= nextChapterAt) {
					chapterIndex++;
					chapterSym.assign(chapterNames[chapterIndex], root.scope, agent);
					if (chapterIndex < chapterMarks.length - 1) {
						nextChapterAt = chapterMarks[chapterIndex]
					} else {
						nextChapterAt = undefined;
					}
				}
			});
			mediaElement.addEventListener("ended", function (event) {
				timeSym.assign(mediaElement.duration, root.scope, EdenSymbol.localJSAgent);
				chapterIndex = chapterMarks.length;
				goToChapter();
			});
			mediaElement.addEventListener("seeking", function (event) {
				var currentTime = mediaElement.currentTime;
				if (timeSym.value() !== currentTime) {
					timeSym.assign(currentTime, root.scope, EdenSymbol.localJSAgent);
				}
				me.atEnd = currentTime == mediaElement.duration;
				findChapter();
			});
			mediaElement.addEventListener("seeked", function (event) {
				var isPaused = pausedSym.value();
				me.timeIndex = Math.floor(mediaElement.currentTime);
				if (!isPaused) {
					mediaElement.play();
				}
			});


	//Playback speed

			var speedResetOnLoad;
			var speed = speedSym.value();
			if (speed === undefined) {
				speedSym.assign(1, root.scope, EdenSymbol.defaultAgent);
			} else if (speed > 0) {
				mediaElement.defaultPlaybackRate = speed;
			}
			speedSym.addJSObserver("changePlaybackSpeed", function (symbol, speed) {
				if (mediaElement.playbackRate != speed) {
					if (speed > 0) {
						mediaElement.defaultPlaybackRate = speed;
					} else {
						mediaElement.defaultPlaybackRate = 1;					
					}
					mediaElement.playbackRate = speed;
				}
			});
			mediaElement.addEventListener("ratechange", function (event) {
				root.beginAutocalcOff();
				var speed = mediaElement.playbackRate;
				if (speedSym.definition === undefined) {
					speedSym.assign(speed, root.scope, agent);
				}
				if (speed == 0) {
					mediaElement.pause();
				} else if (!pausedSym.value()) {
					mediaElement.play();
				}
				root.endAutocalcOff();
			});


	//Volume

			var volume = volumeSym.value();
			if (volume === undefined) {
				volumeSym.assign(1, root.scope, EdenSymbol.defaultAgent);
			} else if (volume == 0) {
				mediaElement.muted = true;
			} else {
				mediaElement.volume = volume;			
			}
			this.volumeChanging = false;
			volumeSym.addJSObserver("adjustVolume", function (symbol, volume) {
				if (!me.volumeChanging) {
					me.volumeChanging = true;
					if (symbol.definition === undefined) {
						if (volume == 0) {
							mediaElement.muted = true;
						} else {
							mediaElement.muted = false;
							mediaElement.volume = volume;
						}
					} else {
						mediaElement.volume = volume;
					}
					me.volumeChanging = false;
				}

			});
			mediaElement.addEventListener("volumechange", function (event) {
				if (!me.volumeChanging) {
					me.volumeChanging = true;
					var oldVolume = volumeSym.value();
					var newVolume = mediaElement.volume;
					if (mediaElement.muted) {
						if (volumeSym.definition === undefined) {
							volumeSym.assign(0, root.scope, agent);
						}
					} else if (oldVolume != newVolume) {
						if (volumeSym.definition === undefined) {
							volumeSym.assign(newVolume, root.scope, agent);
						} else {
							mediaElement.volume = oldVolume;
						}
					}
					me.volumeChanging = false;
				}
			});

	//Loading a video file

			var url = urlSym.value();
			if (url !== undefined) {
				if (this.preload) {
					mediaElement.preload  = "auto";
				} else {
					mediaElement.preload = "metadata";
				}
				mediaElement.src = url;
			}
			urlSym.addJSObserver("newVideo", function (symbol, url) {
				if (url != mediaElement.src) {
					timeSym.assign(0, root.scope, agent);
					me.timeIndex = 0;
					chapterIndex = -1;
					goToChapter();
					mediaElement.src = url;
					loadMedia(me);
				}
			});


	//Mouse Zones

		if (this.type == "Video") {
			mediaElement.onmousedown = function (event) {
				var mouseFollow = root.lookup("mouseFollow").value();
				root.lookup("mouseDownZone").assign(me.name, root.scope, EdenSymbol.hciAgent, mouseFollow);
			};
			mediaElement.onmouseup = function (event) {
				edenUI.plugins.Canvas2D.endClick();
			};
			edenUI.plugins.Canvas2D.initZoneFromName(this.name, this.type)
		}
		mediaElement.onmouseenter = function (event) {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseZone").assign(me.name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		};


	//Finalize creation

			this.elements = [mediaElement];
			root.endAutocalcOff();
		}
	}

	Audiovisual.prototype.scale = function (scale, zoom , origin) {
		this.cachedScaleFactor = scale;
		this.cachedOrigin = origin;

		var name = this.name;
		var position = root.lookup(name + "_position").value();
		this.doTranslation(position);

		if (this.type == "Video") {
			this.cachedZoom = zoom;
			var scaleSym = root.lookup(name + "_scale");
			var videoScale = scaleSym.value();

			if (videoScale === undefined) {
				videoScale = scale / zoom;
				scaleSym.assign(videoScale, root.scope, root.lookup(this.type));
			} else {
				var size = root.lookup(name + "_size").value();
				this.doScaling(size, videoScale);
			}
		}
	}

	Audiovisual.prototype.doScaling = function (size, scale) {
		if (size instanceof Point) {
			var element = this.elements[0];
			var scaleFactor = this.cachedZoom * scale;
			element.width = size.x * scaleFactor;
			element.height = size.y * scaleFactor;
		}
	}

	Audiovisual.prototype.doTranslation = function (position) {
		if (position instanceof Point) {
			var style = this.elements[0].style;
			var origin = this.cachedOrigin;
			var scaleFactor = this.cachedScaleFactor;
			style.left = ((origin.x + position.x) * scaleFactor) + "px";
			style.top = ((origin.y + position.y) * scaleFactor) + "px";
		}
	}

	Audiovisual.prototype.toString = function () {
		if (this.name == this.obsName) {
			return this.type + "(" + Eden.edenCodeForValues(this.preload) + ")";
		} else {
			return this.type + "(" + Eden.edenCodeForValues(this.name, this.preload) + ")";		
		}
	}
	
	Audiovisual.prototype.getEdenCode = Audiovisual.prototype.toString;

	//Create an observable for background sounds.
	var backgroundAudioSym = root.lookup("background_audio");
	var backgroundAudioPausedSym = root.lookup("background_audio_paused");
	if (backgroundAudioPausedSym.value() === undefined && backgroundAudioPausedSym.definition === undefined) {
		backgroundAudioPausedSym.assign(false, root.scope, EdenSymbol.defaultAgent);
	}
	var backgroundAudio = new Audiovisual("background_audio", "Audio", true);
	backgroundAudioSym.assign(backgroundAudio, root.scope,EdenSymbol.defaultAgent);
	backgroundAudio.draw();
	backgroundAudioSym.addJSObserver("initialize", function (sym, value) {
		if (value instanceof Audiovisual) {
			value.draw();
		}
	});

}}$;

# Copyright (c) 2013, Empirical Modelling Group
# All rights reserved.
#
# See LICENSE.txt

${{
View = function (name, type, x, y, width, height) {
	this.type = type;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.name = name;
}

View.prototype.hash = function () {
	return this.x+"$$"+
		this.y+"$$"+
		this.width+"$$"+
		this.height+"$$"+
		this.type+"$$"+
		this.name+"$$";
};
}}$

/**
 * Create a View tag to display an embedded view
 * 
 * @param name
 * @param type
 * @param x X-coordinate
 * @param y Y-coordinate
 * @param [width Width in pixels or as a string or undefined
 * @param [height]] Height in pixels or as a string or undefined
 * #canvas #view #embedded
 */
func View { ${{
	var name = arguments[0];
	var type = arguments[1];
	var x = arguments[2];
	var y = arguments[3];
	var width, height;   //Number of pixels, string (e.g. "50%") or undefined (automatic)
	
	var argsProcessed = 4;
	var argType = typeof(arguments[4]);
	
	if (argType == "number" || argType == "undefined") {
		width = arguments[4];
		argsProcessed++;
		
		argType = typeof(arguments[5]);
		if (argType == "number" || argType == "undefined") {
			height = arguments[5];
			argsProcessed++;
		}
	}

	return new View(name, type, x, y, width, height);
}}$ }

${{

View.prototype.draw = function(context) {

  if (this.elements === undefined) {
	var me = this;

	var divElement = edenUI.createEmbedded(this.name, this.type).contents.get(0);
	divElement.className += " canvashtml-item canvashtml-div-item";

	/*document.createElement("div");
	if (this.name !== undefined) {
		divElement.id = this.name;
	}

	divElement.addEventListener("click", function(event) {
		var script = event.target.getAttribute("data-jseden");
		if (script !== null && script != "") {
			eden.execute2(script);
		}
	});*/

	//Create object properties that record the automatically generated width and/or height.
	if (this.width === undefined || this.name !== undefined) {
		var objectElement = document.createElement("object");
		objectElement.setAttribute("style", "display: block; position: absolute; top: 0px; left: 0px; " + 
			"height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;");

		objectElement.onload = function () {
			me.resize();
		}

		objectElement.type = "text/html";
		objectElement.data = "about:blank";
		divElement.appendChild(objectElement);
	}

	this.elements = [divElement];
  }
};

View.prototype.resize = function () {
	var scale = this.cachedScale;
	if (scale === undefined) {
		//Not yet added drawn onto a canvas.
		return;
	}

	var element = this.elements[0];
	var style = element.style;
	//style.transform = "scale("+scale+")";
	var autoWidth = this.width === undefined;
	var autoHeight = this.height === undefined;

	/*if (autoWidth) {
		var savedHeight = style.height;
		style.width = "auto";
		style.height = "auto";
		var contentWidth = element.clientWidth;
		style.width = contentWidth + "px";
		style.height = savedHeight;
		var scrollBarSize = element.offsetWidth - element.clientWidth;
		if (scrollBarSize > 0) {
			scrollBarSize = scrollBarSize + 2;
			style.width = String(contentWidth + scrollBarSize) + "px";
		} else {
			style.width = "auto";
		}
	}*/

	if (this.name !== undefined) {
		var agent = root.lookup("Div");
		var widthSymName = this.name + "_width";
		var heightSymName = this.name + "_height";

		if (autoWidth || widthSymName in eden.root.symbols) {
			root.lookup(widthSymName).assign(element.offsetWidth / scale, root.scope, agent);
		}
		if (autoHeight || heightSymName in eden.root.symbols) {
			root.lookup(heightSymName).assign(element.offsetHeight / scale, root.scope, agent);
		}
	}
}

View.prototype.scale = function (scale, zoom , origin) {
	var style = this.elements[0].style;
	style.left = Math.round((this.x + origin.x) * scale) + "px";
	style.top = Math.round((this.y + origin.y) * scale) + "px";

	if (this.width !== undefined) {
		style.width = Math.round(this.width) + "px";
	}
	if (this.height !== undefined) {
		style.height = Math.round(this.height) + "px";
	}
	/*if (this.fontSizeSpecified) {
		style.fontSize = String(this.fontSizeNumber * zoom) + this.fontSizeUnits;
	} else {
		if (zoom == 1) {
			style.fontSize = ""; //Could be specified by a CSS class.
		} else {
			style.fontSize = zoom + "em";
		}
	}*/
	if (scale != this.cachedScale) {
		style.transform = "scale("+scale+")";
	}
	this.cachedScale = scale;
	this.resize();
};

View.prototype.toString = function() {
	return this.getEdenCode();
};

View.prototype.getEdenCode = function () {
	var s = "View(" + Eden.edenCodeForValues(this.name, this.type, this.x, this.y, this.width, this.height)+")";
	return s;
};

}}$;

/* Copyright (c) 2013, Empirical Modelling Group
 * All rights reserved.
 *
 * See LICENSE.txt
 */

${{
UVMap = function(texCoords) {
	this.name = eden.root.currentObservableName();
	this.texCoords = texCoords;
	//this.off = off;
	//this.scale = scale;

	this.tbufs = {};
}

UVMap.prototype.createBuffer = function(gl, viewName) {
	this.tbufs[viewName] = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.tbufs[viewName]);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.texCoords), gl.STATIC_DRAW);
    this.tbufs[viewName].itemSize = 2;
    this.tbufs[viewName].numItems = this.texCoords.length / 2;

	//console.log("UVMAP length = ", this.texCoords.length/2);
}

}}$;

#! Make a texture coordinate map #library
UVMap is ${{ new UVMap }}$ ($1);


${{

UVMap.prototype.bind = function (context, viewName, mvMatrix, shader) {
	if (!this.tbufs[viewName]) {
		this.createBuffer(context, viewName);
	}

	context.bindBuffer(context.ARRAY_BUFFER, this.tbufs[viewName]);
	context.vertexAttribPointer(shader.textureCoordAttribute, this.tbufs[viewName].itemSize, context.FLOAT, false, 0, 0);
	//console.log("Bind UV for "+this.name+" = "+this.tbufs[viewName].numItems);
};

}}$;

/* Copyright (c) 2013, Empirical Modelling Group
 * All rights reserved.
 *
 * See LICENSE.txt
 */

${{
Mesh = function(vertices, normals, indices, kind) {
	console.log("CONSTRUCT MESH", vertices.length);
	this.name = eden.root.currentObservableName();
	this.vertices = vertices;
	this.normals = normals;
	this.indices = indices;
	this.kind = kind;

	this.vbufs = {};
	this.nbufs = {};
	this.ibufs = {};
}

Mesh.prototype.createBuffer = function(gl, viewName) {
	console.log("MAKE BUFFER",this.name);
	this.vbufs[viewName] = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vbufs[viewName]);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
    this.vbufs[viewName].itemSize = 3;
    this.vbufs[viewName].numItems = this.vertices.length / 3;

	console.log("Mesh has " + (this.vertices.length/2) + " vertices");

	this.nbufs[viewName] = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.nbufs[viewName]);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.normals), gl.STATIC_DRAW);
    this.nbufs[viewName].itemSize = 3;
    this.nbufs[viewName].numItems = this.normals.length / 3;

	if (this.indices) {
		this.ibufs[viewName] = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibufs[viewName]);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), gl.STATIC_DRAW);
		this.ibufs[viewName].itemSize = 1;
		this.ibufs[viewName].numItems = this.indices.length;
	}
}

}}$;

Mesh is ${{ new Mesh }}$ ($1,normals,indices,kind) :: kind=kind if kind!=@ else "triangles";


${{

Mesh.prototype.draw = function (context, viewName, mvMatrix, shader) {
	if (!this.vbufs[viewName]) {
		this.createBuffer(context, viewName);
	}

	context.bindBuffer(context.ARRAY_BUFFER, this.vbufs[viewName]);
    context.vertexAttribPointer(shader.vertexPositionAttribute, this.vbufs[viewName].itemSize, context.FLOAT, false, 0, 0);

	context.bindBuffer(context.ARRAY_BUFFER, this.nbufs[viewName]);
    context.vertexAttribPointer(shader.vertexNormalAttribute, this.nbufs[viewName].itemSize, context.FLOAT, false, 0, 0);

	if (this.indices) {
		context.bindBuffer(context.ELEMENT_ARRAY_BUFFER, this.ibufs[viewName]);
	}

	// Actually set the transform into the shader
	context.uniformMatrix4fv(shader.mvMatrixUniform, false, mvMatrix);

	// Calculate the normals transform and set that into shader
	var normalMatrix = mat3.create();
    mat3.fromMat4(normalMatrix,mvMatrix);
	mat3.invert(normalMatrix,normalMatrix);
    mat3.transpose(normalMatrix,normalMatrix);
    context.uniformMatrix3fv(shader.nMatrixUniform, false, normalMatrix);

	// Do the actual draw...
	if (this.indices) {
		switch (this.kind) {
		case "triangles":	context.drawElements(context.TRIANGLES, this.ibufs[viewName].numItems, context.UNSIGNED_SHORT, 0); break;
		case "trianglestrip":	context.drawElements(context.TRIANGLE_STRIP, this.ibufs[viewName].numItems, context.UNSIGNED_SHORT, 0); break;
		case "lines":	context.drawElements(context.LINES, this.ibufs[viewName].numItems, context.UNSIGNED_SHORT, 0); break;
		case "lineloop": context.drawElements(context.LINE_LOOP, this.ibufs[viewName].numItems, context.UNSIGNED_SHORT, 0); break;
		}
	} else {
		switch (this.kind) {
		case "triangles":	context.drawArrays(context.TRIANGLES, 0, this.vbufs[viewName].numItems); break;
		case "lines":	context.drawArrays(context.LINES, 0, this.vbufs[viewName].numItems); break;
		case "lineloop": context.drawArrays(context.LINE_LOOP, 0, this.vbufs[viewName].numItems); break;
		case "linestrip": context.drawArrays(context.LINE_STRIP, 0, this.vbufs[viewName].numItems); break;
		case "points": context.drawArrays(context.POINTS, 0, this.vbufs[viewName].numItems); break;
		}
	}
};

}}$;

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
SpotLight = function(position, colour) {
	this.x = position.x;
	this.y = position.y;
	this.z = position.z;
	this.colour = (colour) ? colour : "white";
}

}}$;

#! Create a spot light for a 3D scene #library
SpotLight is ${{ new SpotLight}}$ ($1,$2);

${{

SpotLight.prototype.draw = function (context, scale, viewname, mvMatrix, shader, pMatrix) {
	 context.uniform1i(shader.useLightingUniform, true);

	var colorobj = jQuery.Color( (typeof this.colour == "string") ? this.colour : "orange" );
			var r = colorobj.red() / 255;
			var g = colorobj.green() / 255;
			var b = colorobj.blue() / 255;

	context.uniform3f(
        shader.pointLightingColorUniform,
        r,
        g,
        b
      );

	var lightingPos = vec3.create();
	vec3.set(lightingPos,this.x,this.y,this.z);
	vec3.transformMat4(lightingPos, lightingPos, mvMatrix);
	context.uniform3fv(shader.pointLightingLocationUniform, lightingPos);

	/*context.uniform3f(
        shader.pointLightingLocationUniform,
        this.x,
        this.y,
        this.z
      );*/

	/*var normalMatrix = mat3.create();
    mat3.fromMat4(normalMatrix,mvMatrix);
	mat3.invert(normalMatrix,normalMatrix);
    mat3.transpose(normalMatrix,normalMatrix);

	var lightingDirection = vec3.create();
	vec3.set(lightingDirection,this.x,this.y,this.z);
	vec3.transformMat3(lightingDirection, lightingDirection, normalMatrix);
      var adjustedLD = vec3.create();
      vec3.normalize(adjustedLD,lightingDirection);
      vec3.scale(adjustedLD,adjustedLD, -1);
      context.uniform3fv(shader.lightingDirectionUniform, adjustedLD);*/
};


}}$;

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Light = function(direction, colour) {
	this.x = direction.x;
	this.y = direction.y;
	this.z = direction.z;
	this.colour = (colour) ? colour : "white";
}

}}$;

#! Creates a directional light.
#
# ##Usage Example
#  `Light::(Point3D::(x,y,z),"white");`
# 
#  #canvas #rectangle #drawingoptions #square #box #shape #draw
Light is ${{ new Light }}$ ($1,$2);

${{

Light.prototype.draw = function (context, scale, viewname, mvMatrix, shader, pMatrix) {
	 context.uniform1i(shader.useLightingUniform, true);
	console.log("Use uniform lighting");

	var colorobj = jQuery.Color( (typeof this.colour == "string") ? this.colour : "orange" );
			var r = colorobj.red() / 255;
			var g = colorobj.green() / 255;
			var b = colorobj.blue() / 255;

	context.uniform3f(
        shader.directionalColorUniform,
        r,
        g,
        b
      );

	var normalMatrix = mat3.create();
    mat3.fromMat4(normalMatrix,mvMatrix);
	mat3.invert(normalMatrix,normalMatrix);
    mat3.transpose(normalMatrix,normalMatrix);

	var lightingDirection = vec3.create();
	vec3.set(lightingDirection,this.x,this.y,this.z);
	vec3.transformMat3(lightingDirection, lightingDirection, normalMatrix);
      var adjustedLD = vec3.create();
      vec3.normalize(adjustedLD,lightingDirection);
      vec3.scale(adjustedLD,adjustedLD, -1);
      context.uniform3fv(shader.lightingDirectionUniform, adjustedLD);
};

Light.prototype.isHit = function (context, scale, x, y) {
	return false;
}

}}$;

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Material = function(texture,colour,toff,tscale) {
	this.texture = texture;
	this.colour = colour;
	this.toff = toff;
	this.tscale = tscale;
}

}}$;



/* Copyright (c) 2013, Empirical Modelling Group
 * All rights reserved.
 *
 * See LICENSE.txt
 */

#Taints the canvas if the file is located on another domain.

${{
Texture = function (file, clamp, mipmap, nearest, format, glow) {
	this.clamp = clamp;
	this.mipmap = mipmap;
	this.nearest = nearest;
	this.format = format;
	this.glow = glow;
	this.image = new Image();
	//this.image.setAttribute("crossorigin","anonymous");	
	this.canvasesToRepaint = {};
	this.loaded = false;
	
	var me = this;

	this.texture = {};
	
	this.image.onload = function() {
		me.loaded = true;
		for (var viewName in me.canvasesToRepaint) {
			edenUI.plugins.Canvas2D.drawPicture(viewName);
		}
	}
	this.image.src = file;
};

Texture.textures = {};
}}$;

#! Load a texture for a surface. #library
Texture is ${{ new Texture }}$ ($1,clamp || true,mipmap || true, nearest,format || "rgba",glow);

${{
function isPowerOf2(value) {
  return (value & (value - 1)) == 0;
};


Texture.prototype.bind = function(context, viewName, shader) {
	if (this.loaded) {
		if (!this.texture[viewName]) {
			this.texture[viewName] = context.createTexture();
			context.bindTexture(context.TEXTURE_2D, this.texture[viewName]);
			context.pixelStorei(context.UNPACK_FLIP_Y_WEBGL, true);
			context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, context.RGBA, context.UNSIGNED_BYTE, this.image);

			if (isPowerOf2(this.image.width) && isPowerOf2(this.image.height)) { // && this.mipmap) {
				// the dimensions are power of 2 so generate mips and turn on 
				// tri-linear filtering.
				context.generateMipmap(context.TEXTURE_2D);
				context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.LINEAR_MIPMAP_LINEAR);
			  } else {
				console.log("Non-p of 2");
				// at least one of the dimensions is not a power of 2 so set the filtering
				// so WebGL will render it.
				context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);
				context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);
				//context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.LINEAR);
				context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);
				context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST);
			  }

			console.log("IMAGE TEXTURE MADE FOR", viewName);

			//context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);
			//context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST);
			//context.bindTexture(context.TEXTURE_2D, null);
		} else {
			context.bindTexture(context.TEXTURE_2D, this.texture[viewName]);
		}
	} else {
		this.canvasesToRepaint[viewName] = true;
	}
};

}}$;

/* Copyright (c) 2013, Empirical Modelling Group
 * All rights reserved.
 *
 * See LICENSE.txt
 */

${{
STLModel = function (file) {
	this.canvasesToRepaint = {};
	this.loaded = false;
	
	var me = this;

	var xhr = new XMLHttpRequest();
	xhr.open('GET', file, true);
	xhr.responseType = 'arraybuffer';
	 
	xhr.onload = function(e) {
	 // console.log("XHR",xhr.status,e);
	  if (this.status == 200) {
		// get binary data as a response
		var blob = this.response;

		let stlReader = new stlreader.stlreader();
		let facets = stlReader.read(blob);

		me.mesh = new Mesh(facets.vertices, facets.normals, undefined, "triangles");
		//console.log("STL",facets);

		me.loaded = true;
		for (var viewName in me.canvasesToRepaint) {
			edenUI.plugins.Canvas2D.drawPicture(viewName);
		}
	  }
	};
	 
	xhr.send();

	this.mesh = null;
};
}}$;

#! Load an STL Model. #library
STLModel is ${{ new STLModel }}$ ($1);

${{

STLModel.prototype.draw = function (context, viewName, mvMatrix, shader) {
	if (this.loaded) {
		this.mesh.draw(context, viewName, mvMatrix, shader);
	}
}

}}$;

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt


${{
Shape = function(mesh, pos, scale, rot, material, uvmap, ortho) {
	this.mesh = mesh;
	this.position = pos;
	this.scale = scale;
	this.rotation = rot;
	this.material = (material) ? material : "orange";
	this.obsName = root.currentObservableName();
	this.uvmap = uvmap;
	this.ortho = ortho;

	this.texture = {};
}

}}$;

Shape is ${{ new Shape }}$ ($1, $2, scale, rotation, material, uvmap, ortho);

${{

Shape.prototype.draw = function (context, pscale, viewname, mvMatrix, shader, pMatrix, canvas, id) {
	if (this.ortho) {
		mat4.identity(mvMatrix);
	}

	var translation = vec3.create();
	vec3.set (translation, this.position.x, this.position.y, this.position.z);
	mat4.translate(mvMatrix,mvMatrix,translation);

	if (this.scale) {
		var scale = vec3.create();
		vec3.set(scale, this.scale.x, this.scale.y, this.scale.z);
		mat4.scale(mvMatrix,mvMatrix,scale);
	}


	if (this.rotation) {
		var rot = vec3.create();
		if (this.rotation.x) {
			vec3.set(rot, 1, 0, 0);
			mat4.rotate(mvMatrix, mvMatrix, this.rotation.x * Math.PI / 180, rot);
		}
		if (this.rotation.y) {
			vec3.set(rot, 0, 1, 0);
			mat4.rotate(mvMatrix, mvMatrix, this.rotation.y * Math.PI / 180, rot);
		}
		if (this.rotation.z) {
			vec3.set(rot, 0, 0, 1);
			mat4.rotate(mvMatrix, mvMatrix, this.rotation.z * Math.PI / 180, rot);
		}
	}

	if (!this.uvmap) context.disableVertexAttribArray(shader.textureCoordAttribute);

	if (this.material instanceof Texture) {
		if (this.uvmap) this.uvmap.bind(context, viewname, mvMatrix, shader);

		context.activeTexture(context.TEXTURE0);

		if (this.material.loaded) {
			//console.log("LOADED TEXTURE");
			this.material.bind(context,viewname, shader);
		} else {
			this.material.bind(context,viewname, shader);

			if (!this.texture[viewname]) {
				this.texture[viewname] = context.createTexture();
				context.bindTexture(context.TEXTURE_2D, this.texture[viewname]);
				context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, 1, 1, 0, context.RGBA, context.UNSIGNED_BYTE,
							  new Uint8Array([100, 100, 100, 255]));
			} else {
				context.bindTexture(context.TEXTURE_2D, this.texture[viewname]);
			}
		}
    	context.uniform1i(shader.samplerUniform, 0);
	} else {
		if (!this.texture[viewname]) {
			var colorobj = jQuery.Color( (typeof this.material == "string") ? this.material : "orange" );
			var r = colorobj.red();
			var g = colorobj.green();
			var b = colorobj.blue();

			//console.log("Making colour texture");

			var rgbstr = "rgb("+r+","+g+","+b+")";
			if (!Texture.textures[viewname]) Texture.textures[viewname] = {};
			if (Texture.textures[viewname][rgbstr]) {
				if (this.uvmap) this.uvmap.bind(context, viewname, mvMatrix, shader);
				this.texture[viewname] = Texture.textures[viewname][rgbstr];
				context.activeTexture(context.TEXTURE0);
				context.bindTexture(context.TEXTURE_2D, this.texture[viewname]);
				//console.log("Reuse colour");
			} else {
				this.texture[viewname] = context.createTexture();
				Texture.textures[viewname][rgbstr] = this.texture[viewname];

				if (this.uvmap) this.uvmap.bind(context, viewname, mvMatrix, shader);
				console.log("New colour being made");
				context.activeTexture(context.TEXTURE0);
				context.bindTexture(context.TEXTURE_2D, this.texture[viewname]);
				context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, 1, 1, 0, context.RGBA, context.UNSIGNED_BYTE,
							  new Uint8Array([r, g, b, 255]));
				context.uniform1i(shader.samplerUniform, 0);
				console.log("New colour made");
			}
		} else {
			if (this.uvmap) this.uvmap.bind(context, viewname, mvMatrix, shader);
			//console.log("UVMAP",this.uvmap.texCoords.length/2,this.mesh.vertices.length/3);

			context.activeTexture(context.TEXTURE0);
	   		context.bindTexture(context.TEXTURE_2D, this.texture[viewname]);
			context.uniform1i(shader.samplerUniform, 0);
		}
	}

	//console.log("MESH DRAW",this.mesh.vertices.length/3);

	if (this.ortho) {
		context.uniformMatrix4fv(shader.pMatrixUniform, false, canvas.oMatrix);
		this.mesh.draw(context, viewname, mvMatrix, shader);
		context.uniformMatrix4fv(shader.pMatrixUniform, false, canvas.pMatrix);
	} else {
		this.mesh.draw(context, viewname, mvMatrix, shader);
	}

	if (!this.uvmap) context.enableVertexAttribArray(shader.textureCoordAttribute);
};

}}$;

/* Copyright (c) 2013, Empirical Modelling Group
 * All rights reserved.
 *
 * See LICENSE.txt
 */

shape_sphere_longitudes = 30;
shape_sphere_latitudes = 30;
shape_sphere_theta is lat * 180 / shape_sphere_latitudes;
shape_sphere_phi is longi * 360 / shape_sphere_longitudes;
shape_sphere_cosphi is cos(shape_sphere_phi);
shape_sphere_sinphi is sin(shape_sphere_phi);
shape_sphere_costheta is cos(shape_sphere_theta);
shape_sphere_sintheta is sin(shape_sphere_theta);
shape_sphere_x is shape_sphere_cosphi * shape_sphere_sintheta;
shape_sphere_y is shape_sphere_costheta;
shape_sphere_z is shape_sphere_sinphi * shape_sphere_sintheta;
shape_sphere_u is 1 - (longi / shape_sphere_longitudes);
shape_sphere_v is 1 - (lat / shape_sphere_latitudes);

test_lib_load = sin != @;

shape_sphere_first is (lat * (shape_sphere_longitudes + 1)) + longi;
shape_sphere_second is shape_sphere_first + shape_sphere_longitudes + 1;

do lib;

shape_sphere_vertices is concat(
	([shape_sphere_x, shape_sphere_y, shape_sphere_z]::lat in 0..shape_sphere_latitudes, longi in 0..shape_sphere_longitudes)
);

shape_sphere_normals is concat(
	([shape_sphere_x, shape_sphere_y, shape_sphere_z]::lat in 0..shape_sphere_latitudes, longi in 0..shape_sphere_longitudes)
);

shape_sphere_texCoords is concat(
	([shape_sphere_u, shape_sphere_v]::lat in 0..shape_sphere_latitudes, longi in 0..shape_sphere_longitudes)
);

shape_sphere_indices is concat(
	([shape_sphere_first, shape_sphere_second, shape_sphere_first+1, shape_sphere_second,
		shape_sphere_second+1,shape_sphere_first+1]::lat in 0..shape_sphere_latitudes-1, longi in 0..shape_sphere_longitudes-1)
);

shape_sphere_uvmap is UVMap::shape_sphere_texCoords;

shape_sphere_mesh is Mesh::(shape_sphere_vertices, normals=shape_sphere_normals, indices=shape_sphere_indices, kind="triangles");
shape_sphere_lod_1 is shape_sphere_mesh;
shape_sphere_lod_2 is shape_sphere_mesh :: shape_sphere_longitudes=10, shape_sphere_latitudes=10;

#! Create a Sphere #library
Sphere is Shape::(shape_sphere_lod_1 if lod==@ else shape_sphere_lod_2, $1, uvmap=uvmap if uvmap else shape_sphere_uvmap);


/* Copyright (c) 2013, Empirical Modelling Group
 * All rights reserved.
 *
 * See LICENSE.txt
 */

shape_cube_vertices = [
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
        ];

shape_cube_normals = [
       0.0,  0.0,  1.0,
       0.0,  0.0,  1.0,
       0.0,  0.0,  1.0,
       0.0,  0.0,  1.0,

       0.0,  0.0, -1.0,
       0.0,  0.0, -1.0,
       0.0,  0.0, -1.0,
       0.0,  0.0, -1.0,

       0.0,  1.0,  0.0,
       0.0,  1.0,  0.0,
       0.0,  1.0,  0.0,
       0.0,  1.0,  0.0,

       0.0, -1.0,  0.0,
       0.0, -1.0,  0.0,
       0.0, -1.0,  0.0,
       0.0, -1.0,  0.0,

       1.0,  0.0,  0.0,
       1.0,  0.0,  0.0,
       1.0,  0.0,  0.0,
       1.0,  0.0,  0.0,

      -1.0,  0.0,  0.0,
      -1.0,  0.0,  0.0,
      -1.0,  0.0,  0.0,
      -1.0,  0.0,  0.0
    ];

shape_cube_indices = [
            0, 1, 2,      0, 2, 3,
            4, 5, 6,      4, 6, 7,
            8, 9, 10,     8, 10, 11,
            12, 13, 14,   12, 14, 15,
            16, 17, 18,   16, 18, 19,
            20, 21, 22,   20, 22, 23
        ];

shape_cube_textureCoords = [
      0.0, 0.0,
      1.0, 0.0,
      1.0, 1.0,
      0.0, 1.0,

      1.0, 0.0,
      1.0, 1.0,
      0.0, 1.0,
      0.0, 0.0,

      0.0, 1.0,
      0.0, 0.0,
      1.0, 0.0,
      1.0, 1.0,

      1.0, 1.0,
      0.0, 1.0,
      0.0, 0.0,
      1.0, 0.0,

      1.0, 0.0,
      1.0, 1.0,
      0.0, 1.0,
      0.0, 0.0,

      0.0, 0.0,
      1.0, 0.0,
      1.0, 1.0,
      0.0, 1.0
    ];

shape_cube_uvmap = UVMap::shape_cube_textureCoords;

shape_cube_mesh = Mesh::(shape_cube_vertices, normals=shape_cube_normals, indices=shape_cube_indices, kind="triangles");

Cube is Shape::(shape_cube_mesh, $1, uvmap=uvmap if uvmap else shape_cube_uvmap);


/* Copyright (c) 2013, Empirical Modelling Group
 * All rights reserved.
 *
 * See LICENSE.txt
 */

shape_plane_vertices = [
            -1.0, -1.0,  0.0,
             1.0, -1.0,  0.0,
             1.0,  1.0,  0.0,
            -1.0,  1.0,  0.0
        ];

shape_plane_normals = [
       0.0,  0.0,  1.0,
       0.0,  0.0,  1.0,
       0.0,  0.0,  1.0,
       0.0,  0.0,  1.0
    ];

shape_plane_indices = [
            0, 1, 2,      0, 2, 3
        ];

shape_plane_textureCoords = [
      0.0, 0.0,
      1.0, 0.0,
      1.0, 1.0,
      0.0, 1.0
    ];

shape_plane_uvmap = UVMap::shape_plane_textureCoords;

shape_plane_mesh = Mesh::(shape_plane_vertices, normals=shape_plane_normals, indices=shape_plane_indices, kind="triangles");

#! A 2D rectangular plane in 3D space. #library
Plane is Shape::(shape_plane_mesh, $1, uvmap=uvmap if uvmap else shape_plane_uvmap);


${{
EdenUI.edgeTable = new Int32Array([
0x0  , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c,
0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac,
0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
0x460, 0x569, 0x663, 0x76a, 0x66 , 0x16f, 0x265, 0x36c,
0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff , 0x3f5, 0x2fc,
0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55 , 0x15c,
0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc ,
0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
0xcc , 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
0x15c, 0x55 , 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
0x2fc, 0x3f5, 0xff , 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
0x36c, 0x265, 0x16f, 0x66 , 0x76a, 0x663, 0x569, 0x460,
0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa , 0x1a3, 0x2a9, 0x3a0,
0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33 , 0x339, 0x230,
0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99 , 0x190,
0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0])

EdenUI.triTable = new Int32Array([
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1,
3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1,
3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1,
3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1,
9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1,
1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1,
9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1,
2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1,
8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1,
9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1,
4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1,
3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1,
1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1,
4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1,
4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1,
9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1,
1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1,
5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1,
2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1,
9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1,
0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1,
2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1,
10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1,
4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1,
5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1,
5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1,
9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1,
0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1,
1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1,
10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1,
8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1,
2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1,
7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1,
9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1,
2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1,
11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1,
9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1,
5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1,
11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1,
11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1,
1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1,
9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1,
5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1,
2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1,
0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1,
5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1,
6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1,
0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1,
3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1,
6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1,
5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1,
1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1,
10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1,
6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1,
1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1,
8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1,
7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1,
3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1,
5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1,
0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1,
9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1,
8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1,
5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1,
0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1,
6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1,
10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1,
10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1,
8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1,
1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1,
3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1,
0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1,
10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1,
0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1,
3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1,
6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1,
9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1,
8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1,
3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1,
6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1,
0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1,
10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1,
10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1,
1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1,
2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1,
7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1,
7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1,
2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1,
1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1,
11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1,
8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1,
0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1,
7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1,
10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1,
2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1,
6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1,
7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1,
2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1,
1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1,
10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1,
10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1,
0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1,
7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1,
6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1,
8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1,
9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1,
6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1,
1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1,
4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1,
10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1,
8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1,
0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1,
1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1,
8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1,
10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1,
4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1,
10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1,
5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1,
11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1,
9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1,
6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1,
7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1,
3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1,
7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1,
9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1,
3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1,
6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1,
9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1,
1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1,
4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1,
7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1,
6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1,
3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1,
0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1,
6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1,
1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1,
0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1,
11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1,
6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1,
5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1,
9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1,
1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1,
1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1,
10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1,
0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1,
5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1,
10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1,
11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1,
9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1,
7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1,
2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1,
8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1,
9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1,
9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1,
1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1,
9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1,
9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1,
5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1,
0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1,
10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1,
2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1,
0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1,
0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1,
9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1,
5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1,
3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1,
5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1,
8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1,
0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1,
9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1,
0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1,
1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1,
3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1,
4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1,
9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1,
11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1,
11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1,
2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1,
9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1,
3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1,
1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1,
4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1,
4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1,
0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1,
3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1,
3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1,
0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1,
9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1,
1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]);
}}$


${{

}}$

func IsoSurfaceSN {
	para values,size,axisMin,axisRange;
	${{ var tet = surfaceNets(size, values,axisMin,axisRange);
	return [tet.positions,tet.normals]; }}$;
}

func IsoSurfaceMC {
	para values,size,axisMin,axisRange;

	${{
	// Marching Cubes Algorithm
	console.time("IsoSurface");
	
	var size2 = size * size;
	// Vertices may occur along edges of cube, when the values at the edge's endpoints
	//   straddle the isolevel value.
	// Actual position along edge weighted according to function values.
	var vlist = new Array(12);
	
	var vertexIndex = 0;

	//var points = [];
	var vertices = [];
	var normals = [];

	var delta = axisRange / (size);

	/*for (var k = 0; k < size; k++)
	for (var j = 0; j < size; j++)
	for (var i = 0; i < size; i++)
	{
		// actual values
		var x = axisMin + axisRange * i / (size - 1);
		var y = axisMin + axisRange * j / (size - 1);
		var z = axisMin + axisRange * k / (size - 1);
		points.push( new Point3D(x,y,z) );
	}*/

	var point_x = axisMin;
	var point_y = axisMin;
	var point_z = axisMin;
	
	for (var z = 0; z < size - 1; z++) {
	for (var y = 0; y < size - 1; y++) {
	for (var x = 0; x < size - 1; x++)
	{
		// index of base point, and also adjacent points on cube
		var p    = x + size * y + size2 * z,
			px   = p   + 1,
			py   = p   + size,
			pxy  = py  + 1,
			pz   = p   + size2,
			pxz  = px  + size2,
			pyz  = py  + size2,
			pxyz = pxy + size2;
		
		// store scalar values corresponding to vertices
		var value0 = values[ p    ],
			value1 = values[ px   ],
			value2 = values[ py   ],
			value3 = values[ pxy  ],
			value4 = values[ pz   ],
			value5 = values[ pxz  ],
			value6 = values[ pyz  ],
			value7 = values[ pxyz ];
		
		// place a "1" in bit positions corresponding to vertices whose
		//   isovalue is less than given constant.
		
		var isolevel = 0;
		
		var cubeindex = 0;
		if ( value0 >= isolevel ) cubeindex |= 1;
		if ( value1 >= isolevel ) cubeindex |= 2;
		if ( value2 >= isolevel ) cubeindex |= 8;
		if ( value3 >= isolevel ) cubeindex |= 4;
		if ( value4 >= isolevel ) cubeindex |= 16;
		if ( value5 >= isolevel ) cubeindex |= 32;
		if ( value6 >= isolevel ) cubeindex |= 128;
		if ( value7 >= isolevel ) cubeindex |= 64;
		
		// bits = 12 bit number, indicates which edges are crossed by the isosurface
		var bits = EdenUI.edgeTable[ cubeindex ];
		
		// if none are crossed, proceed to next iteration
		if ( bits === 0 ) {
			point_x += delta;
			continue;
		}
		
		// check which edges are crossed, and estimate the point location
		//    using a weighted average of scalar values at edge endpoints.
		// store the vertex in an array for use later.
		var mu = 0.5; 
		
		// bottom of the cube
		if ( bits & 1 )
		{
			mu = ( isolevel - value0 ) / ( value1 - value0 );
			//vlist[0] = points[p].lerp( points[px], mu );
			vlist[0] = [point_x + mu*delta, point_y, point_z];
		}
		if ( bits & 2 )
		{
			mu = ( isolevel - value1 ) / ( value3 - value1 );
			//vlist[1] = points[px].lerp( points[pxy], mu );
			vlist[1] = [point_x+delta, point_y + mu*delta, point_z];
		}
		if ( bits & 4 )
		{
			mu = ( isolevel - value2 ) / ( value3 - value2 );
			//vlist[2] = points[py].lerp( points[pxy], mu );
			vlist[2] = [point_x+mu*delta, point_y+delta,point_z];
		}
		if ( bits & 8 )
		{
			mu = ( isolevel - value0 ) / ( value2 - value0 );
			//vlist[3] = points[p].lerp( points[py], mu );
			vlist[3] = [point_x,point_y+mu*delta,point_z];
		}
		// top of the cube
		if ( bits & 16 )
		{
			mu = ( isolevel - value4 ) / ( value5 - value4 );
			//vlist[4] = points[pz].lerp( points[pxz], mu );
			vlist[4] = [point_x+mu*delta,point_y,point_z+delta];
		}
		if ( bits & 32 )
		{
			mu = ( isolevel - value5 ) / ( value7 - value5 );
			//vlist[5] = points[pxz].lerp( points[pxyz], mu );
			vlist[5] = [point_x+delta,point_y+mu*delta,point_z+delta];
		}
		if ( bits & 64 )
		{
			mu = ( isolevel - value6 ) / ( value7 - value6 );
			//vlist[6] = points[pyz].lerp( points[pxyz], mu );
			vlist[6] = [point_x+mu*delta,point_y+delta,point_z+delta];
		}
		if ( bits & 128 )
		{
			mu = ( isolevel - value4 ) / ( value6 - value4 );
			//vlist[7] = points[pz].lerp( points[pyz], mu );
			vlist[7] = [point_x,point_y+mu*delta,point_z+delta];
		}
		// vertical lines of the cube
		if ( bits & 256 )
		{
			mu = ( isolevel - value0 ) / ( value4 - value0 );
			//vlist[8] = points[p].lerp( points[pz], mu );
			vlist[8] = [point_x,point_y,point_z+mu*delta];
		}
		if ( bits & 512 )
		{
			mu = ( isolevel - value1 ) / ( value5 - value1 );
			//vlist[9] = points[px].lerp( points[pxz], mu );
			vlist[9] = [point_x+delta,point_y,point_z+mu*delta];
		}
		if ( bits & 1024 )
		{
			mu = ( isolevel - value3 ) / ( value7 - value3 );
			//vlist[10] = points[pxy].lerp( points[pxyz], mu );
			vlist[10] = [point_x+delta,point_y+delta,point_z+mu*delta];
		}
		if ( bits & 2048 )
		{
			mu = ( isolevel - value2 ) / ( value6 - value2 );
			//vlist[11] = points[py].lerp( points[pyz], mu );
			vlist[11] = [point_x,point_y+delta,point_z+mu*delta];
		}
		
		// construct triangles -- get correct vertices from triTable.
		var i = 0;
		cubeindex <<= 4;  // multiply by 16... 
		// "Re-purpose cubeindex into an offset into triTable." 
		//  since each row really isn't a row.
		// the while loop should run at most 5 times,
		//   since the 16th entry in each row is a -1.
		while ( EdenUI.triTable[ cubeindex + i ] != -1 ) 
		{
			var index1 = EdenUI.triTable[cubeindex + i];
			var index2 = EdenUI.triTable[cubeindex + i + 1];
			var index3 = EdenUI.triTable[cubeindex + i + 2];

			//if (vlist[index3].z < 0 && z >= 49) zcount++;
			
			vertices.push( vlist[index1][0], vlist[index1][1], vlist[index1][2] );
			vertices.push( vlist[index2][0], vlist[index2][1], vlist[index2][2] );
			vertices.push( vlist[index3][0], vlist[index3][1], vlist[index3][2] );
			vertexIndex += 3;
			i += 3;

			var norm = Point3D.normal(vlist[index1],vlist[index2],vlist[index3]);
			normals.push(norm.x,norm.y,norm.z);
			normals.push(norm.x,norm.y,norm.z);
			normals.push(norm.x,norm.y,norm.z);
		}
		point_x += delta;
	}
		point_x = axisMin;
		point_y += delta;
	}
		point_x = axisMin;
		point_y = axisMin;
		point_z += delta;
	}

	console.timeEnd("IsoSurface");
	return [vertices,normals];
	}}$
}

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt


${{
Line3D = function(start, end, colour, width) {
	this.start = start;
	this.end = end;
	this.colour = (colour)?colour:"black";
	this.width = (width)?width:2;

	this.vbufs = {};
	this.nbufs = {};
	this.mbufs = {};
	this.ibufs = {};
}

Line3D.makeShader = function(gl, viewname) {
	// Per fragment lighting
	var fragmentShader = EdenUI.plugins.Canvas2D.getShader(gl, `
#ifdef GL_ES
precision mediump float;
#endif

uniform vec3 color;
uniform float inner;
varying float edge;

const vec3 color2 = vec3(0.8);

void main() {
  float v = 1.0 - abs(edge);
  v = smoothstep(0.65, 0.7, v*inner); 
  gl_FragColor = mix(vec4(color, 1.0), vec4(0.0), v);
}
`,"fragment");

	var vertexShader = EdenUI.plugins.Canvas2D.getShader(gl,`
attribute vec2 position;
attribute vec2 normal;
attribute float miter; 
uniform mat4 projection;
uniform mat4 modelview;
uniform float thickness;
varying float edge;

void main() {
  edge = sign(miter);
  vec2 pointPos = position.xy + vec2(normal * thickness/2.0 * miter);
  gl_Position = projection * modelview * vec4(pointPos, 0.0, 1.0);
  gl_PointSize = 1.0;
}
`,"vertex");


    shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      alert("Could not initialise shaders");
    }

    gl.useProgram(shaderProgram);

	shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "position");
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
	shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "normal");
    gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
	shaderProgram.miterAttribute = gl.getAttribLocation(shaderProgram, "miter");
   	gl.enableVertexAttribArray(shaderProgram.miterAttribute);

	shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "projection");
    shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "modelview");
	shaderProgram.thicknessUniform = gl.getUniformLocation(shaderProgram, "thickness");
	shaderProgram.innerUniform = gl.getUniformLocation(shaderProgram, "inner");
	shaderProgram.colourUniform = gl.getUniformLocation(shaderProgram, "color");
	Line3D.shaders[viewname] = shaderProgram;
	return shaderProgram;
}

Line3D.shaders = {};

}}$;

#! Draw a line in 3D space. #library
Line3D is ${{ new Line3D }}$ ($1, $2, colour, width);


${{

Line3D.prototype.draw = function (context, scale, viewname, mvMatrix, shader, pMatrix) {
	var lineshader = Line3D.shaders[viewname];
	if (!lineshader) lineshader = Line3D.makeShader(context, viewname);
	context.useProgram(lineshader);

	// Actually set the transform into the shader
	context.uniformMatrix4fv(lineshader.mvMatrixUniform, false, mvMatrix);
	context.uniformMatrix4fv(lineshader.pMatrixUniform, false, pMatrix);
	context.uniform1f(lineshader.thicknessUniform, this.width);
	context.uniform1f(lineshader.innerUniform, 0);

	var colorobj = jQuery.Color( (typeof this.colour == "string") ? this.colour : "orange" );
			var r = colorobj.red() / 255;
			var g = colorobj.green() / 255;
			var b = colorobj.blue() / 255;

	context.uniform3f(
        lineshader.colourUniform,
        r,
        g,
        b
      );


	if (this.vbufs[viewname] === undefined) {
		this.vbufs[viewname] = context.createBuffer();
		this.nbufs[viewname] = context.createBuffer();
		this.mbufs[viewname] = context.createBuffer();
		this.ibufs[viewname] = context.createBuffer();
	}

	var vertices = [
		this.start.x, this.start.y,
		this.end.x, this.end.y,
		this.start.x, this.start.y,
		this.end.x, this.end.y
	];

	var dx = this.end.x - this.start.x;
	var dy = this.end.y - this.start.y;
	var normals = [-dy,dx,dy,-dx,-dy,dx,dy,-dx];

	var miters = [1,1,-1,-1];
	var indices = [0,1,3,1,2,0];

	context.bindBuffer(context.ARRAY_BUFFER, this.vbufs[viewname]);
	context.bufferData(context.ARRAY_BUFFER, new Float32Array(vertices), context.DYNAMIC_DRAW);
	context.vertexAttribPointer(lineshader.vertexPositionAttribute, 2, context.FLOAT, false, 0, 0);
	context.bindBuffer(context.ARRAY_BUFFER, this.nbufs[viewname]);
	context.bufferData(context.ARRAY_BUFFER, new Float32Array(normals), context.DYNAMIC_DRAW);
	context.vertexAttribPointer(lineshader.vertexNormalAttribute, 2, context.FLOAT, false, 0, 0);
	context.bindBuffer(context.ARRAY_BUFFER, this.mbufs[viewname]);
	context.bufferData(context.ARRAY_BUFFER, new Float32Array(miters), context.DYNAMIC_DRAW);
	context.vertexAttribPointer(lineshader.miterAttribute, 1, context.FLOAT, false, 0, 0);
	context.bindBuffer(context.ELEMENT_ARRAY_BUFFER, this.ibufs[viewname]);
	context.bufferData(context.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), context.DYNAMIC_DRAW);

	context.drawElements(context.TRIANGLES, 6, context.UNSIGNED_SHORT, 0);

	context.useProgram(shader);
};

}}$;
