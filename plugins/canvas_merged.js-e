## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

#! Creates a clickable Button in your canvas. If you give the button a name then you can use observables with that name and _click or _clicked to respond to button presses.
#
# ##Usage Example
#  `Button("mybutton", "Label", x, y);`
#
# @param name Name to be used for the _click and _clicked observable
# @param label Label to be displayed
# @param [imageURL] Image to be displayed on the button
# @param x
# @param y
# @param [width] Default fits the size of the label
# @param [height] Default fits the size of the label
# @param [enabled]
# 
#  #canvas #button
func Button {
${{
	var argsProcessed, arg, argType;
	var name, label, imageURL;
	var nameSpecified = false;
	for (argsProcessed = 0; argsProcessed < 3; argsProcessed++) {
		arg = arguments[argsProcessed];
		if (arg !== undefined && typeof(arg) != "string") {
			break;
		}
	}

	if (argsProcessed == 3) {
		name = arguments[0];
		label = arguments[1];
		imageURL = arguments[2];
		nameSpecified = true;
	} else if (argsProcessed > 0) {
		var str = arguments[argsProcessed - 1];
		var found = false;
		for (var i = 0; i < Button.imageFileSuffixes.length; i++) {
			var filenameSuffix = Button.imageFileSuffixes[i];
			if (str.substr(-filenameSuffix.length) == filenameSuffix) {
				imageURL = str;
				if (argsProcessed == 2) {
					label = arguments[0];
				}
				found = true;
				break;
			}
		}
		if (!found) {
			label = str;
			if (argsProcessed == 2) {
				name = arguments[0];
				nameSpecified = true;
			}
		}
	}
	if (name === undefined) {
		var obsName = root.currentObservableName();
		if (!nameSpecified) {
			name = obsName;
		}
		if (name === undefined) {
			eden.error(new Error("Button: The button defined by observable " + obsName + " must have a name."), "error");
			return undefined;
		}	
	}

	var x = arguments[argsProcessed];
	argsProcessed++;
	var y = arguments[argsProcessed];
	argsProcessed++;
	arg = arguments[argsProcessed];
	argType = typeof(arg);

	var width, minHeight, enabled;

	if (argType == "number") {
		width = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);

		if (argType == "number") {
			minHeight = arg;
			argsProcessed++;
			arg = arguments[argsProcessed];
			argType = typeof(arg);
		}
	}

	if (argType == "boolean") {
		enabled = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);	
	} else {
		enabled = true;
	}

	if (argsProcessed < arguments.length - 2) {
		argsProcessed = arguments.length - 2;
	}

	var fillcolour = arguments[argsProcessed];
	var textcolour = arguments[argsProcessed + 1];
	return new Button(name, label, imageURL, x, y, width, minHeight, enabled, fillcolour, textcolour);
}}$;
}

# Copyright (c) 2013, Empirical Modelling Group
# All rights reserved.
#
# See LICENSE.txt


#Initialize observables
mouseButton = "";
mouseButtons = "";
mouseCapture = false;
mouseCaptured = false;
mouseContextMenuEnabled = false;
mouseDoubleClicks = 0;
mouseDown = @;
mouseDownView = @;
mouseDownZone = @;
mouseFollow = false;
mousePosition = @;
mousePressed = false;
mouseUp = @;
mouseWheel = 0;
mouseWheelEnabled = false;
mouseWheelVelocity = 0;
mouseView = @;
mouseX is @ if mousePosition == @ else mousePosition["x"];
mouseY is @ if mousePosition == @ else mousePosition["y"];
mouseZone = @;
pixel is 1 / view_picture_scale;
touchPanX = 0;
touchPanXSpeed = 0;
touchPinch = 0;
touchPinchEnabled = false;

/** 
* Attempts to capture the mouse pointer so the it cannot leave the current canvas window.  This
* allows the mouse to be used as a pure sensor and the mousePosition observable becomes able to take
* on any value, free from the constraints of the size of the window.  Note that this procedure will
* only work if the window has already been in mouse capture mode previously and the user did not
* exit capture mode using the escape key.

* The sequence of events:
* 1) The model sets the mouseCapture observable to true, meaning that mouse capture is permitted.
* 1) The user clicks in the canvas window to initiate capture mode.  The mouseCaptured observable
*     automatically gets set to true.
* 1) Capture mode is ended either by (a) the user pressing the escape key, or, (b) the model
*     setting the mouseCapture observable to false.
* 1) Calling attemptMouseCapture after case (3b) has occurred will succeed in the mouse pointer
*     becoming captured again immediately.  However, if case (3a) occurred then calling
*     attemptMouseCapture won't do anything.  If this situation occurs then the model can still set
*     mouseCapture to true and wait for the user to re-grant permission to capture mouse movements
*     by clicking in the window again.
*
* Note that at the time of writing (5/2/2015) although the underlying API has received the W3C's
* Candidate Recommendation approval it is currently only implemented in recent versions of Chrome.
* Access to mouse capturing capabilities can be restricted based upon a browser preference setting.
* (In Chrome this is under Settings->Advanced settings->Content settings->Mouse cursor.)
*/
proc attemptMouseCapture {
	${{
		var canvasName = root.lookup("mouseView").value();
		if (canvasName !== undefined) {
			canvases[canvasName].requestPointerLock();
		}
	}}$;
}

/**
* Creates a canvas and a triggered procedure so that canvas display is kept in
* sync with the value of a given observable at all times.  The first parameter
* is the name of the observable that provides the list of drawables.  The
* second, optional parameter, is the text to place into the window's title bar.
*
* 
* If three parameters are provided, the first is the viewName, the second is the
* observable that stores the list of drawables. The third parameter is the text to place
* into the window's title bar.
* 
* @param [viewName]
* @param observableName
* @param viewTitle
* 
*/
func createCanvas {
	para p1, p2, p3;
	auto obsName, viewTitle, viewName;
	auto titleSymName, contentSymName, addJSObserver;
	auto argc;
	argc = ${{ arguments.length }}$;
	viewName = @;
	viewTitle = @;

	if (argc == 1) {
		obsName = p1;
	} else if (argc == 2) {
		obsName = p1;
		viewTitle = p2;
	} else if (argc == 3) {
		viewName = p1;
		obsName = p2;
		viewTitle = p3;
		if (!isString(viewName)) {
			error("createCanvas: The first argument must be a string, not a " // type(viewName));
			return;
		}
	} else {
		error("createCanvas: This procedure requires at least 1 argument and at most 3 arguments.");
		return;
	}

	
	
	if (isPointer(obsName)) {
		obsName = nameof(obsName);
	} else if (!isString(obsName)) {
		error("createCanvas: The observable name must be expressed as a string or a pointer, not a " // type(obsName));
		return;
	}

	if (viewName == @) {
		viewName = obsName;
	}
	
	if (viewTitle != @ && !isString(viewTitle)) {
		error("createCanvas: The window title must be a string, not a " // type(viewTitle));
		return;
	}

	if (`{obsName}` == @) {
		`{obsName}` = [];
	}

	createView(viewName, "Canvas2D");
	execute("view_" // viewName // "_content is " // obsName // ";");
	if (viewTitle == @) {
		# don't attempt to make this update by dependency on redefinition of _view_viewName_content.
		# Severe performance problems result.
		viewTitle = "Canvas " // obsName;
	}
	`view_{viewName}_title` = viewTitle;
}

/**
* Returns a string that can be used as the src attribute for an <img> tag inside the content of a
* HTML view.  The image with the special URL returned by this function is a snapshot of the contents
* of the canvas at the time this function was called.
* Optional parameter can be used to select which canvas should be used to take the snapshot.
* 
* @param [canvasName]
* 
*/
func canvasURL {
	${{
		var canvasName;
		if (arguments.length > 1) {
			eden.error(new Error("canvasURL: This function requires at most one argument."), "error");
			return "";
		} else if (arguments.length == 0) {
			canvasName = "picture";
		} else {
			canvasName = arguments[0];
			if (canvasName === undefined) {
				return "";
			} else if (typeof(canvasName) == "string") {
				if (!(canvasName in canvases)) {
					return "";
				}
			} else {
				eden.error(new Error("canvasURL: The first argument must be a string, not a " + typeof(canvasName)), "error");
				return "";
			}
		}
		
		return canvases[canvasName].toDataURL();
	}}$;
}

/**
* Finds the topmost shape object at a given pair of canvas coordinates.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] Include in the search any shapes that do not have a mouse zone name set (N.B. the default is false!)
*/
func shapeOnTopAt {
	${{
		var target = arguments[0];
		var x, y, testAll;
		if (arguments.length < 2 || arguments.length > 4) {
			eden.error(new Error("shapeOnTopAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
			return undefined;
		}
		if (arguments[1] instanceof Point) {
			x = arguments[1].x;
			y = arguments[1].y;
			testAll = arguments[2];
		} else {
			x = arguments[1];
			y = arguments[2];
			testAll = arguments[3];
		}

		if (target === undefined || x === undefined || y === undefined) {
			return undefined;
		}
		if (target instanceof Symbol) {
			var match = target.name.match(/^\/_view_(.*)_content$/);
			if (match === null) {
				eden.error(new Error("shapeOnTopAt: The first argument must be either a string or a pointer to a _view_xxx_content observable, not " +
					Eden.edenCodeForValue(target)), "error");
				return undefined;
			} else {
				target = match[1];
			}
		} else if (typeof(target) != "string") {
			eden.error(new Error("shapeOnTopAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");		
			return undefined;
		}
		if (typeof(x) != "number") {
			eden.error(new Error("shapeOnTopAt: The x-coordinate must be a number, not a " + typeof(x)), "error");		
			return undefined;
		} else if (typeof(y) != "number") {
			eden.error(new Error("shapeOnTopAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
			return undefined;
		}
		return edenUI.plugins.Canvas2D.findDrawableHit(target, x, y, false, testAll);
	}}$;
}

/**
* Finds the bottommost shape object at a given pair of canvas coordinates.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] Include in the search any shapes that do not have a mouse zone name set (N.B. the default is false!)
*/
func shapeOnBottomAt {
	${{
		var target = arguments[0];
		var x, y, testAll;
		if (arguments.length < 2 || arguments.length > 4) {
			eden.error(new Error("shapeOnBottomAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
			return undefined;
		}
		if (arguments[1] instanceof Point) {
			x = arguments[1].x;
			y = arguments[1].y;
			testAll = arguments[2];
		} else {
			x = arguments[1];
			y = arguments[2];
			testAll = arguments[3];
		}

		if (target === undefined || x === undefined || y === undefined) {
			return undefined;
		}
		if (target instanceof Symbol) {
			var match = target.name.match(/^\/_view_(.*)_content$/);
			if (match === null) {
				eden.error(new Error("shapeOnBottomAt: The first argument must be either a string or a pointer to a _view_xxx_content observable, not " +
					Eden.edenCodeForValue(target)), "error");
				return undefined;
			} else {
				target = match[1];
			}
		} else if (typeof(target) != "string") {
			eden.error(new Error("shapeOnBottomAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");		
			return undefined;
		}
		if (typeof(x) != "number") {
			eden.error(new Error("shapeOnBottomAt: The x-coordinate must be a number, not a " + typeof(x)), "error");		
			return undefined;
		} else if (typeof(y) != "number") {
			eden.error(new Error("shapeOnBottomAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
			return undefined;
		}
		return edenUI.plugins.Canvas2D.findDrawableHit(target, x, y, true, testAll);
	}}$;
}

/**
* Finds the name of the mouse zone of the topmost shape at a given pair of canvas coordinates.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
*/
func zoneOnTopAt {
	auto drawable;
	drawable = apply(shapeOnTopAt, ${{ arguments }}$);
	if (drawable == @) {
		return @;
	} else {
		return drawable["name"];
	}
}

/**
* Finds the name of the mouse zone of the bottommost shape at a given pair of canvas coordinates.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
*/
func zoneOnBottomAt {
	auto drawable;
	drawable = apply(shapeOnBottomAt, ${{ arguments }}$);
	if (drawable == @) {
		return @;
	} else {
		return drawable["name"];
	}
}

/**
* Obtains the observable name associated with a given canvas shape (if there is one).
* @param shape
*/
func observableForShape {
	${{
		var drawable = arguments[0];
		if (drawable === undefined) {
			return undefined;
		} else if ("obsName" in drawable) {
			return drawable["obsName"];
		} else {
			return drawable["name"];
		}
	}}$;
}

/**
* Finds the observable name associated with the topmost shape at a given pair of canvas coordinates (if there is one).
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] Include in the search any shapes that do not have a mouse zone name set (N.B. the default is false!)
*/
func observableOnTopAt {
	auto drawable;
	drawable = apply(shapeOnTopAt, ${{ arguments }}$);
	return observableForShape(drawable);
}

/**
* Finds the observable name associated with the bottommost shape at a given pair of canvas coordinates (if there is one).
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] Include in the search any shapes that do not have a mouse zone name set (N.B. the default is false!)
*/
func observableOnBottomAt {
	auto drawable;
	drawable = apply(shapeOnBottomAt, ${{ arguments }}$);
	return observableForShape(drawable);
}

/**
* Finds all of the shape objects present at a given pair of canvas coordinates and returns them as a list.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] If false then only shapes which have a mouse zone name set are returned (N.B. the default is false!)
*/
func shapesAt {
	${{
		var target = arguments[0];
		var x, y, testAll;
		if (arguments.length < 2 || arguments.length > 4) {
			eden.error(new Error("shapesAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
			return undefined;
		}
		if (arguments[1] instanceof Point) {
			x = arguments[1].x;
			y = arguments[1].y;
			testAll = arguments[2];
		} else {
			x = arguments[1];
			y = arguments[2];
			testAll = arguments[3];
		}

		if (target === undefined || x === undefined || y === undefined) {
			return undefined;
		}
		if (target instanceof Symbol) {
			var match = target.name.match(/^\/_view_(.*)_content$/);
			if (match === null) {
				eden.error(new Error("shapesAt: The first argument must be either a string or a pointer to a _view_xxx_content observable, not " +
					Eden.edenCodeForValue(target)), "error");
				return undefined;
			} else {
				target = match[1];
			}
		} else if (typeof(target) != "string") {
			eden.error(new Error("shapesAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");		
			return undefined;
		}
		if (typeof(x) != "number") {
			eden.error(new Error("shapesAt: The x-coordinate must be a number, not a " + typeof(x)), "error");		
			return undefined;
		} else if (typeof(y) != "number") {
			eden.error(new Error("shapesAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
			return undefined;
		}
		return edenUI.plugins.Canvas2D.findAllDrawablesHit(target, x, y, testAll);
	}}$;
}

/**
* Finds all of the mouse zone names of the shapes intersecting at a given pair of canvas coordinates and returns them as a list.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
*/
func zonesAt {
	auto drawables, zones, i;
	drawables = apply(shapesAt, ${{ arguments }}$);
	zones = [];
	for (i = 1; i <= drawables#; i++) {
		append zones, drawables[i]["name"];
	}
	return zones;
}

/**
* Finds all of observable names associated with shapes intersecting at a given pair of canvas coordinates and returns them as a list.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] If false then only shapes which have a mouse zone name set are considered (N.B. the default is false!)
*/
func observablesAt {
	auto drawables, obsList, obsName, i;
	drawables = apply(shapesAt, ${{ arguments }}$);
	obsList = [];
	for (i = 1; i <= drawables#; i++) {
		obsName = observableForShape(drawables[i]);
		if (obsName != @) {
			append obsList, obsName;
		}
	}
	return obsList;
}

#! Creates an image element for display on the canvas together with the
# geometric shapes.  Taints the canvas if url is located on another domain.
#
# ##Usage Example
#   `Image(x, y, url);`
#	`Image(x, y, width, height, url);`
#
# ##Examples
# * [Scaling an Image](@external CanvasExamples > scaledimage)
# * [Using OpenClipart](@external CanvasExamples > openclipart)
# * [Rotating an Image](@external CanvasExamples > rotateimage)
# * [Keyframe Animation](@external CanvasExamples > keyframeimage)
# * [Sprites](@external CanvasExamples > sprites)
# * [Upload an Image](@external CanvasExamples > uploadimage)
#
#   @param [name]
#   @param x X-coordinate
#   @param y Y-coordinate
#   @param [width] Width in pixels
#   @param [height] Height in pixels
#   @param [clip_left]
#   @param [clip_top]
#   @param [clip_right]
#   @param [clip_bottom]
#   @param [smoothed]
#   @param url Source file for the image
#
#   #canvas #library #picture #photo #photograph #draw
func Image {
	${{
		var numArgs = arguments.length;
		var argsProcessed;
		var name;
		if (typeof(arguments[0]) == "string") {
			name = arguments[0];
			argsProcessed = 1;
		} else {
			argsProcessed = 0;
		}

		var dx = arguments[argsProcessed];
		argsProcessed++;
		var dy = arguments[argsProcessed];
		argsProcessed++;

		var dWidth, dHeight, sx1 = 0, sy1 = 0, sx2, sy2, smoothed = true, file;

		if (numArgs - 1 > argsProcessed) {
			dWidth = arguments[argsProcessed];
			argsProcessed++;
		}
		if (numArgs - 1 > argsProcessed) {
			dHeight = arguments[argsProcessed];
			argsProcessed++;
		}
		if (numArgs - 1 > argsProcessed) {
			sx1 = arguments[argsProcessed];
			argsProcessed++;
		}
		if (numArgs - 1 > argsProcessed) {
			sy1 = arguments[argsProcessed];
			argsProcessed++;
		}
		if (numArgs - 1 > argsProcessed) {
			sx2 = arguments[argsProcessed];
			argsProcessed++;
		}
		if (numArgs - 1 > argsProcessed) {
			sy2 = arguments[argsProcessed];
			argsProcessed++;
		}
		if (numArgs - 1 > argsProcessed) {
			smoothed = arguments[argsProcessed];
			argsProcessed++;
		}
		file = arguments[numArgs - 1];
		return new CanvasImage(name, dx, dy, dWidth, dHeight, sx1, sy1, sx2, sy2, smoothed, file);
	}}$;
}

#! Make a clickable checkbox on the canvas. Give it a name and then an observable `name_checked` is set to true of false.
#
# @param [name]
# @param label
# @param x x position
# @param y y position
# @param [tristate] If true, the checkbox will have three states; true, false, undefined. Defaults to false
# @param [enabled] Defaults to true.
#  #canvas #checkbox #tick #box #tickbox #check #form
func Checkbox {
${{
	var argsProcessed;

	var name;
	if (typeof(arguments[1]) == "string" || arguments[1] === undefined) {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("Checkbox: Every checkbox must have a name."), "error");
			return undefined;
		}
	}

	var label;
	if (typeof(arguments[argsProcessed]) == "string" || arguments[argsProcessed] === undefined) {
		label = arguments[argsProcessed];
		argsProcessed++;
	}

	var x = arguments[argsProcessed];
	var y = arguments[argsProcessed + 1];

	var tristate = arguments[argsProcessed + 2];
	if (tristate === undefined) tristate = false;

	var enabled = arguments[argsProcessed + 3];
	if (enabled === undefined) enabled = true;

	return new Checkbox(name, label, x, y, tristate, enabled);
}}$; }

#! Creates a circle. See [drawing options](@external CanvasExamples > drawingoptions) for more styling options.
#
# ##Usage Example
#  `Circle(x, y, radius, "purple");`
#  `Circle(x, y, radius, "green", "red");`
# 
# @param x x position of center of the circle
# @param y y position of center of the circle
# @param radius radius of the circle
# @param [fillColour]
# @param [outlineColour] defaults to black
# @param [drawingOptions] object of drawingOptions
# 
#  #canvas #circle #shape #draw #library
func Circle {
${{
	var x = arguments[0];
	var y = arguments[1];
	var radius = arguments[2];
	var fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 3) {
		fillcolour = arguments[3];
		if (processUpTo == 4) {
			outlinecolour = arguments[4];
		}
	}
	if (fillcolour === undefined && outlinecolour === undefined) {
		outlinecolour = "black";
	}
	return new Circle(x, y, radius, fillcolour, outlinecolour, drawingOptions);
}}$; };

/**
 * Creates a Combobox (drop down selection)
 * @param [name] defaults to the observable name
 * @param suggestions list of strings to be suggested
 * @param x
 * @param y
 * @param [width]
 * @param [placeholder] string to display before choice is made. Defaults to observable name.
 * @param [maxlength] Maximum length allowed in input
 * @param [enabled] defaults to true.
 * 
 * #canvas #combobox #input #select
 */

func Combobox { ${{
	var argsProcessed;

	var name;
	if (typeof(arguments[0]) == "string") {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("Combobox: Every combobox must have a name."), "error");
			return undefined;
		}
	}

	var suggestions = arguments[argsProcessed];
	argsProcessed++;
	var x = arguments[argsProcessed];
	argsProcessed++;
	var y = arguments[argsProcessed];
	argsProcessed++;
	var width, placeholder, maxlength;

	var arg = arguments[argsProcessed];
	var argType = typeof(arg);
	if (arg === undefined || argType == "number") {
		width = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}
	if (arg === undefined || argType == "string") {
		placeholder = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}
	if (arg === undefined || argType == "number") {
		maxlength = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
	}
	var enabled = arg;

	return new Combobox(name, suggestions, x, y, width, placeholder, maxlength, enabled);
}}$; }


/**
 * Creates a EuclideanSpace object
 * @param xMin
 * @param yMin
 * @param [zMin]
 * @param xMax
 * @param yMax
 * @param [zMax]
 * #euclideanspace #contour
 */
func EuclideanSpace {
	${{
		var xMin, yMin, zMin, xMax, yMax, zMax;
		if (arguments.length > 4) {
			xMin = arguments[0];
			yMin = arguments[1];
			zMin = arguments[2];
			xMax = arguments[3];
			yMax = arguments[4];
			zMax = arguments[5];
		} else {
			xMin = arguments[0];
			yMin = arguments[1];
			xMax = arguments[2];
			yMax = arguments[3];
		}
		return new EuclideanSpace(xMin, yMin, zMin, xMax, yMax, zMax);
	}}$;
}

/**
 * 
 * Creates object to hold Scalar Field values
 * For more details, please see: 
 * <a target="_blank" href="http://jseden.dcs.warwick.ac.uk/latest-master/index-dev.html?import=plugins/canvas/contourLine/guide">Contour Line Guide</a>
 * @param dataPtr
 * @param space
 * @param numX
 * @param numY
 * @param [tmin
 * @param [tmax]]
 * #scalarfield #contour
 */

func ScalarField2D {
	${{
		var dataPtr = arguments[0];
		var space = arguments[1];
		var numX = arguments[2];
		var numY = arguments[3];

		var tMin, tMax, numT, existsBefore, existsAfter;
		var numArgs = arguments.length;
		var argsProcessed;

		if (numArgs > 5) {
			tMin = arguments[4];
			tMax = arguments[5];
			argsProcessed = 6;
			if (numArgs == 9 || typeof(arguments[argsProcessed]) == "number") {
				numT = arguments[6];
				argsProcessed++;
			} else if (tMin === undefined || tMax === undefined || tMin === tMax) {
				numT = 1;
			} else {
				numT = 2;
			}
			existsBefore = numArgs > argsProcessed? arguments[argsProcessed] : tMin === undefined;
			argsProcessed++;
			existsAfter = numArgs > argsProcessed? arguments[argsProcessed] : tMax === undefined;
		} else if (numArgs > 4) {
			tMin = arguments[4];
			tMax = tMin;
			numT = 1;
			existsBefore = true;
			existsAfter = true;
		}

		var dataSource = dataPtr instanceof Symbol? dataPtr.value() : undefined;

		if (Array.isArray(dataSource)) {
			return new Explicit2DScalarField(dataPtr, space, numX, numY, tMin, tMax, numT, existsBefore, existsAfter);
		} else if (tMin === undefined || tMax === undefined || tMin === tMax || numT === 1) {
			return new Static2DScalarField(dataPtr, space, numX, numY, tMin, tMax, numT, existsBefore, existsAfter);
		} else {
			return new KeyFrame2DScalarField(dataPtr, space, numX, numY, tMin, tMax, numT, existsBefore, existsAfter);
		}
	}}$;
}

/**
 * 
 * Applies a threshold and traces the outline of a shape.
 * For more details, please see: 
 * <a target="_blank" href="http://jseden.dcs.warwick.ac.uk/latest-master/index-dev.html?import=plugins/canvas/contourLine/guide">Contour Line Guide</a>
 * @param scalar_field_2d ScalarField object providing the function values
 * @param [iso_value The threshold value that determines which function values fall inside the boundary of the shape
 * @param [time_value]] The time instant at which to evaluate the function.  May be omitted if the function is time invariant.
 *
 * #contour
 */

func ContourData {
	${{
		var field = arguments[0];
		var isoValue = arguments[1];
		if (isoValue === undefined) {
			isoValue = 0;
		}
		var t = arguments[2];
		return new ContourData(field, isoValue, t);
	}}$;
}

/**
 * Creates a contoured shape object with size, position, colour, etc. from the mathematical description (ContourData).
 * For more details, please see: 
 * <a target="_blank" href="http://jseden.dcs.warwick.ac.uk/latest-master/index-dev.html?import=plugins/canvas/contourLine/guide">Contour Line Guide</a>
 * 
 * @param x
 * @param y
 * @param width
 * @param height
 * @param contour_data A contourData object
 * @param [fill_colour
 * @param [outline_colour]]
 * @param [drawing_options] A drawingOptions object
 * 
 * #canvas #contour #line #drawingOptions
 * 
 */
func ContourLine {
	${{
		var x = arguments[0];
		var y = arguments[1];
		var width = arguments[2];
		var height = arguments[3];
		var line = arguments[4];

		var fillcolour, outlinecolour, drawingOptions;
		var lastArg = arguments[arguments.length - 1];
		var processUpTo;
		if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
			drawingOptions = lastArg;
			processUpTo = arguments.length - 2;
		} else {
			processUpTo = arguments.length - 1;
		}
		if (processUpTo >= 5) {
			fillcolour = arguments[5];
			if (processUpTo == 6) {
				outlinecolour = arguments[6];
			}
		}
		if (fillcolour === undefined && outlinecolour === undefined) {
			outlinecolour = "black";
		}
		return new ContourLine(x, y, width, height, line, fillcolour, outlinecolour, drawingOptions);
	}}$;
}

func Curve {
	${{
		var x1 = arguments[0];
		var y1 = arguments[1];
		var x2 = arguments[2];
		var y2 = arguments[3];
		var r = arguments[4];
		var elasticity = arguments[5];

		var direction, theta1, theta2, mid = 0.5, overshoot = 150, direction, colours, drawingOptions;
		var lastArg = arguments[arguments.length - 1];
		var processUpTo;
		if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg)) {
			drawingOptions = lastArg;
			processUpTo = arguments.length - 2;
			lastArg = arguments[processUpTo];
		} else {
			processUpTo = arguments.length - 1;
		}
		if (typeof(lastArg) == "string") {
			colours = [lastArg];
			processUpTo--;
		} else if (Array.isArray(lastArg)) {
			colours = lastArg;
			processUpTo--;
		} else {
			colours = ["black"];
		}
		lastArg = arguments[processUpTo];
		if (typeof(lastArg) == "boolean") {
			direction = lastArg;
			processUpTo--;
		}
		if (processUpTo > 5) {
			theta1 = arguments[6];
			if (processUpTo > 6) {
				theta2 = arguments[7];
				if (processUpTo > 7) {
					mid = arguments[8];
					if (processUpTo > 8) {
						overshoot = arguments[9];
					}
				}
			} else {
				theta2 = theta1;
			}
		}
		return new Curve(x1, y1, x2, y2, r, elasticity, theta1, theta2, mid, overshoot, direction, colours, drawingOptions);
	}}$;
}
semicircleAngle ~> [Curve];

/**
 * Create a Div tag to display HTML
 * 
 * @param html
 * @param x X-coordinate
 * @param y Y-coordinate
 * @param [width Width in pixels or as a string or undefined
 * @param [height]] Height in pixels or as a string or undefined
 * @param [id]
 * @param [css_class_list]
 * @param [style] An optional CSS style string
 * #canvas #div #html #css
 */

func Div { ${{
	var html = arguments[0];
	var x = arguments[1];
	var y = arguments[2];
	var width, height;   //Number of pixels, string (e.g. "50%") or undefined (automatic)
	var id, classNames;
	var style = "";
	
	var argsProcessed = 3;
	var argType = typeof(arguments[3]);
	
	if (argType == "number" || argType == "undefined") {
		width = arguments[3];
		argsProcessed++;
		
		argType = typeof(arguments[4]);
		if (argType == "number" || argType == "undefined") {
			height = arguments[4];
			argsProcessed++;
		}
	}

	if (arguments.length > argsProcessed) {
		if (arguments.length == argsProcessed + 3) {
			id = arguments[argsProcessed];
			classNames = arguments[argsProcessed + 1];
			style = arguments[argsProcessed + 2];
		} else {
			if (Array.isArray(arguments[argsProcessed])) {
				classNames = arguments[argsProcessed];
				if (arguments.length == argsProcessed + 2) {
					style = arguments[argsProcessed + 1];
				}
			} else if (arguments.length == argsProcessed + 2) {
				id = arguments[argsProcessed];
				if (Array.isArray(arguments[argsProcessed + 1])) {
					classNames = arguments[argsProcessed + 1];
				} else {
					style = arguments[argsProcessed + 1];
				}
			} else {
				argType = typeof(arguments[argsProcessed]);
				if ((argType == "string" && arguments[argsProcessed].indexOf(":") !== -1) ||
					argType == "object") {
					style = arguments[argsProcessed];
				} else {
					id = arguments[argsProcessed];
				}
			}
		}
	}	
	return new Div(html, x, y, width, height, id, classNames, style);
}}$; }


/**
 * Creates a DropDown list, allowing for the selection
 * @param [name] Prefix for _value observable. Default is the name of the observable being defined.
 * @param values A list of options
 * @param [labels] A list of labels to display, if not supplied, the list of values will be used
 * @param x X-coordinate
 * @param y Y-coordinate
 * @param [enabled] Boolean to determine if list selection is enabled
 * #canvas #dropdown #input #select
 */
func DropDownList { ${{
	var argsProcesed;

	var name;
	if (typeof(arguments[0]) == "string") {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("DropDownList: Every DropDownList must have a name."), "error");
			return undefined;
		}
	}

	var values = arguments[argsProcessed];
	argsProcessed++;
	var labels;
	if (Array.isArray(arguments[argsProcessed])) {
		labels = arguments[argsProcessed];
		argsProcessed++;
	} else {
		labels = values;
	}
	var x = arguments[argsProcessed];
	argsProcessed++;
	var y = arguments[argsProcessed];
	argsProcessed++;
	var enabled = arguments[argsProcessed];

	return new DropDownList(name, values, labels, x, y, enabled);
}}$; }

/**
 * Create an Ellipse
 * 
 * @param x Centre X-coordinate
 * @param y Centre Y-coordinate
 * @param x_radius Ellipse x-axis radius from centre
 * @param y_radius Ellipse y-axis radius from centre
 * @param [fill_colour Fill colour for the ellipse on the canvas
 * @param [outline_colour]] Outline colour of the ellipse on the canvas
 * @param [drawing_options] A drawingOptions object
 * 
 * #canvas #ellipse #drawingOptions
 */

func Ellipse { ${{
	var x = arguments[0];
	var y = arguments[1];
	var xradius = arguments[2];
	var yradius = arguments[3];
	var fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 4) {
		fillcolour = arguments[4];
		if (processUpTo == 5) {
			outlinecolour = arguments[5];
		}
	}

	if (fillcolour === undefined && outlinecolour === undefined) {
		outlinecolour = "black";
	}
	return new Ellipse(x, y, xradius, yradius, fillcolour, outlinecolour, drawingOptions);
}}$; };

/**
 * Create FillPattern object based on an image
 * @param url URL of the image
 */

func FillPattern {
	${{
		return new FillPattern(arguments[0]);
	}}$;
}



/**
 * The FlowLayout function has a picture list parameter and itself appears in the picture list.
 * Items within its local picture list behave differently to other items. Their positions are
 * determined automatically!
 * FlowLayout works in the same way that words are conventionally set out in paragraphs. FlowLayout is
 * the paragraph and its items are the words. The items are placed one after another, left to right,
 * wrapping onto another line if necessary.
 * At present only HTML items are supported (so use Div instead of Text, HTMLImage instead of Image).
 *
 * @param x x-position
 * @param y y-position
 * @param [width]
 * @param items List of items to be displayed
 * @param [drawingOptions] List of drawing options
 *
 * #flowlayout #canvas #picture #drawingoptions
 */
func FlowLayout {
${{
	var x = arguments[0];
	var y = arguments[1];
	var width, content, drawingOptions;

	var argsProcessed = 2;
	var arg = arguments[2];

	if (Array.isArray(arg)) {
		content = arg;
		argsProcessed++;
	} else {
		width = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		content = arg;
		argsProcessed++;
	}

	arg = arguments[argsProcessed];

	if (typeof(arg) == "object") {
		drawingOptions = arg;
	}

	return new FlowLayout(x, y, width, content, drawingOptions);
}}$;
}

## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

/** Returns a GreyPixelList drawable.  The ptrToData argument should be a pointer to a list of
 * integers.  The first element represents the grey shade of the top-left pixel (0-255) and the
 * subsequent elements represent successive pixels, first along the top row going from left to right
 * and then along the second row, etc.  The data list should contain data for an exact number of rows
 * of the specified width.  The image can be tinted in a particular colour using the optional
 * redMultiply, greenMultiply, blueMultiply, redAdd, greenAdd and blueAdd parameters.
 * redOfResultingPixel = redMultiply * grayscaleValue + redAdd
 * greenOfResultingPixel = greenMultiply * grayscaleValue + redAdd
 * blueOfResultingPixel = blueMultiply * grayscaleValue + blueAdd
 *
 * The resulting red, green and blue values from the above calculations are clipped so that the final
 * values rendered all lie within the range 0 to 255.  This can be used to create effects, for
 * example, multipliers greater than 1 increase the contrast of the image.  Usage of the undefined
 * value in the list of grayscale values causes the relevant pixel to be white and uneffected by the
 * tinting process.
 *
 * The multipliers all default to 1 and the additions all default to adding nothing, i.e. a pure
 * grayscale image is created without a tint.
 * 
 * Example:
 * ````
 * func greyMap {
 *		auto data, i, j, v;
 *		data = [];
 *		for (j = 0; j <= 255; j++) {
 *			for (i = 0; i <= 255; i++) {
 *					v = sqrt((i - 128) * (i - 128) + (j - 128) * (j - 128));
 *					if (v > 115) {
 *						append data, @;
 *					} else {
 *						append data, ((i - 128) * (i - 128) + (j - 128) * (j - 128)) % 256;
 *					}
 *			}
 *		}
		return data;
 *	}
 *	pixelData is greyMap();
 *	pixels is GreyPixelList(&pixelData, mousePosition.x - 128, mousePosition.y - 128, 256);
 *	picture is [pixels];
 *  ````
 *  @param [name]
 *  @param ptrToData Pointer to the pixel data
 *  @param x x-position
 *  @param y y-position
 *  @param width
 *  @param [redMultiply]
 *  @param [blueMultiply]
 *  @param [greenMultiply]
 *  @param [redAdd]
 *  @param [blueAdd]
 *  @param [greenAdd]
 *  @return GreyPixelList drawable
 */

func GreyPixelList {
	${{
		var name;
		var argsProcessed;
		if (typeof(arguments[0]) == "string") {
			name = arguments[0];
			argsProcessed = 1;
		} else {
			argsProcessed = 0;
		}
		var ptrToData = arguments[argsProcessed];
		argsProcessed++;
		var x = arguments[argsProcessed];
		argsProcessed++;
		var y = arguments[argsProcessed];
		argsProcessed++;
		var width = arguments[argsProcessed];
		argsProcessed++;
		var redMultiply = arguments[argsProcessed];
		if (redMultiply === undefined) redMultiply = 1;
		argsProcessed++;
		var greenMultiply = arguments[argsProcessed];
		if (greenMultiply === undefined) greenMultiply = 1;
		argsProcessed++;
		var blueMultiply = arguments[argsProcessed];
		if (blueMultiply === undefined) blueMultiply = 1;
		argsProcessed++;
		var redAdd = arguments[argsProcessed];
		if (redAdd === undefined) redAdd = 0;
		argsProcessed++;
		var greenAdd = arguments[argsProcessed];
		if (greenAdd === undefined) greenAdd = 0;
		argsProcessed++;
		var blueAdd = arguments[argsProcessed];
		if (blueAdd === undefined) blueAdd = 0;
		argsProcessed++;
		return new GreyPixelList(name, ptrToData, x, y, width, redMultiply, greenMultiply, blueMultiply, redAdd, greenAdd, blueAdd);
	}}$;
}


/**
 * Create drawable image for a canvas
 * 
 * @param name Name for click events
 * @param x X-coordinate
 * @param y Y-coordinate
 * @param [width Width in virtual pixel units
 * @param [height] Height in virtual pixel units
 * @param [sizeIsPercentage] Whether width and height are in pixel or percentage units
 * @param [at_scale]] The value of _view_xxx_scale needed to make 1 virtual pixel equal 1 real pixel
 * @param url Source file for the image
 * @param [zones] List of two element lists. The first element of each is the name of an image area. The second is a Circle, Rectangle or Polygon object.
 * 
 * #canvas #image #htmlimage
 */
func HTMLImage { ${{
	var numArgs = arguments.length;
	var argsProcessedFirst, arg, argType;
	
	var name;
	if (typeof(arguments[0]) == "string") {
		name = arguments[0];
		argsProcessedFirst = 1;
	} else {
		argsProcessedFirst = 0;
	}

	var x = arguments[argsProcessedFirst];
	argsProcessedFirst++;
	var y = arguments[argsProcessedFirst];
	argsProcessedFirst++;

	var width, height, asPercent, url, imageMap;
	var scaleFactor = 1;
	var argsLeft = numArgs - argsProcessedFirst;

	if (numArgs == 9 || Array.isArray(arguments[numArgs - 1])) {
		imageMap = arguments[numArgs - 1];
		url = arguments[numArgs - 2];
		argsLeft = argsLeft - 2;
	} else {
		url = arguments[numArgs - 1];
		argsLeft--;
	}


	if (argsLeft > 0) {
		arg = arguments[argsProcessedFirst];
		argType = typeof(arg);
		if (argType == "number" || arg === undefined) {
			width = arg;
			argsProcessedFirst++;
			argsLeft--;
			arg = arguments[argsProcessedFirst];
			argType = typeof(arg);
		}
	}
	if (argsLeft > 0 && (argType == "number" || arg === undefined)) {
		height = arg;
		argsProcessedFirst++;
		argsLeft--;
		arg = arguments[argsProcessedFirst];
		argType = typeof(arg);
	}
	if (argsLeft > 0 && (argType == "boolean" || arg === undefined)) {
		asPercent = arg;
		argsProcessedFirst++;
		argsLeft--;
		arg = arguments[argsProcessedFirst];
		argType = typeof(arg);
	}
	if (argsLeft > 0 && argType == "number") {
		scaleFactor = arg;
	}

	return new HTMLImage(name, x, y, width, height, asPercent, scaleFactor, url, imageMap);
}}$; }

func imageWithZones {
	para p1, p2, p3, p4;
	auto name, width, height, url, imageMap, testing, items, argsProcessed;
	auto i, shape, zoneName, centre;
	items = [];
	if (isString(p2)) {
		name = p1;
		url = p2;
		argsProcessed = 2;
	} else if (isList(p2)) {
		url = p1;
		argsProcessed = 1;
	} else if (isString(p1)) {
		name = p1;
		width = p2;
		height = p3;
		url = p4;
		argsProcessed = 4;
	} else {
		width = p1;
		height = p2;
		url = p3;
		argsProcessed = 3;
	}
	imageMap = ${{arguments[argsProcessed]}}$;
	testing = ${{arguments[argsProcessed + 1]}}$;

	if (testing) {
		append items, Image(name, 0, 0, width, height, url);
		for (i = 1; i <= imageMap#; i++) {
			shape = imageMap[i];
			append items, shape;
			zoneName = shape["drawingOptions"] == @ if @ else shape["drawingOptions"]["name"];
			if (zoneName != @) {
				centre = shape["centre"]();
				append items, Div(zoneName, centre["x"] - 5.5 * zoneName#, centre["y"] - 15, @, @, "color: white; background-color: black; font-size: 20px; font-family: monospace");
			}
		}
	} else {
		append items, HTMLImage(name, 0, 0, width, height, url, imageMap);
	}
	return items;
}

#! Create a drawable line for display on the canvas. See [drawing options](@external CanvasExamples > drawingoptions) for more styling options.
#
# ##Usage Example
#  `Line(startx, starty, endx, endy, "green");`
#  `Line(x1,y1,x2,y2,"red",Object("lineWidth", 10));`
#
# @param x1 Start x-position
# @param y1 Start y-position
# @param x2 End x-position
# @param y2 End y-position
# @param [colour(s)] A HTML colour value for the whole line or a list of HTML colour values to create a gradient
# @param [drawing_options] list of drawing options
# 
#  #canvas #line #drawingoptions #draw
func Line {
${{
	var x1 = arguments[0];
	var y1 = arguments[1];
	var x2 = arguments[2];
	var y2 = arguments[3];
	var colours, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 4) {
		colours = arguments[4];
	}

	if (colours === undefined) {
		colours = ["black"];
	} else if (!Array.isArray(colours)) {
		colours = [colours];
	} else if (colours.length == 0) {
		colours = ["black"];
	}
	return new Line(x1, y1, x2, y2, colours, drawingOptions);
}}$; };


func distanceMoved {
	${{
		var from, to;
		if (arguments.length == 1) {
			if (arguments[0] instanceof Line) {
				var line = arguments[0];
				from = new Point(line.x1, line.y1);
				to = new Point(line.x2, line.y2);
			} else {
				to = arguments[0];
				from = new Point(0, 0);
			}
		} else if (arguments.length == 2) {
			from = arguments[0];
			to = arguments[1];
			if (from === undefined) {
				return undefined;
			} else if (!(from instanceof Point)) {
				eden.error(new Error("distanceMoved: The first argument must be a Point, not a " + typeof(from)), "error");
				return undefined;
			}
		} else {
			eden.error(new Error("distanceMoved: This function requires at least 1 argument and at most 2 arguments"), "error");
			return undefined;
		}
		if (to === undefined) {
			return undefined;
		} else if (!(to instanceof Point)) {
			eden.error(new Error("distanceMoved: The destination point must be a Point or a Line, not a " + typeof(to)), "error");
			return undefined;
		}
		if (from.x == undefined || from.y == undefined || to.x == undefined || to.y == undefined) {
			return undefined;
		}
		var xDist = to.x - from.x;
		var yDist = to.y - from.y;
		return Math.sqrt(xDist * xDist + yDist * yDist);
	}}$;
}

func angleTurned {
	${{
		var from, to;
		if (arguments[0] instanceof Folder) {
			//Probably not an actual function call but semicircleAngle observable changed.
			return undefined;
		} else if (arguments.length == 1) {
			to = arguments[0];
			from = new Point(0, 0);
		} else if (arguments.length == 2) {
			from = arguments[0];
			to = arguments[1];
			if (from === undefined) {
				return undefined;
			} else if (!(from instanceof Point)) {
				eden.error(new Error("angleTurned: The first argument must be a Point, not a " + typeof(from)), "error");
				return undefined;
			}
		} else {
			eden.error(new Error("angleTurned: This function requires at at least 1 argument and most 2 arguments"), "error");
			return undefined;
		}
		if (to === undefined) {
			return undefined;
		} else if (!(to instanceof Point)) {
			eden.error(new Error("angleTurned: The destination point must be a Point, not a " + typeof(to)), "error");
			return undefined;
		}
		if (from.x == undefined || from.y == undefined || to.x == undefined || to.y == undefined) {
			return undefined;
		}
		var relativeX = to.x - from.x;
		var relativeY = to.y - from.y;
		return Math.atan2(relativeY, relativeX) * root.lookup("semicircleAngle").value() / Math.PI;
	}}$;
}
semicircleAngle ~> [angleTurned];

## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

##Example:
/**
 * Creates a LinearGradient that can be used to colour shapes
 * @param x1 X-coordinate for start
 * @param y1 Y-coordinate for start
 * @param x2 X-coordinate for end
 * @param y2 Y-coordinate for end
 * @param [start_colour Start Colour
 * @param end_colour] End Colour
 * @param [extra_colour_stops] A list of two item lists.  The first element of each is a point along the gradient (0.0-1.0).  The second is the colour.
 * 
 * Usage example: 
 * 
 * ```
 * 	x = 50;
 * 	y = 50;
 * 	width = 400;
 * 	height = 250;
 * 	gradient is LinearGradient(x, y, x + width, y + height, "cyan", "blue");
 * 	rect is Rectangle(x, y, width, height, gradient);
 * 	picture is [rect];
 * ```
 * #canvas #colour #gradient #lineargradient
*/

func LinearGradient {
	${{
		var x1 = arguments[0];
		var y1 = arguments[1];
		var x2 = arguments[2];
		var y2 = arguments[3];
		var colourStops;
		if (Array.isArray(arguments[4])) {
			colourStops = arguments[4];
		} else {
			if (Array.isArray(arguments[6])) {
				colourStops = arguments[6];
			} else {
				colourStops = [];
			}
			
			var start_colour = arguments[4];
			if (typeof(start_colour) != "string") {
				start_colour = "black";
			}
			
			var end_colour = arguments[5];
			if (typeof(end_colour) != "string") {
				end_colour = "white";
			}
			
			colourStops.push([0, start_colour]);
			colourStops.push([1, end_colour]);
		}
		return new LinearGradient(x1, y1, x2, y2, colourStops);
	}}$;
}

#! Creates a sequence of joined lines for display on the canvas from a list of Points. This produces a better visual result than just using normal lines. See [drawing options](@external CanvasExamples > drawingoptions) for more style options.
# 
# ##Usage Example
#  `LineSequence(pointslist, "blue");`
#  `LineSequence([Point(ax,ay),Point(bx,by),Point(cx,cy)]);`
#
# @param points List of coordinates in the form Point(x, y) from the top left corner of the canvas
# @param [colour(s)] Colour of the line as a HTML colour value, or a list of such colour values
# @param [drawing_options] List of drawingOptions
# 
#  #canvas #line #linesequence #drawingoptions #draw
func LineSequence {
${{
	var vertices = arguments[0];
	var colours, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo == 1) {
		colours = arguments[1];
	}

	if (colours === undefined) {
		colours = ["black"];
	} else if (!Array.isArray(colours)) {
		colours = [colours];
	} else if (colours.length == 0) {
		colours = ["black"];
	}

	return new LineSequence(vertices, colours, drawingOptions);
}}$; };

/*
 * Creates a pixel that can be displayed on a canvas
 * 
 * @param x x-position
 * @param y y-position
 * @param colour colour
 * 
 */
func Pixel { ${{
  var x = arguments[0];
  var y = arguments[1];
  var colour = arguments[2];
  return new Pixel(x, y, colour);
}}$; };

## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

/*
 * Returns a PixelList drawable.  The ptrToData argument should be a pointer to a list of
 * integers.  The first four elements of the list represent the red, green, blue and
 * alpha components of the first pixel respectively (all in the range 0-255).  The
 * next four elements represent the second pixel, going from left to right along the
 * top line of the block.  The data list should contain data for an exact number
 * of rows of the specified width.  Although cumbersome a PixelList performs far
 * faster than trying to map each pixel to an individual EDEN observable for a
 * block of any significant size.
 * 
 * N.B. Unfortunately the alpha values are not true transparency.  That is, you
 * you can't see through to other objects drawn underneath on the canvas.  Alpha
 * values less than 255 just make the colours lighter.
 * 
 * Example:
 * ```
 * 	func colourMap {
 * 		para b;
 * 		auto data, i, j;
 * 		data = [];
 * 		for (j = 0; j <= 255; j++) {
 * 			for (i = 0; i <= 255; i++) {
 * 			append data, i;
 * 			append data, j;
 * 			append data, b;
 * 			append data, 255;
 * 		}
 * 		}
 * 	return data;
 *  }
 *  
 *  blue = 50;
 *  pixelData is colourMap(blue);
 *  pixels is PixelList(&pixelData, 20, 20, 256);
 *  picture is [pixels];
 *  
 *  @param [name]
 *  @param ptrToData pointer to list of R,G,B,Alpha values
 *  @param x x-position
 *  @param y y-position
 *  @param width
 *  
 * #canvas #pixellist
 */


func PixelList {
	${{
		var name;
		var argsProcessed;
		if (typeof(arguments[0]) == "string") {
			name = arguments[0];
			argsProcessed = 1;
		} else {
			argsProcessed = 0;
		}
		var ptrToData = arguments[argsProcessed];
		argsProcessed++;
		var x = arguments[argsProcessed];
		argsProcessed++;
		var y = arguments[argsProcessed];
		argsProcessed++;
		var width = arguments[argsProcessed];
		argsProcessed++;
		return new PixelList(name, ptrToData, x, y, width);
	}}$;
}

#! Creates a Polygon object for display on a canvas. You give a list of points and it will draw lines between them and then, optionally, fill the area inside. It will automatically join the last point to the first to close the shape. See [drawing options](@external CanvasExamples > drawingoptions) for more style options.
#
# ##Usage Example
#   `Polygon(pointslist, "green", "black");`
#	`Polygon([Point(10,10),Point(20,20),Point(10,20)]);`
#
# @param points List of coordinates in the form {x, y} from the top left corner of the canvas
# @param [fill_colour Colour of the polygon (fill) in HTML form
# @param [outline_colour]]
# @param [drawing_options] List of drawing options
# 
#  #canvas #polygon #drawingoptions #shape #area #triangle #octagon #hexagon #pentagon #poly #draw
func Polygon {
${{
	var vertices = arguments[0];
	if (vertices[0].x != vertices[vertices.length - 1].x || vertices[0].y != vertices[vertices.length - 1].y) {
		vertices.push(vertices[0]);
	}

	var fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 1) {
		fillcolour = arguments[1];
		if (processUpTo == 2) {
			outlinecolour = arguments[2];
		}
	}

	if (outlinecolour === undefined) {
		if (fillcolour === undefined) {
			outlinecolour = "black";
		}
	}

	return new Polygon(vertices, fillcolour, outlinecolour, drawingOptions);
}}$; };

##Example:

/*
 * Creates a radial gradient that can be used to colour shapes
 * 
 * @param x
 * @param y
 * @param [r radius
 * @param [colourStops]] List of colourStops
 * 
 * ```
 * g is RadialGradient(300, 240, 230, [[0, "red"], [0.5, "orange"], [1, "cyan"]]);
 * c is Circle(300,240,230,g);
 * picture is [c];
 * ```
 */
	
func RadialGradient {
	${{
		var x1, y1, r1, x2, y2, r2, colourStops;
		x1 = arguments[0];
		y1 = arguments[1];
		
		switch (arguments.length) {
			case 4:
				r1 = 0;
				x2 = x1;
				y2 = y1;
				r2 = arguments[2];
				colourStops = arguments[3];
				break;
		}
		return new RadialGradient(x1, y1, r1, x2, y2, r2, colourStops);
	}}$;
}


/**
 * Generates a set of radio buttons
 * 
 * @param [name] Prefix for _value observable.  Default is the name of the observable being defined.
 * @param values A list of strings providing the options
 * @param [labels]
 * @param x X-coordinate
 * @param y Y-coordinate
 * @param [width] Width in pixels
 * @param [is_horizontal
 * @param [enabled]] Boolean to determine if the radio buttons are enabled
 */
func RadioButtons { ${{
	var argsProcessed;

	var name;
	if (typeof(arguments[0]) == "string") {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("RadioButtons: Every group of radio buttons must have a name."), "error");
			return undefined;
		}
	}

	var values = arguments[argsProcessed];
	argsProcessed++;
	var labels;
	if (Array.isArray(arguments[argsProcessed])) {
		labels = arguments[argsProcessed];
		argsProcessed++;
	} else {
		labels = values;
	}
	var x = arguments[argsProcessed];
	argsProcessed++;
	var y = arguments[argsProcessed];
	argsProcessed++;
	var width;
	if (typeof(arguments[argsProcessed]) ==  "number" || arguments.length - argsProcessed > 2) {
		width = arguments[argsProcessed];
		argsProcessed++;
	}
	var horizontal = arguments[argsProcessed];
	argsProcessed++;
	var enabled = arguments[argsProcessed];

	return new RadioButtons(name, values, labels, x, y, width, horizontal, enabled);
}}$; }

#! Creates a rectangle that can be coloured and displayed on a canvas. See [drawing options](@external CanvasExamples > drawingoptions) for more style options.
#
# ##Usage Example
#  `Rectangle(x,y,width,height);`
#  `Rectangle(x,y,w,h, "green", "black", Object("lineWidth", 5));`
#
# @param x X-coordinate for top left
# @param y Y-coordinate for top left
# @param width
# @param height
# @param [fill_colour
# @param [outline_colour]] Colour of the rectangle outline in HTML form
# @param [drawing_options] List of drawing options
# 
#  #canvas #rectangle #drawingoptions #square #box #shape #draw
func Rectangle {
${{
	var x = arguments[0];
	var y = arguments[1];
	var width = arguments[2];
	var height = arguments[3];
	var fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 4) {
		fillcolour = arguments[4];
		if (processUpTo == 5) {
			outlinecolour = arguments[5];
		}
	}
	if (fillcolour === undefined && outlinecolour === undefined) {
		outlinecolour = "black";
	}
	return new Rectangle(x, y, width, height, fillcolour, outlinecolour, drawingOptions);
}}$; };

/**
 * Creates a polygon for display on a canvas
 * 
 * centre_x
 * centre_y
 * radius
 * n_sides Number of sides
 * [star_factor] Produces simple polygon if 1, if 2 it connects every other vertex, if 3 it connects every third vertex, etc.
 * [is_interior_outlined] true or false to draw internal lines in polygon (only has effect if fill colour is set).
 * [rotation] Rotation in degrees
 * [fill_colour Colour to fill the interior of the polygon with
 * [outline_colour]] Colour of the outline
 * [drawing_options] List of drawing options
 * 			
 * 
 * #canvas #drawingOptions #regularPolygon #polygon #drawingOptions
 */

func RegularPolygon {
	${{
		var maxArgs = 10;
		var numArgs = arguments.length;
		var x = arguments[0];
		var y = arguments[1];
		var r = arguments[2];
		var n = arguments[3];
		var star, rotation, interiorOutline;
		var fillcolour, outlinecolour, drawingOptions;
		var argsProcessed = 4;
		if (typeof(arguments[4]) == "number") {
			star = arguments[4];
			argsProcessed++;
		}
		if (numArgs - argsProcessed > maxArgs - 5) { argsProcessed = 5; }

		if (typeof(arguments[argsProcessed]) == "boolean") {
			interiorOutline = arguments[argsProcessed];
			argsProcessed++;
		}
		if (numArgs - argsProcessed > maxArgs - 6) { argsProcessed = 6; }

		if (typeof(arguments[argsProcessed]) == "number") {
				rotation = arguments[argsProcessed];
				argsProcessed++;
		}
		if (numArgs - argsProcessed > maxArgs - 7) { argsProcessed = 7; }

		var lastArg = arguments[numArgs - 1];
		var processUpTo;
		if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
			drawingOptions = lastArg;
			processUpTo = numArgs - 2;
		} else {
			processUpTo = numArgs - 1;
		}
		if (processUpTo >= argsProcessed) {
			fillcolour = arguments[argsProcessed];
			argsProcessed++;
			if (processUpTo == argsProcessed) {
				outlinecolour = arguments[argsProcessed];
			}
		}

		if (star === undefined) {
			star = 1;
		}

		if (rotation === undefined) {
			if (star <= -n || star >= n) {
				rotation = star;
				star = 1;
			} else {
				rotation = 0;
			}
		}

		if (outlinecolour === undefined) {
			if (fillcolour === undefined || interiorOutline) {
				outlinecolour = "black";
			}
		}
		if (interiorOutline === undefined) {
			interiorOutline = true;
		}

		if (drawingOptions !== undefined) {
			if (!("join" in drawingOptions)) {
				drawingOptions.join = "round";
			}
		}
		
		if (n === Infinity) {
			return new Circle(x, y, r, fillcolour, outlinecolour, drawingOptions);
		} else {
			return new RegularPolygon(x, y, r, n, star, rotation, interiorOutline, fillcolour, outlinecolour, drawingOptions);
		}
	}}$;
}
semicircleAngle ~> [RegularPolygon];

func Rotate {
	para item, angle;
	
	${{
		if (item instanceof CanvasImage) {
			return new Rotation(angle, new Point(item.dx + item.dWidth/2, item.dy + item.dHeight/2), new Point(item.dx,item.dy), 0, undefined, [item]);
		}
	}}$;
}

func CombinedRotation {
	${{
		if (arguments[0] instanceof Folder) {
			//Probably not an actual function call but semicircleAngle observable changed.
			return undefined;
		}

		var angle, centre, origin, angle2, radius, items;
		angle = arguments[0];
		centre = arguments[1];
		origin = arguments[2];

		if (arguments.length == 6) {
			angle2 = arguments[3];
			radius = arguments[4];
			items = arguments[5];
		} else {
			angle2 = angle;
			radius = arguments[3];
			items = arguments[4];		
		}

		if (!(centre instanceof Point)) {
			eden.error(new Error("CombinedRotation: The centre of rotation must be a Point, not a " + typeof(centre)), "error");
			return undefined;
		}
		if (!(origin instanceof Point)) {
			eden.error(new Error("CombinedRotation: The centre of the circular orbit must be a Point, not a " + typeof(origin)), "error");
			return undefined;
		}
		return new Rotation(angle, centre, origin, angle2, radius, items);
	}}$;
}

func RotateAboutCentre {
	${{
		if (arguments[0] instanceof Folder) {
			//Probably not an actual function call but semicircleAngle observable changed.
			return undefined;
		}

		var angle = arguments[0];
		var centre = arguments[1];
		var origin = arguments[2];
		var items = arguments[3];

		if (!(centre instanceof Point)) {
			eden.error(new Error("RotateAboutCentre: The centre of rotation must be a Point, not a " + typeof(centre)), "error");
			return undefined;
		}
		if (!(origin instanceof Point)) {
			eden.error(new Error("RotateAboutCentre: The destination position must be a Point, not a " + typeof(origin)), "error");
			return undefined;
		}
		return new Rotation(angle, centre, origin, 0, undefined, items);
	}}$;
}

func RotateAboutPoint {
	${{
		if (arguments[0] instanceof Folder) {
			//Probably not an actual function call but semicircleAngle observable changed.
			return undefined;
		}

		var angle, origin, radius, centre, items;
		angle = arguments[0];
		origin = arguments[1];
		radius = arguments[2];

		if (arguments.length == 5) {
			centre = arguments[3];
			items = arguments[4];
			if (!(centre instanceof Point)) {
				eden.error(new Error("RotateAboutPoint: The centre point of the source picture must be a Point, not a " + typeof(centre)), "error");
				return undefined;
			}
		} else {
			items = arguments[3];
		}

		if (!(origin instanceof Point)) {
			eden.error(new Error("RotateAboutPoint: The centre of the circle must be a Point, not a " + typeof(origin)), "error");
			return undefined;
		}
		return new Rotation(0, centre, origin, angle, radius, items);
	}}$;
}

semicircleAngle ~> [CombinedRotation, RotateAboutCentre, RotateAboutPoint];


#! Draws a rounded rectangle. See [drawing options](@external CanvasExamples > drawingoptions) for more style properties.
#
# ##Usage Example
#  `RoundedRectangle(x,y,width,height, 10);`
#
# @param x
# @param y
# @param width
# @param height
# @param radius
# @param [fillColour
# @param [outlineColour]]
# @param [drawingOptions]
# 
#  #canvas #roundedRectangle #rounded #rectangle #drawingOptions #shape #box #draw
func RoundedRectangle {
${{
	var x = arguments[0];
	var y = arguments[1];
	var width = arguments[2];
	var height = arguments[3];
	var radius = arguments[4];
	var fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 5) {
		fillcolour = arguments[5];
		if (processUpTo == 6) {
			outlinecolour = arguments[6];
		}
	}
	if (fillcolour === undefined && outlinecolour === undefined) {
		outlinecolour = "black";
	}
	return new RoundedRectangle(x, y, width, height, radius, fillcolour, outlinecolour, drawingOptions);
}}$; };

func Scale {
	${{
		var scaleX, scaleY, centreX, centreY, translateX, translateY, items;

		var argNum = arguments.length - 1;
		var arg;

		items = arguments[argNum];
		argNum--;
		if (argNum > 0) {
			arg = arguments[argNum];
			if (arg instanceof Point) {
				translateX = arg.x;
				translateY = arg.y;
				argNum--;
			} else if (argNum >= 2) {
				translateY = arg;
				argNum--;
				translateX = arguments[argNum];
				argNum--;
			}
			if (argNum > 0) {
				arg = arguments[argNum];
				if (arg instanceof Point) {
					centreX = arg.x;
					centreY = arg.y;
					argNum--;
				} else if (argNum >= 2) {
					centreY = arg;
					argNum--;
					centreX = arguments[argNum];
					argNum--;
				}
			}
			if (argNum == 1) {
				scaleY = arguments[argNum];
			} else if (argNum > 0) {
				eden.error(new Error("Scale: invalid parameters."), "error");
				return undefined;
			}
		}

		scaleX = arguments[0];
		if (scaleY === undefined) {
			scaleY = scaleX;
		}

		return new Scaling(scaleX, scaleY, centreX, centreY, translateX, translateY, items);
	}}$;
}


func Sector { ${{
	var x = arguments[0];
	var y = arguments[1];
	var r = arguments[2];
	var sAngle = arguments[3];
	var eAngle = arguments[4];
	var unitsInCircle, fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}

	var argsProcessed = 5;
	if (typeof(arguments[argsProcessed]) == "number") {
		unitsInCircle = arguments[argsProcessed];
		argsProcessed++;
	}
	if (argsProcessed <= processUpTo) {
		fillcolour = arguments[argsProcessed];
		argsProcessed++;
	}
	if (argsProcessed <= processUpTo) {
		outlinecolour = arguments[argsProcessed];
	}
	if (fillcolour === undefined && outlinecolour === undefined) {
		outlinecolour = "black";
	}
	return new Sector(x, y, r, sAngle, eAngle, unitsInCircle, fillcolour, outlinecolour, drawingOptions);
}}$; };
semicircleAngle ~> [Sector];


func Shadow {
	${{
		var colour, blur, xOffset, yOffset, scale;

		var processUpTo;
		var numArgs = arguments.length;
		var lastArg = arguments[numArgs - 1];
		if (lastArg === true || lastArg === false || numArgs == 5) {
			scale = lastArg;
			processUpTo = numArgs - 1;
		} else {
			processUpTo = numArgs;
		}

		var argsProcessed;
		if (typeof(arguments[0]) == "string" || (arguments[0] === undefined && processUpTo > 3)) {
			colour = arguments[0];
			argsProcessed = 1;
		} else {
			argsProcessed = 0;
		}
		if (colour == undefined) {
			colour = "#3b3b3b";
		}

		xOffset = arguments[argsProcessed];
		argsProcessed++;
		yOffset = arguments[argsProcessed];
		argsProcessed++;
		blur = arguments[argsProcessed];
		return new Shadow(colour, xOffset, yOffset, blur, scale);
	}}$;
}

/**
 * Create a slider input control
 * 
 * @param [name] Prefix for _value and _preview observables.  Default is the name of the observable being defined.
 * @param min Minimum value of the slider
 * @param max Maximum value of the slider
 * @param [step Step interval
 * @param [label_interval How frequently to display labels
 * @param [tick_mark_interval How frequently to display tick marks
 * @param [label_divisor]]]] Each label is divided by label_divisor before display 
 * @param x X-position
 * @param y Y-position
 * @param size Size in pixels
 * @param [orientation] Either "horizontal", "vertical", "up", or "down"
 * @param [enabled] Boolean True or False
 *
 * #canvas #input #slider
 * 
 */
func Slider { ${{
	var argsProcessed;

	var name;
	if (typeof(arguments[0]) == "string") {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("Slider: Every slider must have a name."), "error");
			return undefined;
		}
	}
	var min = arguments[argsProcessed];
	argsProcessed++;
	var max = arguments[argsProcessed];
	argsProcessed++;

	var step, labelInterval, labelDivisor, tickMarkInterval, x, y, length, orientation, enabled;
	var arg, argType;
	if (typeof(arguments[argsProcessed + 6]) == "number") {
		step = arguments[argsProcessed];
		labelInterval = arguments[argsProcessed + 1];
		tickMarkInterval = arguments[argsProcessed + 2];
		labelDivisor = arguments[argsProcessed + 3];
		argsProcessed = argsProcessed + 4;
	} else if (typeof(arguments[argsProcessed + 5]) == "number") {
		step = arguments[argsProcessed];
		labelInterval = arguments[argsProcessed + 1];
		tickMarkInterval = arguments[argsProcessed + 2];
		argsProcessed = argsProcessed + 3;
	} else if (typeof(arguments[argsProcessed + 4]) == "number") {
		step = arguments[argsProcessed];
		labelInterval = arguments[argsProcessed + 1];
		argsProcessed = argsProcessed + 2;
	} else if (typeof(arguments[argsProcessed + 3]) == "number") {
		step = arguments[argsProcessed];
		argsProcessed++;
	} else if (max - min > 1 && Math.floor(min) == min && Math.floor(max) == max) {
		step = 1;
	}
	x = arguments[argsProcessed];
	y = arguments[argsProcessed + 1];
	length = arguments[argsProcessed + 2];
	argsProcessed = argsProcessed + 3;
	arg = arguments[argsProcessed];
	argType = typeof(arg);
	if (arg === undefined || argType == "string") {
		orientation = arguments[argsProcessed];
		argsProcessed++;
		arg = arguments[argsProcessed];
	}
	enabled = arg;

	if (labelInterval !== undefined) {
		if (labelDivisor === undefined) {
			labelDivisor = 1;
		}
		if (tickMarkInterval === undefined) {
			tickMarkInterval = labelInterval;
		}
	}
	if (orientation === undefined) {
		orientation = "horizontal";
	}
	if (enabled === undefined) {
		enabled = true;
	}

	return new Slider(name, min, max, step, labelInterval, tickMarkInterval, labelDivisor, x, y, length, orientation, enabled);
}}$; }

## Copyright (c) 2016, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

func TableLayout {
${{
	var x = arguments[0];
	var y = arguments[1];
	var width, content, drawingOptions;

	var argsProcessed = 2;
	var arg = arguments[2];

	if (Array.isArray(arg)) {
		content = arg;
		argsProcessed++;
	} else {
		width = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		content = arg;
		argsProcessed++;
	}

	arg = arguments[argsProcessed];

	if (typeof(arg) == "object") {
		drawingOptions = arg;
	}

	return new TableLayout(x, y, width, content, drawingOptions);
}}$;
}

#! Create a drawable text object for a canvas. See [drawing options](@external CanvasExamples > drawingoptions) for more font and style options.
# 
# ##Usage Example
#  `Text("Message", x, y);`
#  `Text("Hello", x, y, 20, "red");`
#
# @param text Text string to display
# @param x X-coordinate
# @param y Y-coordinate
# @param [size] Size in pixels, or can be specified as a string with a unit (e.g., "30pt", "2em", etc.)
# @param [fill_colour Text colour in HTML form
# @param [outline_colour]]
# @param [options] Options, in string or object format
# 
#  #canvas #text #label #draw
func Text {
	${{
		var text = arguments[0];
		var x = arguments[1];
		var y = arguments[2];
		var size, fillcolour, outlinecolour, options, valign, align;

		var numArgs = arguments.length;
		var argsLeft = numArgs - 3;
		var argsProcessed = 3;

		if (arguments[3] === undefined || typeof(arguments[3]) == "number") {
			size = arguments[3];
			argsProcessed++;
			argsLeft--;
		}

		var lastArg = arguments[numArgs - 1];
		var argType = typeof(lastArg);
		var match;

		if (argType == "string") {
			match = lastArg.match(Text.cssRegExp);
		}

		if (match) {
			argsLeft--;
			valign = match[1];
			align = match[2];
			if (match[3]) {
				// italic, bold, etc.
				options = match[3];
			} else {
				options = "";
			}
			if (match[4]) {
				// size
				options = options + " " + match[4];
			} else if (size !== undefined) {
				options = options + " " + size + "px";
			} else {
				options = options + " " + edenUI.plugins.Canvas2D.defaultFontSizePx + "px";
			}
			if (match[5]) {
				// font family
				options = options + " " + match[5];
			} else {
				options = options + " sans-serif";
			}

		} else if (argType == "object" && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
			argsLeft--;
			options = lastArg;
		}

		if (argsLeft > 0) {
			fillcolour = arguments[argsProcessed];
			argsLeft--;
			argsProcessed++;
			if (argsLeft > 0) {
				outlinecolour = arguments[argsProcessed];
			}
		}

		if (outlinecolour === undefined && fillcolour === undefined) {
			fillcolour = "black";
		}
		return new Text(text, x, y, size, fillcolour, outlinecolour, options, valign, align);
	}}$;
}

func textWidth {
	${{
		var text = arguments[0];
		var options = Text.parseArgs.apply(undefined, arguments);
		var css = options[0];
		var optionsObj = options[1];
		var scale = options[2];

		//Find an existing canvas (any one).
		var canvas;
		for (var canvasName in canvases) {
			canvas =  canvases[canvasName];
			break;
		}
		if (canvas === undefined) {
			canvas = document.createElement("canvas");
		}

		var context = canvas.getContext("2d");
		context.save();
		edenUI.plugins.Canvas2D.configureContextDefaults(context, 1);
		edenUI.plugins.Canvas2D.configureContext(context, 1, 1, optionsObj);
		context.font = css;
		context.textBaseline = "top";
		var metrics = context.measureText(text);
		var lineWidth;
		if (this.outlinecolour !== undefined) {
			lineWidth = context.lineWidth;
		} else {
			lineWidth = 0;
		}
		var width = Math.ceil(metrics.width + lineWidth) / scale;
		context.restore();
		return width;
	}}$;
}

func textHeight {
	${{
		var text = arguments[0];
		var options = Text.parseArgs.apply(undefined, arguments);
		var fontCSS = options[0];
		var optionsObj = options[1];
		var scale = options[2];

		var lineWidth;
		if (optionsObj !== undefined) {
			lineWidth = optionsObj.lineWidth;
		}
		if (lineWidth === undefined) {
			lineWidth = 2;
		}

		var div = document.createElement("div");
		div.innerHTML = text;
		var style = div.style;
		style.position = 'absolute';
		style.top  = '-9999px';
		style.padding = "0pt";
		style.whiteSpace = "nowrap";
		style.lineHeight = "1";
		style.font = fontCSS;

		//Find an existing canvas (any one).
		var canvas, parent;
		for (var canvasName in canvases) {
			canvas =  canvases[canvasName];
			break;
		}
		if (canvas) {
			parent = canvas.parentNode;
		}
		if (!parent) {
			parent = document.body;
		}

		parent.appendChild(div);
		var height = div.scrollHeight;
		parent.removeChild(div);
		/* N.B. even when the vertical alignment is "top" Chrome still leaves a small top margin
		 * where as Firefox doesn't.
		 */
		return (height + lineWidth / 2) / scale;
	}}$;
}

/**
 * Creates a text input box for drawing on the canvas
 * 
 * @param [name] Prefix for _value observable.  Default is the name of the observable being defined.
 * @param x X-position
 * @param y Y-position
 * @param [width
 * @param [height]]
 * @param [placeholder_text] Text to be displayed by default
 * @param [max_characters] Maximum number of characters allowed in input box
 * @param [enabled] Boolean (true or false) to enable or disable input
 * 
 * #canvas #input #text #textbox
 */

	
func Textbox { ${{
	var argsProcesssed;

	var name;
	if (typeof(arguments[0]) == "string") {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("Textbox: Every text box must have a name."), "error");
			return undefined;
		}
	}

	var x = arguments[argsProcessed];
	argsProcessed++;
	var y = arguments[argsProcessed];
	argsProcessed++;

	var width, height, placeholder, maxlength, enabled;
	var arg = arguments[argsProcessed];
	var argType = typeof(arg);

	if (arg === undefined || argType == "number") {
		width = arguments[argsProcessed];
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}

	if (arg === undefined || argType == "number") {
		height = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}
	if (arg === undefined || argType == "string") {
		placeholder = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}
	if (arg === undefined || argType == "number") {
		maxlength = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
	}
	enabled = arg;
	return new Textbox(name, x, y, width, height, placeholder, maxlength, enabled);
}}$; }

func Translate {
	${{
		var centreX, centreY, x, y, items;
		var argNum = arguments.length - 1;
		if (argNum == 0) {
			eden.error(new Error("Translate: This function requires at least 2 arguments."), "error");
			return undefined;
		}
		items = arguments[argNum];
		argNum--;
		arg = arguments[argNum];
		if (arg instanceof Point) {
			x = arg.x;
			y = arg.y;
			argNum--;
		} else if (argNum >= 1) {
			y = arg;
			argNum--;
			x = arguments[argNum];
			argNum--;
		}
		if (argNum >= 0) {
			arg = arguments[argNum];
			if (arg instanceof Point) {
				centreX = arg.x;
				centreY = arg.y;
				argNum--;
			} else if (argNum >= 1) {
				centreY = arg;
				argNum--;
				centreX = arguments[argNum];
				argNum--;
			}		
		}
		if (argNum >= 0) {
			eden.error(new Error("Translate: invalid parameters."), "error");
			return undefined;
		}

		if (typeof(x) !== "number") {
			eden.error(new Error("Translate: The destination X coordinate must be a number, not a " + typeof(x)), "error");
			return undefined;
		}
		if (typeof(y) !== "number") {
			eden.error(new Error("Translate: The destination Y coordinate must be a number, not a " + typeof(y)), "error");
			return undefined;
		}
		if (centreX === undefined) {
			centreX = 0;
		}
		if (centreY === undefined) {
			centreY = 0;
		}
		return new Translation(centreX, centreY, x, y, items);
	}}$;
}

# Copyright (c) 2015, Empirical Modelling Group
# All rights reserved.
#
# See LICENSE.txt

#Bugs:
#Assigning to _chapters causes a jump back to the beginning of the current chapter.
#Triggered procedures are possibly called twice when making assignments?
#If _paused is defined by dependency and is true while seeking then the video starts playing while the mouse button is still held down.
#Attempting to play back video in reverse (vid_speed < 0) only works on Safari on Mac.  A workaround is possible.
#Loading a new video file will reset the playback speed to 1.
#Assigning "end" to _chapter gives improper _time.
#Todo:
#Add ability to set audio player width using _width
#Add a _duration observable (assigning prevents playing past that point).  Change .duration to .maximumDuration
#Add support for poster images.
#Add click in video area to play/pause.
#Add feedback for downloading issues.
#Add mode that draws the video onto the canvas.
#Useful site for extracting YouTube video URLs: http://www.downvids.net/
#Alternative site: http://www.youtubeinmp4.com/
#MP3 files: http://www.mfiles.co.uk/mp3-files.htm

#For a Video drawable named "vid", the following observables are available.  All are read/write.
#
#vid_url
#	The URL of the current video loaded into the video player.
#
#vid_position
#	A Point object representing the position of the video player on the canvas.
#
#vid_size
#	A Point object representing the width and height of the video as it is displayed on the canvas.
#
#vid_scale
#	A number representing the canvas scale factor used to express vid_size.
#
#vid_controls
#	Whether or not the built-in playback controls are available to the user or not.
#
#vid_paused
#	True if the video is not currently playing and false if it is playing or if it should be played
#	as soon as it has finished loading.  Note that if vid_paused is determined by dependency and the
#	user overrides this decision by pausing or resuming playback using the playback controls then
#	the value of vid_paused will not reflect the true status of the video playback.  Also, if
#	vid_paused is determined by dependency and equals true when the end of the video is reached then
#	the video will play again from the beginning.
#
#vid_time
#	The current temporal position of the video, accurate to the nearest second.  Cannot be set by
#	dependency unless the video is kept paused.
#
#vid_chapters and vid_chapter
#	If defined then vid_chapters should be an object where the keys are labels attributed to certain
#	sections of the video and the values are the times when these sections begin.  For example, if
#	vid_chapters is {lesson1: 60, lesson2: 900} then vid_chapter will contain the string "start"
#	during the first 60 seconds of playback, contain the string "lesson1" between 60 seconds through
#	to 15 minutes into the video, at which point the second lesson begins and vid_chapter will
#	become "lesson2".  When the video has finished playing vid_chapter will become "end".
#
#vid_speed
#	Determines the speed of video playback, e.g. 1 for normal speed or 2 to play back at double
#	speed.  Setting the speed to zero pauses the video and assigns the value true to vid_paused
#	unless vid_paused is calculated by dependency.  If vid_speed is set to zero then subsequently
#	assigning another value to vid_speed won't automatically resume playback unless vid_paused is
#	calculated by dependency.  If vid_speed is zero when the video becomes unpaused, either by
#	the value of vid_paused changing from true to false or by the user clicking on the play button,
#	then the speed will be reset to 1.
#
#vid_volume
#	The current volume level of the video's soundtrack, between 0 and 1.  If vid_volume is specified
#	by dependency and playback controls are enabled and the user uses them to adjust the volume
#	then then the dependency will be overwritten by an implicit assignment.
#
#Useful properties of the drawable object itself:
#
#.duration
#	The duration of the currently loaded video file (read-only).
#
#Useful methods of the drawable object itself:
#
#.unmute()
#	Restores the volume to its previous level if currently playing silently.

#Example:
/*
	vid_url = "...";
	vid is Video();
	picture is [vid];

	#Stop to complete an exercise 60 seconds into the video.
	exercisePoints = [60];
	exercisesCompleted = [false];
	exerciseNumber is positionInList(vid_time, exercisePoints);
	vid_controls is exerciseNumber == 0 || exercisesCompleted[exerciseNumber];
	vid_paused is vid_controls == false;
*/

func Video {
	${{
		var argsProcessed;

		var name;
		if (typeof(arguments[0]) == "string") {
			name = arguments[0];
			argsProcessed = 1;
		} else {
			name = root.currentObservableName();
			argsProcessed = 0;
			if (name === undefined) {
				eden.error(new Error("Video: Every video must have a name."), "error");
				return undefined;
			}
		}
		var preload;
		if (argsProcessed < arguments.length) {
			preload = arguments[argsProcessed];
		} else {
			preload = false;
		}
		return new Audiovisual(name, "Video", preload);
	}}$;
}

func Audio {
	${{
		var argsProcessed;

		var name;
		if (typeof(arguments[0]) == "string") {
			name = arguments[0];
			argsProcessed = 1;
		} else {
			name = root.currentObservableName();
			argsProcessed = 0;
			if (name === undefined) {
				eden.error(new Error("Audio: Every audio player must have a name."), "error");
				return undefined;
			}
		}
		var preload;
		if (argsProcessed < arguments.length) {
			preload = arguments[argsProcessed];
		} else {
			preload = false;
		}
		return new Audiovisual(name, "Audio", preload);
	}}$;
}


/**
 * Create a View tag to display an embedded view
 * 
 * @param name
 * @param type
 * @param x X-coordinate
 * @param y Y-coordinate
 * @param [width Width in pixels or as a string or undefined
 * @param [height]] Height in pixels or as a string or undefined
 * #canvas #view #embedded
 */
func View { ${{
	var name = arguments[0];
	var type = arguments[1];
	var x = arguments[2];
	var y = arguments[3];
	var width, height;   //Number of pixels, string (e.g. "50%") or undefined (automatic)
	
	var argsProcessed = 4;
	var argType = typeof(arguments[4]);
	
	if (argType == "number" || argType == "undefined") {
		width = arguments[4];
		argsProcessed++;
		
		argType = typeof(arguments[5]);
		if (argType == "number" || argType == "undefined") {
			height = arguments[5];
			argsProcessed++;
		}
	}

	return new View(name, type, x, y, width, height);
}}$ }
