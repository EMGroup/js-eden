${{console.log("Got Here");}}$;
## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
	console.log("Loading canvas_merged.js-e");
}}$;


${{
Arc = function(x, y, r, sAngle, eAngle, colour, drawingOptions) {
	this.x = x;
	this.y = y;
	this.r = r;
	this.sAngle = sAngle;
	this.eAngle = eAngle;
	var radiansPerUnit = Math.PI / root.lookup("semicircleAngle").value();
	var sRadians = sAngle * radiansPerUnit;
	var eRadians = eAngle * radiansPerUnit;
	var twoPI = 2 * Math.PI;
	sRadians = sRadians % twoPI;
	if (sRadians < 0) {
		sRadians = sRadians + twoPI;
	}
	eRadians = eRadians % twoPI;
	if (eRadians < 0) {
		eRadians = eRadians + twoPI;
	}
	this.sRadians = sRadians;
	this.eRadians = eRadians;
	
	this.colour = colour
	this.drawingOptions = drawingOptions;
}
}}$;

#! Draw an Arc. See [drawing options](@external CanvasExamples > drawingoptions) to control appearance.
#
# ##Usage Example
#  `Arc(x, y, radius, startAngle, endAngle);`
#  `Arc(x, y, radius, startAngle, endAngle, "red");`
#
# @param x X position
# @param y Y position
# @param r Radius
# @param sAngle Start angle in degrees
# @param eAngle End angle in degrees
# @param [colour] Default is black
# @param [drawingOptions] Drawing Options object
#
#  #canvas #arc #drawingOptions
func Arc {
${{
	var x = arguments[0];
	var y = arguments[1];
	var r = arguments[2];
	var sAngle = arguments[3];
	var eAngle = arguments[4];
	var colour, drawingOptions;
	if (arguments.length == 6 && typeof(arguments[5]) == "object" && !(arguments[5] instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		colour = "black";
		drawingOptions = arguments[5];
	} else {
		colour = arguments[5];
		drawingOptions = arguments[6];
		if (colour === undefined) { colour = "black"; }
	}
	return new Arc(x, y, r, sAngle, eAngle, colour, drawingOptions);
}}$; };
semicircleAngle ~> [Arc];

${{

Arc.prototype.draw = function(context, scale) {
	var anticlockwise;
	if (this.drawingOptions !== undefined && "direction" in this.drawingOptions) {
		var directionName = this.drawingOptions.direction;
		var turnedThroughAC = this.eRadians - this.sRadians;
		if (this.eRadians < this.sRadians) {
			turnedThroughAC = turnedThroughAC + 2 * Math.PI;
		}
		switch (directionName) {
		case "anticlockwise":
		case "acw":
		case "ccw":
			anticlockwise = true;
			break;
		case "auto":
			anticlockwise = this.sAngle < this.eAngle;
			break;
		case "clockwise":
		case "cw":
			anticlockwise = false;
			break;
		case "major":
			anticlockwise = turnedThroughAC > Math.PI;
			break;
		case "minor":
			anticlockwise = turnedThroughAC <= Math.PI;
			break;
		default:
			//Invalid value specified.
			anticlockwise = true;
		}
	} else {
		//Default to "auto" 
		anticlockwise = this.sAngle < this.eAngle;
	}
	var sRadians = this.sRadians;
	var eRadians = this.eRadians;
	if (scale < 0) {
		sRadians = -sRadians;
		eRadians = -eRadians;
		anticlockwise = !anticlockwise;
	}
	var r = this.r - context.lineWidth / 2;
	context.beginPath();
	context.arc(this.x, this.y, r, -sRadians, -eRadians, anticlockwise);
	context.strokeStyle = this.colour;
	context.stroke();

	if (this.drawingOptions !== undefined && this.drawingOptions.arrowhead instanceof Arrowhead) {
		var cos1 = Math.cos(-sRadians);
		var sin1 = Math.sin(-sRadians);
		var cos2 = Math.cos(-eRadians);
		var sin2 = Math.sin(-eRadians);
		var x1 = this.x + r * cos1;
		var y1 = this.y + r * sin1;
		var x2 = this.x + r * cos2;
		var y2 = this.y + r * sin2;
		var gradient1 = -cos1 / sin1;
		var gradient2 = -cos2 / sin2;
		var reverse1, reverse2;
		if (anticlockwise) {
			reverse1 = sRadians <= Math.PI;
			reverse2 = eRadians <= Math.PI;
		} else {
			reverse1 = sRadians > Math.PI;
			reverse2 = eRadians > Math.PI;
		}
		this.drawingOptions.arrowhead.draw(context, scale, x1, y1, gradient1, reverse1, x2, y2,
			gradient2, reverse2);
	}
};

Arc.prototype.toString = function() {
	var s = "Arc(" + Eden.edenCodeForValues(this.x, this.y, this.r, this.sAngle, this.eAngle, this.colour);

	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
}

Arc.prototype.getEdenCode = Arc.prototype.toString;

}}$;

${{console.log("Got Here");}}$;
${{console.log("Got Here");}}$;
## Copyright (c) 2016, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
	Arrowhead = function(start, end, length, width, filled) {
		this.start = start;
		this.end = end;
		this.length = length;
		this.width = width;
		this.filled = filled;
	};

	Arrowhead.prototype.toString = function () {
		return "Arrowhead(" + Eden.edenCodeForValues(this.start, this.end, this.length, this.width,
			this.filled) + ")";
	};

	Arrowhead.prototype.getEdenCode = Arrowhead.prototype.toString;

	Arrowhead.prototype.draw = function (context, scale, x1, y1, gradient1, reverse1, x2, y2, gradient2, reverse2) {
		var invGradient, len1, len2, len3, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y;
		var lineWidth = context.lineWidth;
		var adjustment = lineWidth / 4;
		var filled = this.filled;

		var width = this.width;
		var length = this.length;

		if (length === undefined) {
			if (lineWidth <= 4) {
				length = 10 / scale;
			} else {
				length = lineWidth * 2.5 / scale;
			}
		} else {
			length = length / scale;
		}
		if (width === undefined) {
			width = length / 2;
		} else {
			width = (width / 2) / scale;
		}

		context.fillStyle = context.strokeStyle;

		if (this.start) {
			invGradient = - 1 / gradient1;
			if ((reverse1 && invGradient == Infinity) || (!reverse1 && invGradient == -Infinity)) {
				//Horizontal left
				p1x = x1 + length;
				p1y = y1 - width;
				p2x = p1x;
				p2y = y1 + width;
				p3x = x1 + adjustment;
				p3y = y1;
			} else if (gradient1 == 0) {
				//Horizontal right
				p1x = x1 - length;
				p1y = y1 - width;
				p2x = p1x;
				p2y = y1 + width;
				p3x = x1 - adjustment;
				p3y = y1;
			} else if ((reverse1 && gradient1 == -Infinity) || (!reverse1 && gradient1 == Infinity)) {
				//Vertical upward
				p1x = x1 - width;
				p1y = y1 + length;
				p2x = x1 + width;
				p2y = p1y;
				p3x = x1;
				p3y = y1 + adjustment;
			} else if (gradient1 == Infinity || gradient1 == -Infinity) {
				//Vertical downward
				p1x = x1 - width;
				p1y = y1 - length;
				p2x = x1 + width;
				p2y = p1y;
				p3x = x1;
				p3y = y1 - adjustment;
			} else {
				len1 = Math.sqrt(length * length / (1 + gradient1 * gradient1));
				if (reverse1) {
					len1 = -len1;
				}
				p0x = x1 + len1;
				p0y = y1 + len1 * gradient1;
				len2 = Math.sqrt(width * width / (1 + invGradient * invGradient));
				p1x = p0x - len2;
				p1y = p0y - len2 * invGradient;
				p2x = p0x + len2;
				p2y = p0y + len2 * invGradient;
				len3 = Math.sqrt(adjustment * adjustment / (1 + gradient1 * gradient1));
				p3x = x1 - len3;
				p3y = y1 - len3 * gradient1
			}

			context.beginPath();
			context.moveTo(p1x, p1y);
			context.lineTo(p3x, p3y);
			context.lineTo(p2x, p2y);
			if (filled) {
				context.closePath();
				context.fill();
			}
			context.stroke();
		}

		if (this.end) {
			invGradient = - 1 / gradient2;
			if ((reverse2 && invGradient == -Infinity) || (!reverse2 && invGradient == Infinity)) {
				//Horizontal left
				p1x = x2 + length;
				p1y = y2 - width;
				p2x = p1x;
				p2y = y2 + width;
				p3x = x2 + adjustment;
				p3y = y2;
			} else if (gradient2 == 0) {
				//Horizontal right
				p1x = x2 - length;
				p1y = y2 - width;
				p2x = p1x;
				p2y = y2 + width;
				p3x = x2 - adjustment;
				p3y = y2;
			} else if ((reverse2 && gradient2 == Infinity) || (!reverse2 && gradient2 == -Infinity)) {
				//Vertical upward
				p1x = x2 - width;
				p1y = y2 + length;
				p2x = x2 + width;
				p2y = p1y;
				p3x = x2;
				p3y = y2 + adjustment;
			} else if (gradient2 == Infinity || gradient2 == -Infinity) {
				//Vertical downward
				p1x = x2 - width;
				p1y = y2 - length;
				p2x = x2 + width;
				p2y = p1y;
				p3x = x2;
				p3y = y2 - adjustment;
			} else {
				len1 = Math.sqrt(length * length / (1 + gradient2 * gradient2));
				if (reverse2) {
					len1 = -len1;
				}
				p0x = x2 - len1;
				p0y = y2 - len1 * gradient2;
				len2 = Math.sqrt(width * width / (1 + invGradient * invGradient));
				p1x = p0x - len2;
				p1y = p0y - len2 * invGradient;
				p2x = p0x + len2;
				p2y = p0y + len2 * invGradient;
				len3 = Math.sqrt(adjustment * adjustment / (1 + gradient2 * gradient2));
				p3x = x2 - len3;
				p3y = y2 - len3 * gradient2
			}

			context.beginPath();
			context.moveTo(p1x, p1y);
			context.lineTo(p3x, p3y);
			context.lineTo(p2x, p2y);
			if (filled) {
				context.closePath();
				context.fill();
			}
			context.stroke();
		}
	};

}}$;

#! Create an Arrowhead line.
# @param start Whether to draw the arrowhead at the start
# @param end Whether to draw the arrowhead at the end
# @param length Length of the arrowhead
# @param width Width of the arrowhead. IF undefined, a proportional value is automatically chosen.
# @param [filled] Whether to fill the arrowhead or just draw an outline. Defaults to true.
# 
#  #canvas #arrow #arrowhead #shape #arrow #library #draw
func Arrowhead {
	${{
		var argsProcessed;
		var numArgs = arguments.length;
		var arg = arguments[0];
		var argType = typeof(arg);

		var start, end, length, width, filled;

		if ((argType == "boolean" && numArgs >= 2 &&
		 (typeof(arguments[1]) == "boolean" || arguments[1] === undefined)) ||
		 numArgs == 5
		) {
			start = arg;
			end = arguments[1];
			argsProcessed = 2;
			arg = arguments[2];
			argType = typeof(arg);
		} else {
			start = false;
			end = true;
			argsProcessed = 0;
		}

		if (argType == "number" || arg === undefined) {
			length = arg;
			argsProcessed++;
			arg = arguments[argsProcessed];
			argType = typeof(arg);
		}

		if (argType == "number" || arg === undefined) {
			width = length;
			length = arg;
			argsProcessed++;
		}

		if (argsProcessed < numArgs) {
			filled = arguments[argsProcessed];
		}

		if (filled === undefined) {
			filled = true;
		}

		return new Arrowhead(start, end, length, width, filled);
	}}$;
}

${{console.log("Got Here");}}$;
${{console.log("Got Here");}}$;
## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

#! Creates a clickable Button in your canvas. If you give the button a name then you can use observables with that name and _click or _clicked to respond to button presses.
#
# ##Usage Example
#  `Button("mybutton", "Label", x, y);`
#
# @param name Name to be used for the _click and _clicked observable
# @param label Label to be displayed
# @param [imageURL] Image to be displayed on the button
# @param x
# @param y
# @param [width] Default fits the size of the label
# @param [height] Default fits the size of the label
# @param [enabled]
# 
#  #canvas #button
func Button {
${{
	var argsProcessed, arg, argType;
	var name, label, imageURL;
	var nameSpecified = false;
	for (argsProcessed = 0; argsProcessed < 3; argsProcessed++) {
		arg = arguments[argsProcessed];
		if (arg !== undefined && typeof(arg) != "string") {
			break;
		}
	}

	if (argsProcessed == 3) {
		name = arguments[0];
		label = arguments[1];
		imageURL = arguments[2];
		nameSpecified = true;
	} else if (argsProcessed > 0) {
		var str = arguments[argsProcessed - 1];
		var found = false;
		for (var i = 0; i < Button.imageFileSuffixes.length; i++) {
			var filenameSuffix = Button.imageFileSuffixes[i];
			if (str.substr(-filenameSuffix.length) == filenameSuffix) {
				imageURL = str;
				if (argsProcessed == 2) {
					label = arguments[0];
				}
				found = true;
				break;
			}
		}
		if (!found) {
			label = str;
			if (argsProcessed == 2) {
				name = arguments[0];
				nameSpecified = true;
			}
		}
	}
	if (name === undefined) {
		var obsName = root.currentObservableName();
		if (!nameSpecified) {
			name = obsName;
		}
		if (name === undefined) {
			eden.error(new Error("Button: The button defined by observable " + obsName + " must have a name."), "error");
			return undefined;
		}	
	}

	var x = arguments[argsProcessed];
	argsProcessed++;
	var y = arguments[argsProcessed];
	argsProcessed++;
	arg = arguments[argsProcessed];
	argType = typeof(arg);

	var width, minHeight, enabled;

	if (argType == "number") {
		width = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);

		if (argType == "number") {
			minHeight = arg;
			argsProcessed++;
			arg = arguments[argsProcessed];
			argType = typeof(arg);
		}
	}

	if (argType == "boolean") {
		enabled = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);	
	} else {
		enabled = true;
	}

	if (argsProcessed < arguments.length - 2) {
		argsProcessed = arguments.length - 2;
	}

	var fillcolour = arguments[argsProcessed];
	var textcolour = arguments[argsProcessed + 1];
	return new Button(name, label, imageURL, x, y, width, minHeight, enabled, fillcolour, textcolour);
}}$;
}

${{
Button = function (name, label, imageURL, x, y, width, minHeight, enabled, fillcolour, textcolour) {
	this.name = name;
	this.obsName = root.currentObservableName();
	this.label = label;
	this.imageURL = imageURL;
	this.x = x;
	this.y = y;
	this.width = width;
	this.minHeight = minHeight;
	this.enabled = enabled;
	this.fillcolour = fillcolour;
	this.textcolour = textcolour;
};

Button.imageFileSuffixes = [".jpg", ".jpeg", ".png", ".gif", ".svg", ".svgz", ".webp", ".bmp", ".ico"];

Button.prototype.hash = function () {
	return this.name+"$$"+
				this.label+"$$"+
				this.imageURL+"$$"+
				this.x+"$$"+
				this.y+"$$"+
				this.width+"$$"+
				this.minHeight+"$$"+
				this.enabled+"$$"+
				this.fillcolour+"$$"+
				this.textcolour;
};

Button.prototype.draw = function (context) {

	if (this.elements === undefined) {
		var name = this.name;

		var disabled = this.enabled === false? 'disabled="disabled" ' : ' ';
		var inputHtml = '<button ' +
			disabled +
			'class="canvashtml-item" ' +
			'style="';
		if (this.fillcolour !== undefined) {
			inputHtml = inputHtml + 'background-color: ' + this.fillcolour + '; ';
		}
		if (this.textcolour !== undefined) {
			inputHtml = inputHtml + 'color: ' + this.textcolour + '; ';
		}
		if (this.width === undefined) {
			inputHtml = inputHtml + 'max-width: 256px';
		}
		inputHtml = inputHtml + '">';
		if (this.imageURL !== undefined) {
			inputHtml = inputHtml + '<img src="' + this.imageURL + '" style="max-width: 100%"/><br/>';
		}
		if (this.label !== undefined) {
			inputHtml = inputHtml + this.label;
		}
		inputHtml = inputHtml + '</button>';

		var inputJQ = $(inputHtml);
		var clickSym = root.lookup(name + "_click");
		if (clickSym.value() === undefined) {
			//var agent = root.lookup("Button");
			clickSym.assign(false, root.scope, EdenSymbol.hciAgent);
			root.lookup(name + "_clicked").assign(false, root.scope, EdenSymbol.hciAgent);
		}

		inputJQ
		.click(function () {
			root.lookup(name + "_clicked").assign(true, root.scope, EdenSymbol.hciAgent, true);
			root.lookup(name + "_clicked").assign(false, root.scope, EdenSymbol.hciAgent, true);
		})
		.on("mousedown", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseDownZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		})
		.on("mouseup", function () {
			edenUI.plugins.Canvas2D.endClick();
		})
		.on("mouseenter", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		});

		var button = inputJQ.get(0);
		this.elements = [button];

	} else {

		//Case when the user has performed direct assignment to one or more JavaScript properties.
		var button = this.elements[0];
		button.value = this.label;

		if (this.enabled) {
			button.disabled = false;
		} else {
			button.disabled = true;
		}

		var style = button.style;
		var fillcolour = this.fillcolour;
		if (style.backgroundColor != fillcolour) {
			if (fillcolour === undefined) {
				style.backgroundColor = "";
			} else {
				style.backgroundColor = fillcolour;
			}
		}
		var textcolour = this.textcolour;
		if (style.color != textcolour) {
			if (textcolour === undefined) {
				style.color = "";
			} else {
				style.color = textcolour;
			}
		}
	}
};

Button.prototype.scale = function (scale, zoom, origin) {
	var style = this.elements[0].style;
	style.left = Math.round((this.x + origin.x) * scale) + "px";
	style.top =  Math.round((this.y + origin.y) * scale) + "px";
	style.fontSize = zoom + "em";

	if (this.width === undefined) {
		style.width = "";
	} else {
		style.width = Math.round(this.width * scale) + "px";
	}

	if (this.minHeight === undefined) {
		style.minHeight = "";
	} else {
		style.minHeight = Math.ceil(this.minHeight * scale) + "px";
	}
};

Button.prototype.toString = function () {
	var s;
	if (this.name == this.obsName) {
		s = "Button(" + Eden.edenCodeForValues(this.label, this.imageURL, this.x, this.y, this.enabled);
	} else {
		s = "Button(" + Eden.edenCodeForValues(this.name, this.label, this.imageURL, this.x, this.y, this.enabled);
	}
	if (this.fillcolour !== undefined || this.textcolour !== undefined) {
		s = s + ", " + Eden.edenCodeForValues(this.fillcolour, this.textcolour);
	}
	s = s + ")";
	return s;
};

Button.prototype.getEdenCode = Button.prototype.toString;

}}$;

# Copyright (c) 2013, Empirical Modelling Group
# All rights reserved.
#
# See LICENSE.txt


#Initialize observables
mouseButton = "";
mouseButtons = "";
mouseCapture = false;
mouseCaptured = false;
mouseContextMenuEnabled = false;
mouseDoubleClicks = 0;
mouseDown = @;
mouseDownView = @;
mouseDownZone = @;
mouseFollow = false;
mousePosition = @;
mousePressed = false;
mouseUp = @;
mouseWheel = 0;
mouseWheelEnabled = false;
mouseWheelVelocity = 0;
mouseView = @;
mouseX is @ if mousePosition == @ else mousePosition["x"];
mouseY is @ if mousePosition == @ else mousePosition["y"];
mouseZone = @;
pixel is 1 / view_picture_scale;
touchPanX = 0;
touchPanXSpeed = 0;
touchPinch = 0;
touchPinchEnabled = false;


${{
	root.lookup("mouseCapture").addJSObserver("releaseCapture", function (obs, lock) {
		console.log("mouseCapture not currently supported");
//		if (!lock && document.exitPointerLock) {
//			document.exitPointerLock();
//		}
	});
}}$;
${{console.log("Line 707");}}$;
/** 
* Attempts to capture the mouse pointer so the it cannot leave the current canvas window.  This
* allows the mouse to be used as a pure sensor and the mousePosition observable becomes able to take
* on any value, free from the constraints of the size of the window.  Note that this procedure will
* only work if the window has already been in mouse capture mode previously and the user did not
* exit capture mode using the escape key.

* The sequence of events:
* 1) The model sets the mouseCapture observable to true, meaning that mouse capture is permitted.
* 1) The user clicks in the canvas window to initiate capture mode.  The mouseCaptured observable
*     automatically gets set to true.
* 1) Capture mode is ended either by (a) the user pressing the escape key, or, (b) the model
*     setting the mouseCapture observable to false.
* 1) Calling attemptMouseCapture after case (3b) has occurred will succeed in the mouse pointer
*     becoming captured again immediately.  However, if case (3a) occurred then calling
*     attemptMouseCapture won't do anything.  If this situation occurs then the model can still set
*     mouseCapture to true and wait for the user to re-grant permission to capture mouse movements
*     by clicking in the window again.
*
* Note that at the time of writing (5/2/2015) although the underlying API has received the W3C's
* Candidate Recommendation approval it is currently only implemented in recent versions of Chrome.
* Access to mouse capturing capabilities can be restricted based upon a browser preference setting.
* (In Chrome this is under Settings->Advanced settings->Content settings->Mouse cursor.)
*/
proc attemptMouseCapture {
	${{
		var canvasName = root.lookup("mouseView").value();
		if (canvasName !== undefined) {
			canvases[canvasName].requestPointerLock();
		}
	}}$;
}

/**
* Creates a canvas and a triggered procedure so that canvas display is kept in
* sync with the value of a given observable at all times.  The first parameter
* is the name of the observable that provides the list of drawables.  The
* second, optional parameter, is the text to place into the window's title bar.
*
* 
* If three parameters are provided, the first is the viewName, the second is the
* observable that stores the list of drawables. The third parameter is the text to place
* into the window's title bar.
* 
* @param [viewName]
* @param observableName
* @param viewTitle
* 
*/
${{console.log("createCanvas");}}$;
func createCanvas {
	para p1, p2, p3;
	auto obsName, viewTitle, viewName;
	auto titleSymName, contentSymName, addJSObserver;
	auto argc;
	argc = ${{ arguments.length }}$;
	viewName = @;
	viewTitle = @;

	if (argc == 1) {
		obsName = p1;
	} else if (argc == 2) {
		obsName = p1;
		viewTitle = p2;
	} else if (argc == 3) {
		viewName = p1;
		obsName = p2;
		viewTitle = p3;
		if (!isString(viewName)) {
			error("createCanvas: The first argument must be a string, not a " // type(viewName));
			return;
		}
	} else {
		error("createCanvas: This procedure requires at least 1 argument and at most 3 arguments.");
		return;
	}

	
	
	if (isPointer(obsName)) {
		obsName = nameof(obsName);
	} else if (!isString(obsName)) {
		error("createCanvas: The observable name must be expressed as a string or a pointer, not a " // type(obsName));
		return;
	}

	if (viewName == @) {
		viewName = obsName;
	}
	
	if (viewTitle != @ && !isString(viewTitle)) {
		error("createCanvas: The window title must be a string, not a " // type(viewTitle));
		return;
	}

	if (`{obsName}` == @) {
		`{obsName}` = [];
	}

	createView(viewName, "Canvas2D");
	execute("view_" // viewName // "_content is " // obsName // ";");
	if (viewTitle == @) {
		# don't attempt to make this update by dependency on redefinition of _view_viewName_content.
		# Severe performance problems result.
		viewTitle = "Canvas " // obsName;
	}
	`view_{viewName}_title` = viewTitle;
}

/**
* Returns a string that can be used as the src attribute for an <img> tag inside the content of a
* HTML view.  The image with the special URL returned by this function is a snapshot of the contents
* of the canvas at the time this function was called.
* Optional parameter can be used to select which canvas should be used to take the snapshot.
* 
* @param [canvasName]
* 
*/
${{console.log("canvasURL");}}$;
func canvasURL {
	${{
		var canvasName;
		if (arguments.length > 1) {
			eden.error(new Error("canvasURL: This function requires at most one argument."), "error");
			return "";
		} else if (arguments.length == 0) {
			canvasName = "picture";
		} else {
			canvasName = arguments[0];
			if (canvasName === undefined) {
				return "";
			} else if (typeof(canvasName) == "string") {
				if (!(canvasName in canvases)) {
					return "";
				}
			} else {
				eden.error(new Error("canvasURL: The first argument must be a string, not a " + typeof(canvasName)), "error");
				return "";
			}
		}
		
		return canvases[canvasName].toDataURL();
	}}$;
}

/**
* Finds the topmost shape object at a given pair of canvas coordinates.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] Include in the search any shapes that do not have a mouse zone name set (N.B. the default is false!)
*/
func shapeOnTopAt {
	${{
		var target = arguments[0];
		var x, y, testAll;
		if (arguments.length < 2 || arguments.length > 4) {
			eden.error(new Error("shapeOnTopAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
			return undefined;
		}
		if (arguments[1] instanceof Point) {
			x = arguments[1].x;
			y = arguments[1].y;
			testAll = arguments[2];
		} else {
			x = arguments[1];
			y = arguments[2];
			testAll = arguments[3];
		}

		if (target === undefined || x === undefined || y === undefined) {
			return undefined;
		}
		if (target instanceof Symbol) {
			var match = target.name.match(/^\/_view_(.*)_content$/);
			if (match === null) {
				eden.error(new Error("shapeOnTopAt: The first argument must be either a string or a pointer to a _view_xxx_content observable, not " +
					Eden.edenCodeForValue(target)), "error");
				return undefined;
			} else {
				target = match[1];
			}
		} else if (typeof(target) != "string") {
			eden.error(new Error("shapeOnTopAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");		
			return undefined;
		}
		if (typeof(x) != "number") {
			eden.error(new Error("shapeOnTopAt: The x-coordinate must be a number, not a " + typeof(x)), "error");		
			return undefined;
		} else if (typeof(y) != "number") {
			eden.error(new Error("shapeOnTopAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
			return undefined;
		}
		return edenUI.plugins.Canvas2D.findDrawableHit(target, x, y, false, testAll);
	}}$;
}
${{console.log("shapeOnBottomAt");}}$;
/**
* Finds the bottommost shape object at a given pair of canvas coordinates.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] Include in the search any shapes that do not have a mouse zone name set (N.B. the default is false!)
*/
func shapeOnBottomAt {
	${{
		var target = arguments[0];
		var x, y, testAll;
		if (arguments.length < 2 || arguments.length > 4) {
			eden.error(new Error("shapeOnBottomAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
			return undefined;
		}
		if (arguments[1] instanceof Point) {
			x = arguments[1].x;
			y = arguments[1].y;
			testAll = arguments[2];
		} else {
			x = arguments[1];
			y = arguments[2];
			testAll = arguments[3];
		}

		if (target === undefined || x === undefined || y === undefined) {
			return undefined;
		}
		if (target instanceof Symbol) {
			var match = target.name.match(/^\/_view_(.*)_content$/);
			if (match === null) {
				eden.error(new Error("shapeOnBottomAt: The first argument must be either a string or a pointer to a _view_xxx_content observable, not " +
					Eden.edenCodeForValue(target)), "error");
				return undefined;
			} else {
				target = match[1];
			}
		} else if (typeof(target) != "string") {
			eden.error(new Error("shapeOnBottomAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");		
			return undefined;
		}
		if (typeof(x) != "number") {
			eden.error(new Error("shapeOnBottomAt: The x-coordinate must be a number, not a " + typeof(x)), "error");		
			return undefined;
		} else if (typeof(y) != "number") {
			eden.error(new Error("shapeOnBottomAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
			return undefined;
		}
		return edenUI.plugins.Canvas2D.findDrawableHit(target, x, y, true, testAll);
	}}$;
}

/**
* Finds the name of the mouse zone of the topmost shape at a given pair of canvas coordinates.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
*/
func zoneOnTopAt {
	auto drawable;
	drawable = apply(shapeOnTopAt, ${{ arguments }}$);
	if (drawable == @) {
		return @;
	} else {
		return drawable["name"];
	}
}

/**
* Finds the name of the mouse zone of the bottommost shape at a given pair of canvas coordinates.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
*/
func zoneOnBottomAt {
	auto drawable;
	drawable = apply(shapeOnBottomAt, ${{ arguments }}$);
	if (drawable == @) {
		return @;
	} else {
		return drawable["name"];
	}
}

/**
* Obtains the observable name associated with a given canvas shape (if there is one).
* @param shape
*/
func observableForShape {
	${{
		var drawable = arguments[0];
		if (drawable === undefined) {
			return undefined;
		} else if ("obsName" in drawable) {
			return drawable["obsName"];
		} else {
			return drawable["name"];
		}
	}}$;
}

/**
* Finds the observable name associated with the topmost shape at a given pair of canvas coordinates (if there is one).
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] Include in the search any shapes that do not have a mouse zone name set (N.B. the default is false!)
*/
func observableOnTopAt {
	auto drawable;
	drawable = apply(shapeOnTopAt, ${{ arguments }}$);
	return observableForShape(drawable);
}

/**
* Finds the observable name associated with the bottommost shape at a given pair of canvas coordinates (if there is one).
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] Include in the search any shapes that do not have a mouse zone name set (N.B. the default is false!)
*/
func observableOnBottomAt {
	auto drawable;
	drawable = apply(shapeOnBottomAt, ${{ arguments }}$);
	return observableForShape(drawable);
}

/**
* Finds all of the shape objects present at a given pair of canvas coordinates and returns them as a list.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] If false then only shapes which have a mouse zone name set are returned (N.B. the default is false!)
*/
func shapesAt {
	${{
		var target = arguments[0];
		var x, y, testAll;
		if (arguments.length < 2 || arguments.length > 4) {
			eden.error(new Error("shapesAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
			return undefined;
		}
		if (arguments[1] instanceof Point) {
			x = arguments[1].x;
			y = arguments[1].y;
			testAll = arguments[2];
		} else {
			x = arguments[1];
			y = arguments[2];
			testAll = arguments[3];
		}

		if (target === undefined || x === undefined || y === undefined) {
			return undefined;
		}
		if (target instanceof Symbol) {
			var match = target.name.match(/^\/_view_(.*)_content$/);
			if (match === null) {
				eden.error(new Error("shapesAt: The first argument must be either a string or a pointer to a _view_xxx_content observable, not " +
					Eden.edenCodeForValue(target)), "error");
				return undefined;
			} else {
				target = match[1];
			}
		} else if (typeof(target) != "string") {
			eden.error(new Error("shapesAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");		
			return undefined;
		}
		if (typeof(x) != "number") {
			eden.error(new Error("shapesAt: The x-coordinate must be a number, not a " + typeof(x)), "error");		
			return undefined;
		} else if (typeof(y) != "number") {
			eden.error(new Error("shapesAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
			return undefined;
		}
		return edenUI.plugins.Canvas2D.findAllDrawablesHit(target, x, y, testAll);
	}}$;
}

/**
* Finds all of the mouse zone names of the shapes intersecting at a given pair of canvas coordinates and returns them as a list.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
*/
func zonesAt {
	auto drawables, zones, i;
	drawables = apply(shapesAt, ${{ arguments }}$);
	zones = [];
	for (i = 1; i <= drawables#; i++) {
		append zones, drawables[i]["name"];
	}
	return zones;
}

/**
* Finds all of observable names associated with shapes intersecting at a given pair of canvas coordinates and returns them as a list.
* @param view_name_or_ptr_to_picture
* @param point_or_xy_argument_pair (two parameters in the latter case)
* @param [search_all] If false then only shapes which have a mouse zone name set are considered (N.B. the default is false!)
*/
func observablesAt {
	auto drawables, obsList, obsName, i;
	drawables = apply(shapesAt, ${{ arguments }}$);
	obsList = [];
	for (i = 1; i <= drawables#; i++) {
		obsName = observableForShape(drawables[i]);
		if (obsName != @) {
			append obsList, obsName;
		}
	}
	return obsList;
}


${{console.log("Got Here");}}$;
${{console.log("Got Here");}}$;
## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Checkbox = function (name, label, x, y, tristate, enabled) {
	this.name = name;
	this.obsName = root.currentObservableName();
	this.label = label;
	this.x = x;
	this.y = y;
	this.tristate = tristate;
    this.enabled = enabled;
}

Checkbox.prototype.hash = function () {
	return this.label+"$$"+
				this.name+"$$"+
				this.x+"$$"+
				this.y+"$$"+
				this.tristate+"$$"+
				this.enabled;
};
}}$;

#! Make a clickable checkbox on the canvas. Give it a name and then an observable `name_checked` is set to true of false.
#
# @param [name]
# @param label
# @param x x position
# @param y y position
# @param [tristate] If true, the checkbox will have three states; true, false, undefined. Defaults to false
# @param [enabled] Defaults to true.
#  #canvas #checkbox #tick #box #tickbox #check #form
func Checkbox {
${{
	var argsProcessed;

	var name;
	if (typeof(arguments[1]) == "string" || arguments[1] === undefined) {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("Checkbox: Every checkbox must have a name."), "error");
			return undefined;
		}
	}

	var label;
	if (typeof(arguments[argsProcessed]) == "string" || arguments[argsProcessed] === undefined) {
		label = arguments[argsProcessed];
		argsProcessed++;
	}

	var x = arguments[argsProcessed];
	var y = arguments[argsProcessed + 1];

	var tristate = arguments[argsProcessed + 2];
	if (tristate === undefined) tristate = false;

	var enabled = arguments[argsProcessed + 3];
	if (enabled === undefined) enabled = true;

	return new Checkbox(name, label, x, y, tristate, enabled);
}}$; }

${{

Checkbox.prototype.draw = function(context) {

	if (this.elements === undefined) {
		var me = this;
		var name = this.name;

		var inputJQ = $('<input type="checkbox"/>');
		var inputElement = inputJQ.get(0);
		var element, elementJQ;
		if (this.label === undefined) {
			element = inputElement;
			elementJQ = inputJQ;
		} else {
			var labelJQ = $('<label> ' + this.label + '</label>');
			labelJQ.prepend(inputJQ);
			element = labelJQ.get(0);
			elementJQ = labelJQ;
		}
		element.className = "canvashtml-item";

		inputElement.disabled = (this.enabled === false);
		
		var valueSym = root.lookup(name + "_checked");
		var value = valueSym.value();
		if (value === undefined) {
			if (this.tristate) {
				inputElement.indeterminate = true;
			} else {
				valueSym.assign(false, root.scope, root.lookup("Checkbox"));
			}
		} else {
			inputElement.checked = value;
		}
		valueSym.addJSObserver("updateCheckbox", function (obs, value) {
			var element = me.elements[0];
			if (value === undefined) {
				element.indeterminate = true;
				element.checked = false;
			} else {
				element.indeterminate = false;
				element.checked = (value == true);
			}
		});

		inputJQ.change(function (event) {
			var element = event.target;
			var value;
			if (element.indeterminate) {
				element.indeterminate = false;
				element.checked = true;
				value = true;
			} else if (me.tristate && valueSym.value() === false) {
				element.indeterminate = true;
				element.checked = false;
				value = undefined;
			} else {
				value = element.checked;
			}
			valueSym.assign(value, root.scope, EdenSymbol.hciAgent, true);
		})

		elementJQ.on("mousedown", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseDownZone").assign(undefined, root.scope, EdenSymbol.hciAgent, mouseFollow);
		})
		.on("mouseup", function () {
			edenUI.plugins.Canvas2D.endClick();
		})
		.on("mouseenter", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		});

		this.elements = [element];
	}
};

Checkbox.prototype.scale = function (scale, zoom, origin) {
	var outerElement = this.elements[0];
	var inputElement;
	if (outerElement.tagName.toLowerCase() == "label") {
		inputElement = outerElement.children[0];
	} else {
		inputElement = outerElement;
	}
	var outerStyle = outerElement.style;
	var inputStyle = inputElement.style;

	outerStyle.left = Math.round((this.x + origin.x) * scale) + "px";
	outerStyle.top =  Math.round((this.y + origin.y) * scale) + "px";

	var checkboxSize = Math.round(13 * zoom) + "px";
	inputStyle.width = checkboxSize;
	inputStyle.height = checkboxSize;
};

Checkbox.prototype.toString = function() {
	if (this.name == this.obsName) {
		return "Checkbox(" + Eden.edenCodeForValues(this.x, this.y, this.tristate, this.enabled) + ")";
	} else {
		return "Checkbox(" + Eden.edenCodeForValues(this.name, this.x, this.y, this.tristate, this.enabled) + ")";	
	}
};

Checkbox.prototype.getEdenCode = Checkbox.prototype.toString;

}}$;

${{console.log("Got Here");}}$;
## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Circle = function(x, y, radius, fillcolour, outlinecolour, drawingOptions) {
	this.x = x;
	this.y = y;
	this.radius = radius;
	if (fillcolour === undefined && outlinecolour === undefined) {
		this.fillcolour = undefined;
		this.outlinecolour = "black";
	} else {
		this.fillcolour = fillcolour;
		this.outlinecolour = outlinecolour;
	}
	this.drawingOptions = drawingOptions;
	this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Circle");
	this.obsName = root.currentObservableName();
}
}}$;

#! Creates a circle. See [drawing options](@external CanvasExamples > drawingoptions) for more styling options.
#
# ##Usage Example
#  `Circle(x, y, radius, "purple");`
#  `Circle(x, y, radius, "green", "red");`
# 
# @param x x position of center of the circle
# @param y y position of center of the circle
# @param radius radius of the circle
# @param [fillColour]
# @param [outlineColour] defaults to black
# @param [drawingOptions] object of drawingOptions
# 
#  #canvas #circle #shape #draw #library
func Circle {
${{
	var x = arguments[0];
	var y = arguments[1];
	var radius = arguments[2];
	var fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 3) {
		fillcolour = arguments[3];
		if (processUpTo == 4) {
			outlinecolour = arguments[4];
		}
	}
	if (fillcolour === undefined && outlinecolour === undefined) {
		outlinecolour = "black";
	}
	return new Circle(x, y, radius, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

Circle.prototype.draw = function (context, scale) {
	if (this.radius > 0) {

		this.tracePath(context, scale);
		if (this.fillcolour !== undefined) {
			edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
			context.fill();
		}
		if (this.outlinecolour !== undefined) {
			context.strokeStyle = this.outlinecolour;
			context.stroke();
		}

	}
};

Circle.prototype.tracePath = function (context, scale) {
	var halfLineWidth;
	if (this.outlinecolour !== undefined) {
		halfLineWidth = context.lineWidth / 2;
	} else {
		halfLineWidth = 0;
	}

	var adjustedRadius;
	if (this.radius <= halfLineWidth) {
		context.lineWidth = this.radius;
		adjustedRadius = this.radius / 2;
	} else {
		adjustedRadius = this.radius - halfLineWidth;
	}
	context.beginPath();
	context.arc(this.x, this.y, adjustedRadius, 0, 2 * Math.PI, false);
	context.closePath();
}

Circle.prototype.isHit = function (context, scale, x, y) {
	this.tracePath(context, scale);
	return context.isPointInPath(x,y);
}

Circle.prototype.toString = function(p) {
	var s = "Circle(" + Eden.edenCodeForValuesP(p, this.x, this.y, this.radius, this.fillcolour, this.outlinecolour);
	
	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
};

Circle.prototype.getEdenCode = Circle.prototype.toString;

Circle.prototype.imageMapArea = function () {
	return "shape=\"circle\" coords=\"" + this.x + "," + this.y + "," + this.radius + "\"";
}

Circle.prototype.centre = function () {
	return new Point(this.x, this.y);
}

}}$;

${{console.log("Got Here");}}$;
## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Combobox = function (name, suggestions, x, y, width, placeholder, maxlength, enabled) {
	this.name = name;
	this.obsName = root.currentObservableName();
	this.suggestions = suggestions;
	this.x = x;
	this.y = y;
	this.width = width;
	this.placeholder = placeholder;
	this.maxlength = maxlength;
	this.enabled = enabled;
}

Combobox.prototype.hash = function () {
	return this.name+"$$"+
				(Array.isArray(this.suggestions)? this.suggestions.join("$$") : "") +
				this.x+"$$"+
				this.y+"$$"+
				this.width+"$$"+
				this.placeholder+"$$"+
				this.maxlength+"$$"+
				this.enabled;
};

}}$;

/**
 * Creates a Combobox (drop down selection)
 * @param [name] defaults to the observable name
 * @param suggestions list of strings to be suggested
 * @param x
 * @param y
 * @param [width]
 * @param [placeholder] string to display before choice is made. Defaults to observable name.
 * @param [maxlength] Maximum length allowed in input
 * @param [enabled] defaults to true.
 * 
 * #canvas #combobox #input #select
 */

func Combobox { ${{
	var argsProcessed;

	var name;
	if (typeof(arguments[0]) == "string") {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("Combobox: Every combobox must have a name."), "error");
			return undefined;
		}
	}

	var suggestions = arguments[argsProcessed];
	argsProcessed++;
	var x = arguments[argsProcessed];
	argsProcessed++;
	var y = arguments[argsProcessed];
	argsProcessed++;
	var width, placeholder, maxlength;

	var arg = arguments[argsProcessed];
	var argType = typeof(arg);
	if (arg === undefined || argType == "number") {
		width = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}
	if (arg === undefined || argType == "string") {
		placeholder = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}
	if (arg === undefined || argType == "number") {
		maxlength = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
	}
	var enabled = arg;

	return new Combobox(name, suggestions, x, y, width, placeholder, maxlength, enabled);
}}$; }


${{

Combobox.prototype.makeOptionsHTML = function() {
	var html = "";
	for (var i = 0; i < this.suggestions.length; i++) {
		html = html + '\n<option value="' + this.suggestions[i] + '"/>';
	}
	return html;
}

Combobox.prototype.draw = function(context) {
	var input, suggestions;
	var me = this;
	var name = this.name;
	var valueSym = root.lookup(name + '_value');

	if (this.elements === undefined) {

		var disabled = this.enabled === false? 'disabled="disabled"' : '';
		var placeholder = ' placeholder="' + (this.placeholder === undefined? name : this.placeholder) + '"';
		var maxlength = this.maxlength !== undefined? ' maxlength="' + this.maxlength + '"' : '';
		var inputJQ = $('<input type="text" list="combobox-' + name + '" ' + disabled +
			placeholder + maxlength + ' class="canvashtml-item"/>');

		input = inputJQ.get(0);
		var suggestionsJQ = $('<datalist id="combobox-' + this.name + '"></datalist>');
		suggestions = suggestionsJQ.get(0);
		suggestionsJQ.html(this.makeOptionsHTML(this.values));

		var initialValue = valueSym.value();
		if (initialValue !== undefined) {
			input.value = initialValue;
		}
		valueSym.addJSObserver("updateCombobox", function (symbol, value) {
			input.value = value;
		});

		inputJQ.on("input", function(event) {
			valueSym.assign(event.target.value, root.scope, EdenSymbol.hciAgent, true);
		})
		.on("mousedown", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseDownZone").assign(undefined, root.scope, EdenSymbol.hciAgent, mouseFollow);
		})
		.on("mouseup", function () {
			edenUI.plugins.Canvas2D.endClick();
		})
		.on("mouseenter", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		});

		this.elements = [input, suggestions];

	} else {

		//Case when the user has performed direct assignment to one or more JavaScript properties.
		input = this.elements[0];
		suggestions = this.elements[1];
		$(suggestions).html(this.makeOptionsHTML());

		input.value = valueSym.value();

		if (this.enabled === false) { 
			input.disabled = true;
		} else {
			input.disabled = false;
		}

	}
};

Combobox.prototype.scale = function (scale, zoom, origin) {
	var style = this.elements[0].style;
	style.left = Math.round((this.x + origin.x) * scale) + "px";
	style.top =  Math.round((this.y + origin.y) * scale) + "px";
	if (this.width !== undefined) {
		style.width = Math.round(this.width * scale - 6) + "px";
	}
	style.fontSize = zoom + "em";
};

Combobox.prototype.toString = function() {
	if (this.name == this.obsName) {
		return "Combobox(" + Eden.edenCodeForValues(this.suggestions, this.x, this.y, this.enabled) + ")";
	} else {
		return "Combobox(" + Eden.edenCodeForValues(this.name, this.suggestions, this.x, this.y,
			this.maxlength, this.enabled) + ")";
	}
};

Combobox.prototype.getEdenCode = Combobox.prototype.toString;

}}$;

${{console.log("Before EuclideanSpace");}}$;

/**
 * Creates a EuclideanSpace object
 * @param xMin
 * @param yMin
 * @param [zMin]
 * @param xMax
 * @param yMax
 * @param [zMax]
 * #euclideanspace #contour
 */
func EuclideanSpace {
	${{
		var xMin, yMin, zMin, xMax, yMax, zMax;
		if (arguments.length > 4) {
			xMin = arguments[0];
			yMin = arguments[1];
			zMin = arguments[2];
			xMax = arguments[3];
			yMax = arguments[4];
			zMax = arguments[5];
		} else {
			xMin = arguments[0];
			yMin = arguments[1];
			xMax = arguments[2];
			yMax = arguments[3];
		}
		return new EuclideanSpace(xMin, yMin, zMin, xMax, yMax, zMax);
	}}$;
}

/**
 * 
 * Creates object to hold Scalar Field values
 * For more details, please see: 
 * <a target="_blank" href="http://jseden.dcs.warwick.ac.uk/latest-master/index-dev.html?import=plugins/canvas/contourLine/guide">Contour Line Guide</a>
 * @param dataPtr
 * @param space
 * @param numX
 * @param numY
 * @param [tmin
 * @param [tmax]]
 * #scalarfield #contour
 */

func ScalarField2D {
	${{
		var dataPtr = arguments[0];
		var space = arguments[1];
		var numX = arguments[2];
		var numY = arguments[3];

		var tMin, tMax, numT, existsBefore, existsAfter;
		var numArgs = arguments.length;
		var argsProcessed;

		if (numArgs > 5) {
			tMin = arguments[4];
			tMax = arguments[5];
			argsProcessed = 6;
			if (numArgs == 9 || typeof(arguments[argsProcessed]) == "number") {
				numT = arguments[6];
				argsProcessed++;
			} else if (tMin === undefined || tMax === undefined || tMin === tMax) {
				numT = 1;
			} else {
				numT = 2;
			}
			existsBefore = numArgs > argsProcessed? arguments[argsProcessed] : tMin === undefined;
			argsProcessed++;
			existsAfter = numArgs > argsProcessed? arguments[argsProcessed] : tMax === undefined;
		} else if (numArgs > 4) {
			tMin = arguments[4];
			tMax = tMin;
			numT = 1;
			existsBefore = true;
			existsAfter = true;
		}

		var dataSource = dataPtr instanceof Symbol? dataPtr.value() : undefined;

		if (Array.isArray(dataSource)) {
			return new Explicit2DScalarField(dataPtr, space, numX, numY, tMin, tMax, numT, existsBefore, existsAfter);
		} else if (tMin === undefined || tMax === undefined || tMin === tMax || numT === 1) {
			return new Static2DScalarField(dataPtr, space, numX, numY, tMin, tMax, numT, existsBefore, existsAfter);
		} else {
			return new KeyFrame2DScalarField(dataPtr, space, numX, numY, tMin, tMax, numT, existsBefore, existsAfter);
		}
	}}$;
}

/**
 * 
 * Applies a threshold and traces the outline of a shape.
 * For more details, please see: 
 * <a target="_blank" href="http://jseden.dcs.warwick.ac.uk/latest-master/index-dev.html?import=plugins/canvas/contourLine/guide">Contour Line Guide</a>
 * @param scalar_field_2d ScalarField object providing the function values
 * @param [iso_value The threshold value that determines which function values fall inside the boundary of the shape
 * @param [time_value]] The time instant at which to evaluate the function.  May be omitted if the function is time invariant.
 *
 * #contour
 */

func ContourData {
	${{
		var field = arguments[0];
		var isoValue = arguments[1];
		if (isoValue === undefined) {
			isoValue = 0;
		}
		var t = arguments[2];
		return new ContourData(field, isoValue, t);
	}}$;
}

/**
 * Creates a contoured shape object with size, position, colour, etc. from the mathematical description (ContourData).
 * For more details, please see: 
 * <a target="_blank" href="http://jseden.dcs.warwick.ac.uk/latest-master/index-dev.html?import=plugins/canvas/contourLine/guide">Contour Line Guide</a>
 * 
 * @param x
 * @param y
 * @param width
 * @param height
 * @param contour_data A contourData object
 * @param [fill_colour
 * @param [outline_colour]]
 * @param [drawing_options] A drawingOptions object
 * 
 * #canvas #contour #line #drawingOptions
 * 
 */
func ContourLine {
	${{
		var x = arguments[0];
		var y = arguments[1];
		var width = arguments[2];
		var height = arguments[3];
		var line = arguments[4];

		var fillcolour, outlinecolour, drawingOptions;
		var lastArg = arguments[arguments.length - 1];
		var processUpTo;
		if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
			drawingOptions = lastArg;
			processUpTo = arguments.length - 2;
		} else {
			processUpTo = arguments.length - 1;
		}
		if (processUpTo >= 5) {
			fillcolour = arguments[5];
			if (processUpTo == 6) {
				outlinecolour = arguments[6];
			}
		}
		if (fillcolour === undefined && outlinecolour === undefined) {
			outlinecolour = "black";
		}
		return new ContourLine(x, y, width, height, line, fillcolour, outlinecolour, drawingOptions);
	}}$;
}

${{
	Curve = function (x1, y1, x2, y2, r, elasticity, theta1, theta2, mid, overshoot, dirSwitch, colours, drawingOptions) {
		this.x1 = x1;
		this.y1 = y1;
		this.x2 = x2;
		this.y2 = y2;
		this.r = r;
		this.elasticity = elasticity;
		this.theta1 = theta1;
		this.theta2 = theta2;
		this.mid = mid;
		this.overshoot = overshoot;
		this.dirSwitch = dirSwitch;
		this.colours = colours;
		this.drawingOptions = drawingOptions;

		elasticity = elasticity * 0.94;
		var xDistance = x2 - x1;
		var yDistance = y2 - y1;
		this.theta3 = Math.atan2(yDistance, xDistance);
		this.fullLength = Math.sqrt(xDistance * xDistance + yDistance * yDistance);
		this.length1 = mid * this.fullLength;
		var length2 = this.fullLength - this.length1;

		var radiansPerUnit = Math.PI / root.lookup("semicircleAngle").value();
		this.delta1 = elasticity * this.length1;
		this.delta2 = elasticity * length2;
		var fullTurn = 2 * Math.PI;

		if (theta1 === undefined) {
			this.deltaX1 = 0;
			this.deltaY1 = 0;
		} else {
			var theta1Normalized = (theta1 * radiansPerUnit) % fullTurn;
			if (theta1Normalized < 0) {
				theta1Normalized = theta1Normalized + fullTurn;
			}
			var tanTheta1 = Math.abs(Math.tan(theta1Normalized));

			if (theta1Normalized > fullTurn/4 && theta1Normalized <= fullTurn * 3/4) {
				this.deltaX1 = -overshoot;
			} else {
				this.deltaX1 = Math.abs(this.length1 - this.delta1);
			}

			this.deltaY1 = Math.abs(this.deltaX1) * tanTheta1;
			if (theta1Normalized > fullTurn/2) {
				this.deltaY1 = -this.deltaY1;
			} else if (this.deltaY1 > r) {
				this.deltaY1 = r;
				this.deltaX1 = r / tanTheta1;
			}
		}

		if (theta2 === undefined) {
			this.deltaX2 = 0;
			this.deltaY2 = 0;
		} else {
			var theta2Normalized = (theta2 * radiansPerUnit) % fullTurn;
			if (theta2Normalized < 0) {
				theta2Normalized = theta2Normalized + fullTurn;
			}
			var tanTheta2 = Math.abs(Math.tan(theta2Normalized));

			if (theta2Normalized > fullTurn/4 && theta2Normalized <= fullTurn * 3/4) {
				this.deltaX2 = -overshoot;
			} else {
				this.deltaX2 = Math.abs(length2 - this.delta2);
			}

			this.deltaY2 = Math.abs(this.deltaX2) * tanTheta2;
			if (theta2Normalized > fullTurn/2) {
				this.deltaY2 = -this.deltaY2;
			} else if (this.deltaY2 > r) {
				this.deltaY2 = r;
				this.deltaX2 = r / tanTheta2;
			}
		}

		if (dirSwitch) {
			this.radius = -r;
			this.deltaY1 = -this.deltaY1;
			this.deltaY2 = -this.deltaY2;
		} else {
			this.radius = r;
		}
	}

}}$;

/**
 * Create a Curve
 * 
 * @param x1
 * @param y1
 * @param x2
 * @param y2
 * @param radius
 * @param curviness
 * @param [start_angle
 * @param [end_angle
 * @param [skew Between 0 and 1
 * @param [overshoot]]]]
 * @param [is_flipped]
 * @param [colour(s)]
 * @param [drawing_options]
 * 
 * #canvas #curve #drawingOptions
 */

func Curve {
	${{
		var x1 = arguments[0];
		var y1 = arguments[1];
		var x2 = arguments[2];
		var y2 = arguments[3];
		var r = arguments[4];
		var elasticity = arguments[5];

		var direction, theta1, theta2, mid = 0.5, overshoot = 150, direction, colours, drawingOptions;
		var lastArg = arguments[arguments.length - 1];
		var processUpTo;
		if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg)) {
			drawingOptions = lastArg;
			processUpTo = arguments.length - 2;
			lastArg = arguments[processUpTo];
		} else {
			processUpTo = arguments.length - 1;
		}
		if (typeof(lastArg) == "string") {
			colours = [lastArg];
			processUpTo--;
		} else if (Array.isArray(lastArg)) {
			colours = lastArg;
			processUpTo--;
		} else {
			colours = ["black"];
		}
		lastArg = arguments[processUpTo];
		if (typeof(lastArg) == "boolean") {
			direction = lastArg;
			processUpTo--;
		}
		if (processUpTo > 5) {
			theta1 = arguments[6];
			if (processUpTo > 6) {
				theta2 = arguments[7];
				if (processUpTo > 7) {
					mid = arguments[8];
					if (processUpTo > 8) {
						overshoot = arguments[9];
					}
				}
			} else {
				theta2 = theta1;
			}
		}
		return new Curve(x1, y1, x2, y2, r, elasticity, theta1, theta2, mid, overshoot, direction, colours, drawingOptions);
	}}$;
}
semicircleAngle ~> [Curve];

${{
	Curve.prototype.draw = function (context, scale) {
		if (this.colours.length == 1) {
			context.strokeStyle = this.colours[0];
		} else {
			var gradient = context.createLinearGradient(0, 0, this.fullLength, 0);
			for (var i = 0; i < this.colours.length; i++) {
				gradient.addColorStop(i / (this.colours.length - 1), this.colours[i]);
			}
			context.strokeStyle = gradient;
		}

		context.translate(this.x1, this.y1);
		context.rotate(this.theta3);
		context.beginPath();
		context.moveTo(0, 0);
		context.bezierCurveTo(this.deltaX1, this.deltaY1, this.length1 - this.delta1, this.radius, this.length1, this.radius);
		context.bezierCurveTo(this.length1 + this.delta2, this.radius, this.fullLength - this.deltaX2, this.deltaY2, this.fullLength, 0);
		context.stroke();

		if (this.drawingOptions !== undefined && this.drawingOptions.arrowhead instanceof Arrowhead) {
			var gradient1, gradient2, t, x1, y1;
			if (this.deltaX1 == 0 && this.deltaY1 == 0) {
				t = 0.01;
				x1 = 3 * (1 - t) * t * t * (this.length1 - this.delta1) + t * t * t * this.length1;
				y1 = 3 * (1 - t) * t * t * this.radius + t * t * t * this.radius;
				gradient1 = y1 / x1;
			} else {
				gradient1 = this.deltaY1 / this.deltaX1;
			}
			if (this.deltaX2 == 0 && this.deltaY2 == 0) {
				t = 0.99;
				x1 = (1 - t) * (1 - t) * (1 - t) * this.length1 +
					3 * (1 - t) * (1 - t) * t * (this.length1 + this.delta2) +
					3 * (1 - t) * t * t * this.fullLength +
					t * t * t * this.fullLength;
				y1 = (1 - t) * (1 - t) * (1 - t) * this.radius + 3 * (1 - t) * (1 - t) * t * this.radius;
				gradient2 = -y1 / (this.fullLength - x1);
			} else {
				gradient2 = -this.deltaY2 / this.deltaX2;
			}
			this.drawingOptions.arrowhead.draw(context, scale, 0, 0, gradient1, false, this.fullLength, 0, gradient2, false);
		}
	};

	Curve.prototype.toString = function () {
		return "Curve(" + Eden.edenCodeForValues(this.x1, this.y1, this.x2, this.y2, this.r, this.elasticity, this.theta1, this.theta2, this.mid, this.overshoot, this.dirSwitch, this.colours, this.drawingOptions) + ")";
	}
	
	Curve.prototype.getEdenCode = Curve.prototype.toString;
}}$;


${{console.log("DropDownList");}}$;
## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
DropDownList = function (name, values, labels, x, y, enabled) {
	this.name = name;
	this.obsName = root.currentObservableName();
	this.values = values;
	this.labels = labels;
	this.x = x;
	this.y = y;
	this.enabled = enabled;
}

DropDownList.prototype.hash = function () {
	return this.name+"$$"+
				(Array.isArray(this.values)? this.values.join("$$") : "") +
				(Array.isArray(this.labels)? this.labels.join("$$") : "") +
				this.x+"$$"+
				this.y+"$$"+
				this.enabled;
};

}}$;


/**
 * Creates a DropDown list, allowing for the selection
 * @param [name] Prefix for _value observable. Default is the name of the observable being defined.
 * @param values A list of options
 * @param [labels] A list of labels to display, if not supplied, the list of values will be used
 * @param x X-coordinate
 * @param y Y-coordinate
 * @param [enabled] Boolean to determine if list selection is enabled
 * #canvas #dropdown #input #select
 */
func DropDownList { ${{
	var argsProcesed;

	var name;
	if (typeof(arguments[0]) == "string") {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("DropDownList: Every DropDownList must have a name."), "error");
			return undefined;
		}
	}

	var values = arguments[argsProcessed];
	argsProcessed++;
	var labels;
	if (Array.isArray(arguments[argsProcessed])) {
		labels = arguments[argsProcessed];
		argsProcessed++;
	} else {
		labels = values;
	}
	var x = arguments[argsProcessed];
	argsProcessed++;
	var y = arguments[argsProcessed];
	argsProcessed++;
	var enabled = arguments[argsProcessed];

	return new DropDownList(name, values, labels, x, y, enabled);
}}$; }


${{

DropDownList.prototype.makeOptionsHTML = function() {
	var html = "";
	for (var i = 0; i < this.values.length; i++) {
		html = html + '\n<option value="' + this.values[i] + '">' + this.labels[i] + '</option>';
	}
	return html;
}

DropDownList.prototype.draw = function(context) {
	var dropDownList;
	var me = this;
	var name = this.name;
	var valueSym = root.lookup(name + '_value');

	if (this.elements === undefined) {

		var disabled = this.enabled === false? 'disabled="disabled"' : '';
		var dropDownListJQ = $('<select ' + disabled + ' class="canvashtml-item"></select>');
		dropDownListJQ.html(this.makeOptionsHTML(this.values));

		dropDownList = dropDownListJQ.get(0);
		var initialValue = valueSym.value();
		if (initialValue === undefined) {
			valueSym.assign(me.values[0], root.scope, root.lookup("DropDownList"), true);
		} else {
			dropDownList.value = initialValue;
		}
		valueSym.addJSObserver("updateDropDownList", function (symbol, value) {
			dropDownList.value = value;
		});

		dropDownListJQ.change(function(event) {
			valueSym.assign(event.target.value, root.scope, EdenSymbol.hciAgent, true);
		})
		.on("mousedown", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseDownZone").assign(undefined, root.scope, EdenSymbol.hciAgent, mouseFollow);
		})
		.on("mouseup", function () {
			edenUI.plugins.Canvas2D.endClick();
		})
		.on("mouseenter", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		});

		this.elements = [dropDownList];

	} else {

		//Case when the user has performed direct assignment to one or more JavaScript properties.
		dropDownList = this.elements[0];
		$(dropDownList).html(this.makeOptionsHTML());

		dropDownList.value = valueSym.value();

		if (this.enabled === false) { 
			dropDownList.disabled = true;
		} else {
			dropDownList.disabled = false;
		}

	}
};

DropDownList.prototype.scale = function (scale, zoom, origin) {
	var style = this.elements[0].style;
	style.left = Math.round((this.x + origin.x) * scale) + "px";
	style.top =  Math.round((this.y + origin.y) * scale) + "px";
	style.fontSize = zoom + "em";
};

DropDownList.prototype.toString = function() {
	if (this.name == this.obsName) {
		return "DropDownList(" + Eden.edenCodeForValues(this.values, this.labels, this.x,
			this.y, this.enabled) + ")";
	} else {
		return "DropDownList(" + Eden.edenCodeForValues(this.name, this.values, this.labels, this.x,
			this.y, this.enabled) + ")";
	}
};

DropDownList.prototype.getEdenCode = DropDownList.prototype.toString;

}}$;

${{console.log("Ellipse");}}$;
## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Ellipse = function(x, y, xradius, yradius, fillcolour, outlinecolour, drawingOptions) {
	this.x = x;
	this.y = y;
	this.xradius = xradius;
	this.yradius = yradius;
	this.fillcolour = fillcolour;
	this.outlinecolour = outlinecolour;
	this.drawingOptions = drawingOptions;
	this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Ellipse");
	this.obsName = root.currentObservableName();
}
}}$;

/**
 * Create an Ellipse
 * 
 * @param x Centre X-coordinate
 * @param y Centre Y-coordinate
 * @param x_radius Ellipse x-axis radius from centre
 * @param y_radius Ellipse y-axis radius from centre
 * @param [fill_colour Fill colour for the ellipse on the canvas
 * @param [outline_colour]] Outline colour of the ellipse on the canvas
 * @param [drawing_options] A drawingOptions object
 * 
 * #canvas #ellipse #drawingOptions
 */

func Ellipse { ${{
	var x = arguments[0];
	var y = arguments[1];
	var xradius = arguments[2];
	var yradius = arguments[3];
	var fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 4) {
		fillcolour = arguments[4];
		if (processUpTo == 5) {
			outlinecolour = arguments[5];
		}
	}

	if (fillcolour === undefined && outlinecolour === undefined) {
		outlinecolour = "black";
	}
	return new Ellipse(x, y, xradius, yradius, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

Ellipse.prototype.draw = function (context) {
	if (this.xradius > 0 && this.yradius > 0) {

		var scaleOutline;
		if (this.outlinecolour === undefined || this.outlinecolour == "transparent") {
			scaleOutline = false;
		} else if (this.drawingOptions === undefined || !("scaleOutline" in this.drawingOptions)) {
			scaleOutline = (this.fillcolour !== undefined && this.fillcolour != "transparent");
		} else {
			scaleOutline = this.drawingOptions.scaleOutline;
		}
		if (!scaleOutline) {
			context.save();
		}

		var lineWidth = this.tracePath(context, scaleOutline);

		if (this.fillcolour !== undefined) {
			edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
			context.fill();
		}

		if (!scaleOutline) {
			context.restore();
			context.lineWidth = lineWidth;
		}
		if (this.outlinecolour !== undefined) {
			context.strokeStyle = this.outlinecolour;
			context.stroke();
		}

	}
};

Ellipse.prototype.tracePath = function (context, scaleOutline) {
	var scaleFactor = this.yradius / this.xradius;
	var lineWidth;
	if (this.outlinecolour !== undefined && this.outlinecolour != "transparent") {
		if (scaleOutline) {
			lineWidth = context.lineWidth;
		} else {
			lineWidth = context.lineWidth / scaleFactor;
		}
	} else {
		lineWidth = 0;
	}

	var adjustedXRadius;
	//Not sure what to do when xradius is bigger than 1/2 line width but less than line width, but it isn't correct atm.
	if (this.xradius <= context.lineWidth / 2) {
		lineWidth = this.xradius;
		context.lineWidth = lineWidth;
		adjustedXRadius = this.xradius / 2;
	} else {
		adjustedXRadius = this.xradius - lineWidth / 2;
	}
	context.scale(1, scaleFactor);
	context.beginPath();
	context.arc(this.x, this.y / scaleFactor, adjustedXRadius, 0, 2 * Math.PI, false);
	context.closePath();
	return lineWidth;
}

Ellipse.prototype.isHit = function (context, scale, x, y) {
	this.tracePath(context, false);
	return context.isPointInPath(x,y);
}

Ellipse.prototype.toString = function() {
	var s = "Ellipse(" + Eden.edenCodeForValues(this.x, this.y, this.xradius, this.yradius, this.fillcolour, this.outlinecolour);
	
	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
};

Ellipse.prototype.getEdenCode = Ellipse.prototype.toString;

}}$;

${{console.log("Got Here");}}$;
## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

##Taints the canvas if the file is located on another domain.

${{
FillPattern = function (url) {
	this.image = new Image();
	this.canvasesToRepaint = {};
	this.loaded = false;
	
	var me = this;
	
	this.image.onload = function(){
		me.loaded = true;
		for (var viewName in me.canvasesToRepaint) {
			edenUI.plugins.Canvas2D.drawPicture(viewName);
		}
	}
	this.image.src = url;
};
}}$;

/**
 * Create FillPattern object based on an image
 * @param url URL of the image
 */

func FillPattern {
	${{
		return new FillPattern(arguments[0]);
	}}$;
}

${{
	FillPattern.prototype = new EdenUI.plugins.Canvas2D.FillStyle();
	
	FillPattern.prototype.getColour = function (context) {
		return context.createPattern(this.image, 'repeat');
	}

	FillPattern.prototype.toString = function() {
		return "FillPattern(\"" + this.image.src + "\")";
	}

	FillPattern.prototype.getEdenCode = FillPattern.prototype.toString;

}}$;

## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
	console.log("Before Line");
Line = function(x1, y1, x2, y2, colours, drawingOptions) {
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	var align, valign, shift;
	if (drawingOptions !== undefined) {
		align = drawingOptions.align;
		valign = drawingOptions.valign;
	}
	if (this.x1 == this.x2) {
		if (align == "left") {
			shift = -1;
		} else if (align == "right") {
			shift = 1;
		} else {
			shift = 0;
		}
		this.xShift1 = shift;
		this.xShift2 = shift;
		this.yShift1 = 0;
		this.yShift2 = 0;
	} else if (this.y1 == this.y2) {
		if (valign == "top") {
			shift = -1;
		} else if (valign == "bottom") {
			shift = 1;
		} else {
			shift = 0;
		}
		this.xShift1 = 0;
		this.xShift2 = 0;
		this.yShift1 = shift;
		this.yShift2 = shift;
	} else {
		this.xShift1 = this.x2 > this.x1? 1 : -1;
		this.xShift2 = -this.xShift1;
		this.yShift1 = this.y2 > this.y1? 1 : -1;
		this.yShift2 = -this.yShift1;
	}
	this.colours = colours;
	this.drawingOptions = drawingOptions;
}
}}$;

#! Create a drawable line for display on the canvas. See [drawing options](@external CanvasExamples > drawingoptions) for more styling options.
#
# ##Usage Example
#  `Line(startx, starty, endx, endy, "green");`
#  `Line(x1,y1,x2,y2,"red",Object("lineWidth", 10));`
#
# @param x1 Start x-position
# @param y1 Start y-position
# @param x2 End x-position
# @param y2 End y-position
# @param [colour(s)] A HTML colour value for the whole line or a list of HTML colour values to create a gradient
# @param [drawing_options] list of drawing options
# 
#  #canvas #line #drawingoptions #draw
func Line {
${{
	var x1 = arguments[0];
	var y1 = arguments[1];
	var x2 = arguments[2];
	var y2 = arguments[3];
	var colours, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 4) {
		colours = arguments[4];
	}

	if (colours === undefined) {
		colours = ["black"];
	} else if (!Array.isArray(colours)) {
		colours = [colours];
	} else if (colours.length == 0) {
		colours = ["black"];
	}
	return new Line(x1, y1, x2, y2, colours, drawingOptions);
}}$; };

${{

Line.prototype.draw = function(context, scale) {
	context.beginPath();
	var xShift1, xShift2, yShift1, yShift2;
	if (this.drawingOptions !== undefined) {
		var width = (context.lineWidth / 2 + 0.5 / scale) / Math.SQRT2;
		xShift1 = this.xShift1 * width;
		xShift2 = this.xShift2 * width;
		yShift1 = this.yShift1 * width;
		yShift2 = this.yShift2 * width;
		if ((this.xShift1 == 0 || this.yShift1 == 0) && this.drawingOptions.lineWidth % 2 == 1) {
			context.translate(0.5 / scale, 0.5 / scale);
		}
	} else {
		xShift1 = 0;
		xShift2 = 0;
		yShift1 = 0;
		yShift2 = 0;
	}
	var x1 = this.x1 + xShift1;
	var y1 = this.y1 + yShift1;
	var x2 = this.x2 + xShift2;
	var y2 = this.y2 + yShift2;

	if (this.colours.length == 1) {
		context.strokeStyle = this.colours[0];
	} else {
		var colourGradient = context.createLinearGradient(x1, y1, x2, y2);
		for (var i = 0; i < this.colours.length; i++) {
			colourGradient.addColorStop(i / (this.colours.length - 1), this.colours[i]);
		}
		context.strokeStyle = colourGradient;
	}

	context.moveTo(x1, y1);
	context.lineTo(x2, y2);
	context.stroke();

	if (this.drawingOptions !== undefined && this.drawingOptions.arrowhead instanceof Arrowhead) {
		var gradient = (y2 - y1) / (x2 - x1);
		var reversed = x1 > x2;
		this.drawingOptions.arrowhead.draw(context, scale, x1, y1, gradient, reversed, x2, y2, gradient, reversed);
	}
};

Line.prototype.toString = function(p) {
	var s = "Line(" + Eden.edenCodeForValuesP(p,this.x1, this.y1, this.x2, this.y2) + ", ";

	if (this.colours.length > 1) {
		s = s + Eden.edenCodeForValue(this.colours, undefined, p);
	} else {
		s = s + Eden.edenCodeForValue(this.colours[0], undefined, p);	
	}

	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions, undefined, p);
	}
	
	s = s + ")";
	return s;
};

Line.prototype.getEdenCode = Line.prototype.toString;

}}$;

func distanceMoved {
	${{
		var from, to;
		if (arguments.length == 1) {
			if (arguments[0] instanceof Line) {
				var line = arguments[0];
				from = new Point(line.x1, line.y1);
				to = new Point(line.x2, line.y2);
			} else {
				to = arguments[0];
				from = new Point(0, 0);
			}
		} else if (arguments.length == 2) {
			from = arguments[0];
			to = arguments[1];
			if (from === undefined) {
				return undefined;
			} else if (!(from instanceof Point)) {
				eden.error(new Error("distanceMoved: The first argument must be a Point, not a " + typeof(from)), "error");
				return undefined;
			}
		} else {
			eden.error(new Error("distanceMoved: This function requires at least 1 argument and at most 2 arguments"), "error");
			return undefined;
		}
		if (to === undefined) {
			return undefined;
		} else if (!(to instanceof Point)) {
			eden.error(new Error("distanceMoved: The destination point must be a Point or a Line, not a " + typeof(to)), "error");
			return undefined;
		}
		if (from.x == undefined || from.y == undefined || to.x == undefined || to.y == undefined) {
			return undefined;
		}
		var xDist = to.x - from.x;
		var yDist = to.y - from.y;
		return Math.sqrt(xDist * xDist + yDist * yDist);
	}}$;
}

func angleTurned {
	${{
		var from, to;
		if (arguments[0] instanceof Folder) {
			//Probably not an actual function call but semicircleAngle observable changed.
			return undefined;
		} else if (arguments.length == 1) {
			to = arguments[0];
			from = new Point(0, 0);
		} else if (arguments.length == 2) {
			from = arguments[0];
			to = arguments[1];
			if (from === undefined) {
				return undefined;
			} else if (!(from instanceof Point)) {
				eden.error(new Error("angleTurned: The first argument must be a Point, not a " + typeof(from)), "error");
				return undefined;
			}
		} else {
			eden.error(new Error("angleTurned: This function requires at at least 1 argument and most 2 arguments"), "error");
			return undefined;
		}
		if (to === undefined) {
			return undefined;
		} else if (!(to instanceof Point)) {
			eden.error(new Error("angleTurned: The destination point must be a Point, not a " + typeof(to)), "error");
			return undefined;
		}
		if (from.x == undefined || from.y == undefined || to.x == undefined || to.y == undefined) {
			return undefined;
		}
		var relativeX = to.x - from.x;
		var relativeY = to.y - from.y;
		return Math.atan2(relativeY, relativeX) * root.lookup("semicircleAngle").value() / Math.PI;
	}}$;
}
semicircleAngle ~> [angleTurned];

${{console.log("Got Here");}}$;
## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

##Example:
/**
 * Creates a LinearGradient that can be used to colour shapes
 * @param x1 X-coordinate for start
 * @param y1 Y-coordinate for start
 * @param x2 X-coordinate for end
 * @param y2 Y-coordinate for end
 * @param [start_colour Start Colour
 * @param end_colour] End Colour
 * @param [extra_colour_stops] A list of two item lists.  The first element of each is a point along the gradient (0.0-1.0).  The second is the colour.
 * 
 * Usage example: 
 * 
 * ```
 * 	x = 50;
 * 	y = 50;
 * 	width = 400;
 * 	height = 250;
 * 	gradient is LinearGradient(x, y, x + width, y + height, "cyan", "blue");
 * 	rect is Rectangle(x, y, width, height, gradient);
 * 	picture is [rect];
 * ```
 * #canvas #colour #gradient #lineargradient
*/

func LinearGradient {
	${{
		var x1 = arguments[0];
		var y1 = arguments[1];
		var x2 = arguments[2];
		var y2 = arguments[3];
		var colourStops;
		if (Array.isArray(arguments[4])) {
			colourStops = arguments[4];
		} else {
			if (Array.isArray(arguments[6])) {
				colourStops = arguments[6];
			} else {
				colourStops = [];
			}
			
			var start_colour = arguments[4];
			if (typeof(start_colour) != "string") {
				start_colour = "black";
			}
			
			var end_colour = arguments[5];
			if (typeof(end_colour) != "string") {
				end_colour = "white";
			}
			
			colourStops.push([0, start_colour]);
			colourStops.push([1, end_colour]);
		}
		return new LinearGradient(x1, y1, x2, y2, colourStops);
	}}$;
}

${{
	LinearGradient = function(x1, y1, x2, y2, colourStops) {
		this.x1 = x1;
		this.y1 = y1;
		this.x2 = x2;
		this.y2 = y2;
		this.colourStops = colourStops;
	}
	
	LinearGradient.prototype = new EdenUI.plugins.Canvas2D.FillStyle();
	
	LinearGradient.prototype.getColour = function (context) {
		var gradient = context.createLinearGradient(this.x1, this.y1, this.x2, this.y2);
		var colourStop;
		for (var i = 0; i < this.colourStops.length; i++) {
			colourStop = this.colourStops[i];
			gradient.addColorStop(colourStop[0], colourStop[1]);
		}
		return gradient;
	};

	LinearGradient.prototype.toString = function() {
		return "LinearGradient(" + Eden.edenCodeForValues(this.x1, this.y1, this.x2, this.y2, this.colourStops) + ")";
		
	};

	LinearGradient.prototype.getEdenCode = LinearGradient.prototype.toString;

}}$;

${{console.log("Got Here");}}$;
## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
LineSequence = function(vertices, colours, drawingOptions) {
	this.vertices = vertices;
	this.colours = colours;
	this.drawingOptions = drawingOptions;

	this.minX = this.vertices[0].x;
	this.minY = this.vertices[0].y;
	this.maxX = this.minX, this.maxY = this.minY;
	for (var i = 1; i < this.vertices.length; i++) {
		var vertex = this.vertices[i];
		if (vertex.x < this.minX) {
			this.minX = vertex.x;
		} else if (vertex.x > this.maxX) {
			this.maxX = vertex.x;
		}
		if (vertex.y < this.minY) {
			this.minY = vertex.y;
		} else if (vertex.y > this.maxY) {
			this.maxY = vertex.y;
		}
	}
}
}}$;

#! Creates a sequence of joined lines for display on the canvas from a list of Points. This produces a better visual result than just using normal lines. See [drawing options](@external CanvasExamples > drawingoptions) for more style options.
# 
# ##Usage Example
#  `LineSequence(pointslist, "blue");`
#  `LineSequence([Point(ax,ay),Point(bx,by),Point(cx,cy)]);`
#
# @param points List of coordinates in the form Point(x, y) from the top left corner of the canvas
# @param [colour(s)] Colour of the line as a HTML colour value, or a list of such colour values
# @param [drawing_options] List of drawingOptions
# 
#  #canvas #line #linesequence #drawingoptions #draw
func LineSequence {
${{
	var vertices = arguments[0];
	var colours, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo == 1) {
		colours = arguments[1];
	}

	if (colours === undefined) {
		colours = ["black"];
	} else if (!Array.isArray(colours)) {
		colours = [colours];
	} else if (colours.length == 0) {
		colours = ["black"];
	}

	return new LineSequence(vertices, colours, drawingOptions);
}}$; };

${{
LineSequence.prototype.draw = function(context, scale) {
	if (this.drawingOptions !== undefined && this.drawingOptions.lineWidth % 2 == 1) {
		context.translate(0.5 / scale, 0.5 / scale);
	}

	context.beginPath();
	var maxVertex = this.vertices.length - 1;
	if (this.colours.length == 1) {
		context.strokeStyle = this.colours[0];
	} else {
		var gradient = context.createLinearGradient(this.minX, this.minY, this.maxX, this.maxY);
		for (var i = 0; i < this.colours.length; i++) {
			gradient.addColorStop(i / (this.colours.length - 1), this.colours[i]);
		}
		context.strokeStyle = gradient;
	}

	context.moveTo(this.vertices[0].x, this.vertices[0].y);
	for (var i = 1; i <= maxVertex; i++) {
		context.lineTo(this.vertices[i].x, this.vertices[i].y);
	}
	
	context.stroke();

	if (this.drawingOptions !== undefined && this.drawingOptions.arrowhead instanceof Arrowhead) {
		var vertex0 = this.vertices[0];
		var vertex1 = this.vertices[1];
		var vertexN = this.vertices[maxVertex];
		var vertexNMinus1 = this.vertices[maxVertex - 1];
		var gradient1 = (vertex1.y - vertex0.y) / (vertex1.x - vertex0.x);
		var gradient2 = (vertexN.y - vertexNMinus1.y) / (vertexN.x - vertexNMinus1.x);
		var reverse1 = vertex0.x > vertex1.x;
		var reverse2 = vertexNMinus1.x > vertexN.x;
		this.drawingOptions.arrowhead.draw(context, scale, vertex0.x, vertex0.y, gradient1, reverse1,
			vertexN.x, vertexN.y, gradient2, reverse2);
	}	
};

LineSequence.prototype.toString = function() {
	var s = "LineSequence(" + Eden.edenCodeForValue(this.vertices) + ",";
	
	if (this.colours.length > 1) {
		s = s + Eden.edenCodeForValue(this.colours);
	} else {
		s = s + Eden.edenCodeForValue(this.colours[0]);	
	}

	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
};

LineSequence.prototype.getEdenCode = LineSequence.prototype.toString;

}}$;

${{console.log("Got Here");}}$;
## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Pixel = function(x, y, colour) {
  this.x = x;
  this.y = y;
  this.colour = colour;
}
}}$;

/*
 * Creates a pixel that can be displayed on a canvas
 * 
 * @param x x-position
 * @param y y-position
 * @param colour colour
 * 
 */
func Pixel { ${{
  var x = arguments[0];
  var y = arguments[1];
  var colour = arguments[2];
  return new Pixel(x, y, colour);
}}$; };

${{
Pixel.prototype.toString = function() {
  return "Pixel("+ Eden.edenCodeForValues(this.x, this.y, this.colour) + ")";
};

Pixel.prototype.getEdenCode = Pixel.prototype.toString;
}}$;

${{
Pixel.prototype.draw = function(context) {
  context.fillStyle = this.colour;
  context.fillRect( this.x, this.y, 1, 1);
};
}}$;
${{console.log("Got Here");}}$;
## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

/*
 * Returns a PixelList drawable.  The ptrToData argument should be a pointer to a list of
 * integers.  The first four elements of the list represent the red, green, blue and
 * alpha components of the first pixel respectively (all in the range 0-255).  The
 * next four elements represent the second pixel, going from left to right along the
 * top line of the block.  The data list should contain data for an exact number
 * of rows of the specified width.  Although cumbersome a PixelList performs far
 * faster than trying to map each pixel to an individual EDEN observable for a
 * block of any significant size.
 * 
 * N.B. Unfortunately the alpha values are not true transparency.  That is, you
 * you can't see through to other objects drawn underneath on the canvas.  Alpha
 * values less than 255 just make the colours lighter.
 * 
 * Example:
 * ```
 * 	func colourMap {
 * 		para b;
 * 		auto data, i, j;
 * 		data = [];
 * 		for (j = 0; j <= 255; j++) {
 * 			for (i = 0; i <= 255; i++) {
 * 			append data, i;
 * 			append data, j;
 * 			append data, b;
 * 			append data, 255;
 * 		}
 * 		}
 * 	return data;
 *  }
 *  
 *  blue = 50;
 *  pixelData is colourMap(blue);
 *  pixels is PixelList(&pixelData, 20, 20, 256);
 *  picture is [pixels];
 *  
 *  @param [name]
 *  @param ptrToData pointer to list of R,G,B,Alpha values
 *  @param x x-position
 *  @param y y-position
 *  @param width
 *  
 * #canvas #pixellist
 */


func PixelList {
	${{
		var name;
		var argsProcessed;
		if (typeof(arguments[0]) == "string") {
			name = arguments[0];
			argsProcessed = 1;
		} else {
			argsProcessed = 0;
		}
		var ptrToData = arguments[argsProcessed];
		argsProcessed++;
		var x = arguments[argsProcessed];
		argsProcessed++;
		var y = arguments[argsProcessed];
		argsProcessed++;
		var width = arguments[argsProcessed];
		argsProcessed++;
		return new PixelList(name, ptrToData, x, y, width);
	}}$;
}

${{
PixelList = function(name, ptrToData, x, y, width) {
	this.name = edenUI.plugins.Canvas2D.initZoneFromName(name, "PixelList");
	this.obsName = root.currentObservableName();
	this.ptr = ptrToData;
	this.data = ptrToData instanceof Symbol? ptrToData.value() : [];
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = this.data.length / (4 * width);
}

PixelList.prototype.draw = function (context) {
	var imageData = context.createImageData(this.width, this.height);
	var imageArr = imageData.data;
	var dataArr = this.data;
	var arrayLen = dataArr.length;
	for (var i = 0; i < arrayLen; i++) {
		imageArr[i] = dataArr[i];
	}
	context.putImageData(imageData, this.x, this.y);
}

PixelList.prototype.isHit = function (context, scale, x, y) {
	return x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height;
}

PixelList.prototype.toString = function() {
	var s = "PixelList(";
	if (this.name !== undefined) {
		s = s + Eden.edenCodeForValue(this.name) + ", ";
	}
	s = s + Eden.edenCodeForValues(this.ptr, this.x, this.y, this.width) + ")";
	return s;
}

PixelList.prototype.getEdenCode = PixelList.prototype.toString;

}}$;

${{console.log("Got Here");}}$;
## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Polygon = function(vertices, fillcolour, outlinecolour, drawingOptions, centreY) {
	this.vertices = vertices;
	this.fillcolour = fillcolour;
	this.outlinecolour = outlinecolour;
	this.drawingOptions = drawingOptions;
	this.centreY = centreY; //Used by RegularPolygon
	this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Polygon");
	this.obsName = root.currentObservableName();
}
}}$;

#! Creates a Polygon object for display on a canvas. You give a list of points and it will draw lines between them and then, optionally, fill the area inside. It will automatically join the last point to the first to close the shape. See [drawing options](@external CanvasExamples > drawingoptions) for more style options.
#
# ##Usage Example
#   `Polygon(pointslist, "green", "black");`
#	`Polygon([Point(10,10),Point(20,20),Point(10,20)]);`
#
# @param points List of coordinates in the form {x, y} from the top left corner of the canvas
# @param [fill_colour Colour of the polygon (fill) in HTML form
# @param [outline_colour]]
# @param [drawing_options] List of drawing options
# 
#  #canvas #polygon #drawingoptions #shape #area #triangle #octagon #hexagon #pentagon #poly #draw
func Polygon {
${{
	var vertices = arguments[0];
	if (vertices[0].x != vertices[vertices.length - 1].x || vertices[0].y != vertices[vertices.length - 1].y) {
		vertices.push(vertices[0]);
	}

	var fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 1) {
		fillcolour = arguments[1];
		if (processUpTo == 2) {
			outlinecolour = arguments[2];
		}
	}

	if (outlinecolour === undefined) {
		if (fillcolour === undefined) {
			outlinecolour = "black";
		}
	}

	return new Polygon(vertices, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

Polygon.prototype.draw = function (context, scale) {
	if (this.drawingOptions !== undefined && this.drawingOptions.lineWidth % 2 == 1) {
		context.translate(0.5 / scale, 0.5 / scale);
	}

	this.tracePath(context, scale);

	if (this.fillcolour !== undefined) {
		edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
		context.fill();
	}
	
	if (this.outlinecolour !== undefined) {
		context.strokeStyle = this.outlinecolour;
		context.stroke();
	}
};

Polygon.prototype.tracePath = function (context, scale) {
	context.beginPath();
	if (scale < 0 && this.centreY !== undefined) {
		var a = 2 * this.centreY;
		context.moveTo(this.vertices[0].x, a - this.vertices[0].y);
		for (var i = 1; i < this.vertices.length; i++) {
			context.lineTo(this.vertices[i].x, a - this.vertices[i].y);
		}
	} else {
		context.moveTo(this.vertices[0].x, this.vertices[0].y);
		for (var i = 1; i < this.vertices.length; i++) {
			context.lineTo(this.vertices[i].x, this.vertices[i].y);
		}
	}
	context.closePath();
}

Polygon.prototype.isHit = function (context, scale, x, y) {
	this.tracePath(context, scale);
	return context.isPointInPath(x,y);
}

Polygon.prototype.toString = function() {
	var s = "Polygon(" + Eden.edenCodeForValues(this.vertices, this.fillcolour, this.outlinecolour);

	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
};

Polygon.prototype.getEdenCode = Polygon.prototype.toString;

Polygon.prototype.imageMapArea = function () {
	var s = "shape=\"poly\" coords=\"";
	for (var i = 0; i < this.vertices.length; i++) {
		var vertex = this.vertices[i];
		s = s + vertex.x + "," + vertex.y + ",";
	}
	s = s.slice(0, -1);
	s = s + "\"";
	return s;
}

Polygon.prototype.centre = function () {
	var centreX = 0, centreY = 0;
	for (var i = 0; i < this.vertices.length; i++) {
		centreX = centreX + this.vertices[i].x;
		centreY = centreY + this.vertices[i].y;
	}
	centreX = centreX / this.vertices.length;
	centreY = centreY / this.vertices.length;
	return new Point(centreX, centreY);
}

}}$;

${{console.log("Got Here");}}$;
## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

##Example:

/*
 * Creates a radial gradient that can be used to colour shapes
 * 
 * @param x
 * @param y
 * @param [r radius
 * @param [colourStops]] List of colourStops
 * 
 * ```
 * g is RadialGradient(300, 240, 230, [[0, "red"], [0.5, "orange"], [1, "cyan"]]);
 * c is Circle(300,240,230,g);
 * picture is [c];
 * ```
 */
	
func RadialGradient {
	${{
		var x1, y1, r1, x2, y2, r2, colourStops;
		x1 = arguments[0];
		y1 = arguments[1];
		
		switch (arguments.length) {
			case 4:
				r1 = 0;
				x2 = x1;
				y2 = y1;
				r2 = arguments[2];
				colourStops = arguments[3];
				break;
		}
		return new RadialGradient(x1, y1, r1, x2, y2, r2, colourStops);
	}}$;
}

${{
	RadialGradient = function(x1, y1, r1, x2, y2, r2, colourStops) {
		this.x1 = x1;
		this.y1 = y1;
		this.r1 = r1;
		this.x2 = x2;
		this.y2 = y2;
		this.r2 = r2;
		this.colourStops = colourStops;
	}
	
	RadialGradient.prototype = new EdenUI.plugins.Canvas2D.FillStyle();

	RadialGradient.prototype.getColour = function (context) {
		var gradient = context.createRadialGradient(this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);
		var colourStop;
		for (var i = 0; i < this.colourStops.length; i++) {
			colourStop = this.colourStops[i];
			gradient.addColorStop(colourStop[0], colourStop[1]);
		}
		return gradient;
	};

	RadialGradient.prototype.toString = function() {
		return "RadialGradient(" + Eden.edenCodeForValues(this.x1, this.y1, this.r1, this.x2, this.y2, this.r2, this.colourStops) + ")";
		
	};

	RadialGradient.prototype.getEdenCode = RadialGradient.prototype.toString;

}}$;


## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Rectangle = function(x, y, width, height, fillcolour, outlinecolour, drawingOptions) {
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.fillcolour = fillcolour;
	this.outlinecolour = outlinecolour;
	this.drawingOptions = drawingOptions;
	this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Rectangle");
	this.obsName = root.currentObservableName();
}
}}$;

#! Creates a rectangle that can be coloured and displayed on a canvas. See [drawing options](@external CanvasExamples > drawingoptions) for more style options.
#
# ##Usage Example
#  `Rectangle(x,y,width,height);`
#  `Rectangle(x,y,w,h, "green", "black", Object("lineWidth", 5));`
#
# @param x X-coordinate for top left
# @param y Y-coordinate for top left
# @param width
# @param height
# @param [fill_colour
# @param [outline_colour]] Colour of the rectangle outline in HTML form
# @param [drawing_options] List of drawing options
# 
#  #canvas #rectangle #drawingoptions #square #box #shape #draw
func Rectangle {
${{
	var x = arguments[0];
	var y = arguments[1];
	var width = arguments[2];
	var height = arguments[3];
	var fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 4) {
		fillcolour = arguments[4];
		if (processUpTo == 5) {
			outlinecolour = arguments[5];
		}
	}
	if (fillcolour === undefined && outlinecolour === undefined) {
		outlinecolour = "black";
	}
	return new Rectangle(x, y, width, height, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

Rectangle.prototype.draw = function (context, scale) {
	var lineWidth;
	if (this.outlinecolour !== undefined) {
		lineWidth = context.lineWidth;
		if (this.drawingOptions !== undefined) {
			if (!("join" in this.drawingOptions) && lineWidth < 10) {
				//Bug in Chrome v44, shape isn't drawn when miter join is used with larger line widths.
				context.lineJoin = "miter"
			}
		}
	} else {
		lineWidth = 0;
	}
	var y = this.y;
	if (scale < 0) {
		y = y - this.height;
	}
	if (this.fillcolour !== undefined) {
		edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
		context.fillRect(this.x + lineWidth, y + lineWidth, this.width - 2 * lineWidth, this.height - 2 * lineWidth);
	}
	if (this.outlinecolour !== undefined) {
		context.strokeStyle = this.outlinecolour;
		context.strokeRect(this.x + lineWidth / 2, y + lineWidth / 2, this.width - lineWidth, this.height - lineWidth);
	}
};

Rectangle.prototype.isHit = function (context, scale, x, y) {
	return x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height;
}

Rectangle.prototype.toString = function() {
	var s = "Rectangle(" + Eden.edenCodeForValues(this.x, this.y, this.width, this.height, this.fillcolour, this.outlinecolour);

	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
};

Rectangle.prototype.getEdenCode = Rectangle.prototype.toString;

Rectangle.prototype.imageMapArea = function () {
	return "shape=\"rect\" coords=\"" + this.x + "," + this.y + "," + (this.x + this.width) + "," +
		(this.y + this.height) + "\"";
}

Rectangle.prototype.centre = function () {
	return new Point(this.x + this.width / 2, this.y + this.height / 2);
}


console.log("Before RegularPolygon");
}}$;

${{
	RegularPolygon = function (x, y, r, n, star, rotation, interiorOutline, fillcolour, outlinecolour, drawingOptions) {
		this.x = x;
		this.y = y;
		this.r = r;
		this.n = n;
		this.star = star;
		star = Math.floor(star);
		this.interiorOutline = interiorOutline;
		this.rotation = rotation;
		this.rotationInRadians = rotation * Math.PI / root.lookup("semicircleAngle").value();
		this.fillcolour = fillcolour;
		this.outlinecolour = outlinecolour;
		this.drawingOptions = drawingOptions;
		this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "RegularPolygon");
		this.obsName = root.currentObservableName();

		this.exteriorAngle = (2 * Math.PI) / n;
		this.vertices = [];
		var pointsDone = new Array(n);
		var px, py;
		var currentPolygonVertices, currentPoint;
		var nudge;
		if (drawingOptions !== undefined && drawingOptions.valign == "bottom") {
			if (drawingOptions.lineWidth !== undefined) {
				nudge = drawingOptions.lineWidth;
			} else {
				nudge = 2;
			}
		} else {
			nudge = 0;
		}
		var rotation2;
		if (n % 4 == 0) {
			rotation2 = -this.rotationInRadians - Math.PI * (0.5 - 1 / n);
		} else {
			rotation2 = -this.rotationInRadians - Math.PI * (0.5 - 2 / n); //Zero rotation means "pointing upwards"
		}
		for (var i = 0; i < n; i++) {
			var j = i;
			currentPolygonVertices = [];
			while (pointsDone[j] !== true) {
				px = x + r * Math.cos(rotation2 + j * this.exteriorAngle);
				py = y + r * Math.sin(rotation2 + j * this.exteriorAngle) + nudge;
				currentPoint = new Point(px, py);
				currentPolygonVertices.push(currentPoint);
				pointsDone[j] = true;
				j = (j + star) % n;
			}
			if (currentPolygonVertices.length > 0) {
				this.vertices = this.vertices.concat(currentPolygonVertices);
			}
		}
		if (outlinecolour === undefined && star % n != 0) {
			this.calculatePolygons(0);
		}
	}

	RegularPolygon.degenerateMonogramRadii = 7;

	RegularPolygon.prototype.calculatePolygons = function (lineWidth, scale) {
		var radius;
		var rotation;
		if (this.n % 4 == 0) {
			rotation = -this.rotationInRadians - Math.PI * (0.5 - 1 / this.n);
		} else {
			rotation = -this.rotationInRadians - Math.PI * (0.5 - 2 / this.n); //Zero rotation means "pointing upwards"
		}

		var nudge;
		if (this.drawingOptions !== undefined && this.drawingOptions.valign == "bottom") {
			nudge = lineWidth;
		} else {
			nudge = 0;
		}

		var px, py;
		var polygons = [];
		this.outlinePolygons = [];
		var star = Math.floor(this.star);
		if (star % this.n == 0) {
			var circlesRadius = RegularPolygon.degenerateMonogramRadii / scale + (this.outlinecolour === undefined? 0 : lineWidth * 2);
			radius = this.r - circlesRadius;
			for (var i = 0; i < this.n; i++) {
				px = this.x + radius * Math.cos(rotation + i * this.exteriorAngle);
				py = this.y + radius * Math.sin(rotation + i * this.exteriorAngle) + nudge;
				polygons.push(new Circle(px, py, circlesRadius, this.fillcolour, this.outlinecolour, this.drawingOptions));
			}
			this.filledPolygons = polygons;
			return;
		}

		radius = this.r - lineWidth / 2
		var separatePolygonsPossiblyNeeded;
		if (this.fillcolour !== undefined && this.fillcolour != "transparent" &&
			this.outlinecolour !== undefined &&
			this.n / star != 2
		) {
			separatePolygonsPossiblyNeeded = true;
		} else {
			separatePolygonsPossiblyNeeded = false;		
		}
		
		var pointsDone = new Array(this.n);
		var currentPolygonVertices, currentPoint;
		for (var i = 0; i < this.n; i++) {
			var j = i;
			currentPolygonVertices = [];
			while (pointsDone[j] !== true) {
				px = this.x + radius * Math.cos(rotation + j * this.exteriorAngle);
				py = this.y + radius * Math.sin(rotation + j * this.exteriorAngle) + nudge;
				currentPoint = new Point(px, py);
				currentPolygonVertices.push(currentPoint);
				pointsDone[j] = true;
				j = (j + star) % this.n;
			}
			if (currentPolygonVertices.length > 0) {
				polygons.push(new Polygon(currentPolygonVertices, this.fillcolour, this.outlinecolour, this.drawingOptions, this.y));
			}
		}
		if (separatePolygonsPossiblyNeeded) {
			if (polygons.length == 1) {
				if (!this.interiorOutline) {
					/* Case: single constituent polygon (e.g. five-pointed star) with an outline but
					 * not an outline drawn in inside the shape (i.e. a star or a pentagon rather
					 * than a pentagram).
					 * Solution: add extra polygons to over-paint those inside edges that we don't want.
					 * N.B. We can (and do) safely ignore these extra polygons when performing hit testing.
					 */
					var smallerRadius = this.r - lineWidth;
					currentPolygonVertices = [];
					i = 0;
					do {
						px = this.x + smallerRadius * Math.cos(rotation + i * this.exteriorAngle);
						py = this.y + smallerRadius * Math.sin(rotation + i * this.exteriorAngle);
						currentPoint = new Point(px, py);
						currentPolygonVertices.push(currentPoint);
						i = (i + star) % this.n;
					} while (i != 0);
					polygons.push(new Polygon(currentPolygonVertices, this.fillcolour, undefined, this.drawingOptions, this.y));
				} else {
					/* Case: the user wants to see the edges that intersect the interior of the
					 * polygon.
					 */
				}
				this.filledPolygons = polygons;
			} else {
				/* Case: multiple constituent polygons (specifically, more than 2).  Occurs when
				 * n / star is an integer greater than 2.
				 * Solution: Paint the fill and the outline as separate polygons.  The requirement
				 * to show or hide the interior edges determines whether the outlines are painted
				 * first or the fill is painted first.
				 */
				this.filledPolygons = [];
				for (var i = 0; i < polygons.length; i++) {
					this.filledPolygons.push(new Polygon(polygons[i].vertices, this.fillcolour, undefined, this.drawingOptions, this.y));
				}
				for (var i = 0; i < polygons.length; i++) {
					this.outlinePolygons.push(new Polygon(polygons[i].vertices, undefined, this.outlinecolour, this.drawingOptions, this.y));
				}
			}
		} else {
			/* Case: the outline doesn't have intersecting edges (or only degenerate ones, i.e. n / star = 2),
			 * or doesn't have an outline, or doesn't have a fill colour.
			 * N.B: n / star = 2 is the degenerate case when a polygon is reduced to being a set of unconnected lines.
			 * Solution: One set of polygons that paint either the fill or the outline (the shape doesn't have both).
			 */
			this.filledPolygons = polygons;
		}	
	}
}}$;

/**
 * Creates a polygon for display on a canvas
 * 
 * centre_x
 * centre_y
 * radius
 * n_sides Number of sides
 * [star_factor] Produces simple polygon if 1, if 2 it connects every other vertex, if 3 it connects every third vertex, etc.
 * [is_interior_outlined] true or false to draw internal lines in polygon (only has effect if fill colour is set).
 * [rotation] Rotation in degrees
 * [fill_colour Colour to fill the interior of the polygon with
 * [outline_colour]] Colour of the outline
 * [drawing_options] List of drawing options
 * 			
 * 
 * #canvas #drawingOptions #regularPolygon #polygon #drawingOptions
 */

func RegularPolygon {
	${{
		var maxArgs = 10;
		var numArgs = arguments.length;
		var x = arguments[0];
		var y = arguments[1];
		var r = arguments[2];
		var n = arguments[3];
		var star, rotation, interiorOutline;
		var fillcolour, outlinecolour, drawingOptions;
		var argsProcessed = 4;
		if (typeof(arguments[4]) == "number") {
			star = arguments[4];
			argsProcessed++;
		}
		if (numArgs - argsProcessed > maxArgs - 5) { argsProcessed = 5; }

		if (typeof(arguments[argsProcessed]) == "boolean") {
			interiorOutline = arguments[argsProcessed];
			argsProcessed++;
		}
		if (numArgs - argsProcessed > maxArgs - 6) { argsProcessed = 6; }

		if (typeof(arguments[argsProcessed]) == "number") {
				rotation = arguments[argsProcessed];
				argsProcessed++;
		}
		if (numArgs - argsProcessed > maxArgs - 7) { argsProcessed = 7; }

		var lastArg = arguments[numArgs - 1];
		var processUpTo;
		if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
			drawingOptions = lastArg;
			processUpTo = numArgs - 2;
		} else {
			processUpTo = numArgs - 1;
		}
		if (processUpTo >= argsProcessed) {
			fillcolour = arguments[argsProcessed];
			argsProcessed++;
			if (processUpTo == argsProcessed) {
				outlinecolour = arguments[argsProcessed];
			}
		}

		if (star === undefined) {
			star = 1;
		}

		if (rotation === undefined) {
			if (star <= -n || star >= n) {
				rotation = star;
				star = 1;
			} else {
				rotation = 0;
			}
		}

		if (outlinecolour === undefined) {
			if (fillcolour === undefined || interiorOutline) {
				outlinecolour = "black";
			}
		}
		if (interiorOutline === undefined) {
			interiorOutline = true;
		}

		if (drawingOptions !== undefined) {
			if (!("join" in drawingOptions)) {
				drawingOptions.join = "round";
			}
		}
		
		if (n === Infinity) {
			return new Circle(x, y, r, fillcolour, outlinecolour, drawingOptions);
		} else {
			return new RegularPolygon(x, y, r, n, star, rotation, interiorOutline, fillcolour, outlinecolour, drawingOptions);
		}
	}}$;
}
semicircleAngle ~> [RegularPolygon];

${{
RegularPolygon.prototype.draw = function (context, scale) {
	var lineWidth = context.lineWidth;
	if (!this.interiorOutline) {
		lineWidth = lineWidth * 2;
	}
	if (this.outlinecolour !== undefined || Math.floor(this.star) % this.n == 0) {
		if (lineWidth !== this.cachedPolygonLineWidth) {
			this.calculatePolygons(lineWidth, scale);
			this.cachedPolygonLineWidth = lineWidth;
		}
	}

	if (this.interiorOutline) {
		for (var i = 0; i < this.filledPolygons.length; i++) {
			this.filledPolygons[i].draw(context, scale);
		}
		for (var i = 0; i < this.outlinePolygons.length; i++) {
			this.outlinePolygons[i].draw(context, scale);
		}
	} else {
		context.lineWidth = lineWidth;
		for (var i = 0; i < this.outlinePolygons.length; i++) {
			this.outlinePolygons[i].draw(context, scale);
		}
		context.lineWidth = lineWidth / 2;
		for (var i = 0; i < this.filledPolygons.length; i++) {
			this.filledPolygons[i].draw(context, scale);
		}
	}
}

RegularPolygon.prototype.isHit = function (context, scale, x, y) {
	var hit;
	var star = Math.floor(this.star);
	var ratio = this.n / star;
	var limit;
	if (this.fillcolour !== undefined && this.fillcolour != "transparent" &&
		this.outlinecolour !== undefined &&
		ratio != 2 &&
		(star == 1 || ratio != Math.floor(ratio)) &&
		!this.interiorOutline
	) {
		limit = this.filledPolygons.length / 2;
	} else {
		limit = this.filledPolygons.length;
	}
	for (var i = 0; i < limit; i++) {
		hit = this.filledPolygons[i].isHit(context, scale, x, y);
		if (hit) {
			return true;
		}
	}
	return false;
};

RegularPolygon.prototype.toString = function () {
	var s = "RegularPolygon(" + Eden.edenCodeForValues(this.x, this.y, this.r, this.n, this.star,
		this.interiorOutline, this.rotation, this.fillcolour, this.outlinecolour);

	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	s = s + ")";
	return s;
}

RegularPolygon.prototype.getEdenCode = RegularPolygon.prototype.toString;
	
RegularPolygon.prototype.imageMapArea = function () {
	return this.filledPolygons[0].imageMapArea();
}

RegularPolygon.prototype.centre = function () {
	return new Point(this.x, this.y);
}

}}$;

${{console.log("Got Here");}}$;
## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{

	Rotation = function (angle, centre, origin, angle2, radius, items) {
		this.angle = angle;
		this.centre = centre;
		this.origin = origin;
		this.angle2 = angle2;
		this.radius = radius;
		this.items = items;

		var radiansPerUnit = Math.PI / root.lookup("semicircleAngle").value();
		if (angle2 === undefined) {
			this.radians2 = 0;
		} else {
			this.radians2 = -angle2 * radiansPerUnit;
		}
		if (angle === undefined) {
			this.radians = 0;
		} else {
			this.radians = -angle * radiansPerUnit - this.radians2;
		}
	}

	Rotation.prototype = new EdenUI.plugins.Canvas2D.Transform();
	
	Rotation.prototype.transform = function (context) {
		var origin = this.origin;
		var centre = this.centre;
		var radius = this.radius;

		context.translate(origin.x, origin.y);

		if (radius !== undefined) {
			context.rotate(this.radians2);
			context.translate(radius, 0);
		}
		context.rotate(this.radians);

		if (centre !== undefined) {
			context.translate(-centre.x, -centre.y);
		}
	}

	Rotation.prototype.getCSS = function (scale) {
		var origin = this.origin;
		var centre = this.centre;
		var radius = this.radius;

		var css, x, y, theta;

		x = origin.x * scale;
		y = origin.y * scale;
		css = "translate(" + x + "px, " + y + "px) ";

		if (radius !== undefined) {
			theta = this.radians2;
			x = radius * scale;
			css = css +  "rotate(" + theta + "rad) translateX(" + x + "px) ";
		}

		theta = this.radians;
		css = css + "rotate(" + theta + "rad) ";

		if (centre !== undefined) {
			x = -centre.x * scale;
			y = -centre.y * scale;
			css = css + "translate(" + x + "px, " + y + "px)";
		}

		return css;
	}

	Rotation.prototype.inverse = function (x, y) {
		var origin = this.origin;
		var centre = this.centre;
		var radius = this.radius;

		var invX = x - origin.x;
		var invY = y - origin.y;
		var temp, sin, cos;

		if (radius !== undefined) {
			sin = Math.sin(-this.radians2);
			cos = Math.cos(-this.radians2);
			temp = invX;
			invX = cos * invX - sin * invY;
			invY = sin * temp + cos * invY;
			invX = invX - radius;
		}

		sin = Math.sin(-this.radians);
		cos = Math.cos(-this.radians);
		temp = invX;
		invX = cos * invX - sin * invY;
		invY = sin * temp + cos * invY;

		if (centre !== undefined) {
			invX = invX + centre.x;
			invY = invY + centre.y;
		}
		return new Point(invX, invY);
	}

	Rotation.prototype.toString = function() {
		if (this.radius !== undefined && this.centre !== undefined) {
			return "CombinedRotation(" + Eden.edenCodeForValues(this.angle, this.centre, this.origin, this.angle2, this.radius, this.items) + ")";
		} else if (this.radius !== undefined) {
			return "RotateAboutPoint(" + Eden.edenCodeForValues(this.angle2, this.origin, this.radius, this.items) + ")";
		} else {
			return "RotateAboutCentre(" + Eden.edenCodeForValues(this.angle, this.centre, this.origin, this.items) + ")";
		}
	}

	Rotation.prototype.getEdenCode = Rotation.prototype.toString;

}}$;

func Rotate {
	para item, angle;
	
	${{
		if (item instanceof CanvasImage) {
			return new Rotation(angle, new Point(item.dx + item.dWidth/2, item.dy + item.dHeight/2), new Point(item.dx,item.dy), 0, undefined, [item]);
		}
	}}$;
}

func CombinedRotation {
	${{
		if (arguments[0] instanceof Folder) {
			//Probably not an actual function call but semicircleAngle observable changed.
			return undefined;
		}

		var angle, centre, origin, angle2, radius, items;
		angle = arguments[0];
		centre = arguments[1];
		origin = arguments[2];

		if (arguments.length == 6) {
			angle2 = arguments[3];
			radius = arguments[4];
			items = arguments[5];
		} else {
			angle2 = angle;
			radius = arguments[3];
			items = arguments[4];		
		}

		if (!(centre instanceof Point)) {
			eden.error(new Error("CombinedRotation: The centre of rotation must be a Point, not a " + typeof(centre)), "error");
			return undefined;
		}
		if (!(origin instanceof Point)) {
			eden.error(new Error("CombinedRotation: The centre of the circular orbit must be a Point, not a " + typeof(origin)), "error");
			return undefined;
		}
		return new Rotation(angle, centre, origin, angle2, radius, items);
	}}$;
}

func RotateAboutCentre {
	${{
		if (arguments[0] instanceof Folder) {
			//Probably not an actual function call but semicircleAngle observable changed.
			return undefined;
		}

		var angle = arguments[0];
		var centre = arguments[1];
		var origin = arguments[2];
		var items = arguments[3];

		if (!(centre instanceof Point)) {
			eden.error(new Error("RotateAboutCentre: The centre of rotation must be a Point, not a " + typeof(centre)), "error");
			return undefined;
		}
		if (!(origin instanceof Point)) {
			eden.error(new Error("RotateAboutCentre: The destination position must be a Point, not a " + typeof(origin)), "error");
			return undefined;
		}
		return new Rotation(angle, centre, origin, 0, undefined, items);
	}}$;
}

func RotateAboutPoint {
	${{
		if (arguments[0] instanceof Folder) {
			//Probably not an actual function call but semicircleAngle observable changed.
			return undefined;
		}

		var angle, origin, radius, centre, items;
		angle = arguments[0];
		origin = arguments[1];
		radius = arguments[2];

		if (arguments.length == 5) {
			centre = arguments[3];
			items = arguments[4];
			if (!(centre instanceof Point)) {
				eden.error(new Error("RotateAboutPoint: The centre point of the source picture must be a Point, not a " + typeof(centre)), "error");
				return undefined;
			}
		} else {
			items = arguments[3];
		}

		if (!(origin instanceof Point)) {
			eden.error(new Error("RotateAboutPoint: The centre of the circle must be a Point, not a " + typeof(origin)), "error");
			return undefined;
		}
		return new Rotation(0, centre, origin, angle, radius, items);
	}}$;
}

semicircleAngle ~> [CombinedRotation, RotateAboutCentre, RotateAboutPoint];

${{console.log("Got Here");}}$;
## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
RoundedRectangle = function(x, y, width, height, radius, fillcolour, outlinecolour, drawingOptions) {
	this.x1 = x;
	this.y1 = y;
	this.x2 = x + width;
	this.y2 = y + height;
	this.radius = radius;
	this.fillcolour = fillcolour;
	this.outlinecolour = outlinecolour;
	this.drawingOptions = drawingOptions;
	this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "RoundedRectangle");
	this.obsName = root.currentObservableName();
}
}}$;

#! Draws a rounded rectangle. See [drawing options](@external CanvasExamples > drawingoptions) for more style properties.
#
# ##Usage Example
#  `RoundedRectangle(x,y,width,height, 10);`
#
# @param x
# @param y
# @param width
# @param height
# @param radius
# @param [fillColour
# @param [outlineColour]]
# @param [drawingOptions]
# 
#  #canvas #roundedRectangle #rounded #rectangle #drawingOptions #shape #box #draw
func RoundedRectangle {
${{
	var x = arguments[0];
	var y = arguments[1];
	var width = arguments[2];
	var height = arguments[3];
	var radius = arguments[4];
	var fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 5) {
		fillcolour = arguments[5];
		if (processUpTo == 6) {
			outlinecolour = arguments[6];
		}
	}
	if (fillcolour === undefined && outlinecolour === undefined) {
		outlinecolour = "black";
	}
	return new RoundedRectangle(x, y, width, height, radius, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

RoundedRectangle.prototype.draw = function (context, scale) {

	this.tracePath(context, scale);

	if (this.fillcolour !== undefined) {
		edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
		context.fill();
	}
	if (this.outlinecolour !== undefined) {
		context.strokeStyle = this.outlinecolour;
		context.stroke();
	}
};

RoundedRectangle.prototype.tracePath = function (context, scale) {
	var halfLineWidth;
	if (this.outlinecolour !== undefined) {
		halfLineWidth = context.lineWidth / 2;
	} else {
		halfLineWidth = 0;
	}
	var x1 = this.x1 + halfLineWidth;
	var x2 = this.x2 - halfLineWidth;
	var y1 = this.y1 + halfLineWidth;
	var y2 = this.y2 - halfLineWidth;
	if (scale < 0) {
		var temp = y1 - (y2 - y1);
		y2 = y1;
		y1 = temp;
	}
	
	context.beginPath();
    context.moveTo(x1 + this.radius, y1);
    context.lineTo(x2 - this.radius, y1);
	context.arcTo(x2, y1, x2, y1 + this.radius, this.radius);
	context.lineTo(x2, y2 - this.radius);
	context.arcTo(x2, y2, x2 - this.radius, y2, this.radius);
	context.lineTo(x1 + this.radius, y2);
	context.arcTo(x1, y2, x1, y2 - this.radius, this.radius);
	context.lineTo(x1, y1 + this.radius);
	context.arcTo(x1, y1, x1 + this.radius, y1, this.radius);
	context.closePath();
};

RoundedRectangle.prototype.isHit = function (context, scale, x, y) {
	this.tracePath(context, scale);
	return context.isPointInPath(x,y);
}

RoundedRectangle.prototype.toString = function() {
	var s = "RoundedRectangle(" + Eden.edenCodeForValues(this.x1, this.y1) + ", ";
	
	if (this.x2 === undefined || this.x1 === undefined) {
		s = s + "@, ";
	} else {
		s = s + String(this.x2 - this.x1) + ", ";
	}
	if (this.y2 === undefined || this.y1 === undefined) {
		s = s + "@, ";
	} else {
		s = s + String(this.y2 - this.y1) + ", ";
	}
	s = s + Eden.edenCodeForValues(this.radius, this.fillcolour, this.outlinecolour);
	
	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
};

RoundedRectangle.prototype.getEdenCode = RoundedRectangle.prototype.toString;

}}$;

${{console.log("Got Here");}}$;
## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{

	Scaling = function (scaleX, scaleY, centreX, centreY, translateX, translateY, items) {
		this.scaleX = scaleX;
		this.scaleY = scaleY;
		this.centreX = centreX;
		this.centreY = centreY;
		this.translateX = translateX;
		this.translateY = translateY;
		this.items = items;
	}

	Scaling.prototype = new EdenUI.plugins.Canvas2D.Transform;

	Scaling.prototype.transform = function (context) {
		var translateX = this.translateX;
		if (translateX !== undefined) {
			context.translate(translateX, this.translateY);
		}

		context.scale(this.scaleX, this.scaleY);

		var centreX = this.centreX;
		if (centreX !== undefined) {
			context.translate(-centreX, -this.centreY);
		}
	}

	Scaling.prototype.getCSS = function (scale) {
		var x = this.translateX;
		var y = this.translateY;
		var css;
		if (x || y) {
			x = x * scale;
			y = y * scale;
			css = "translate(" + x + "px, " + y + "px) ";
		} else {
			css = "";
		}

		var scaleX = this.scaleX * scale;
		var scaleY = this.scaleY * scale;
		css = css + "scale(" + scaleX + ", " + scaleY + ") ";

		x = this.centreX;
		y = this.centreY;
		if (x || y) {
			x = -x / this.scaleX;
			y = -y / this.scaleY;
			css = css + "translate(" + x + "px, " + y + "px)";
		}
		return css;
	}

	Scaling.prototype.inverse = function (x, y) {
		var invX = x, invY = y;
		
		var translateX = this.translateX;
		if (translateX) {
			invX = invX - translateX;
			invY = invY - this.translateY;
		}

		invX = invX / this.scaleX;
		invY = invY / this.scaleY;

		var centreX = this.centreX;
		if (centreX) {
			invX = invX + centreX;
			invY = invY + this.centreY;
		}
		return new Point(invX, invY);
	}

	Scaling.prototype.toString = function () {
		return "Scale(" + Eden.edenCodeForValues(this.scaleX, this.scaleY, this.centreX,
			this.centreY, this.translateX, this.translateY, this.items) + ")";
	}

	Scaling.prototype.getEdenCode = Scaling.prototype.toString;

}}$;

func Scale {
	${{
		var scaleX, scaleY, centreX, centreY, translateX, translateY, items;

		var argNum = arguments.length - 1;
		var arg;

		items = arguments[argNum];
		argNum--;
		if (argNum > 0) {
			arg = arguments[argNum];
			if (arg instanceof Point) {
				translateX = arg.x;
				translateY = arg.y;
				argNum--;
			} else if (argNum >= 2) {
				translateY = arg;
				argNum--;
				translateX = arguments[argNum];
				argNum--;
			}
			if (argNum > 0) {
				arg = arguments[argNum];
				if (arg instanceof Point) {
					centreX = arg.x;
					centreY = arg.y;
					argNum--;
				} else if (argNum >= 2) {
					centreY = arg;
					argNum--;
					centreX = arguments[argNum];
					argNum--;
				}
			}
			if (argNum == 1) {
				scaleY = arguments[argNum];
			} else if (argNum > 0) {
				eden.error(new Error("Scale: invalid parameters."), "error");
				return undefined;
			}
		}

		scaleX = arguments[0];
		if (scaleY === undefined) {
			scaleY = scaleX;
		}

		return new Scaling(scaleX, scaleY, centreX, centreY, translateX, translateY, items);
	}}$;
}

${{console.log("Got Here");}}$;
## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Sector = function(x, y, r, sAngle, eAngle, unitsInCircle, fillcolour, outlinecolour,drawingOptions) {
	this.x = x;
	this.y = y;
	this.r = r;
	this.sAngle = sAngle;
	this.eAngle = eAngle;
	this.unitsInCircle = unitsInCircle;
	var radiansPerUnit;
	if (unitsInCircle === undefined) {
		radiansPerUnit = Math.PI / root.lookup("semicircleAngle").value();
	} else {
		radiansPerUnit = (2 * Math.PI) / unitsInCircle;
	}
	this.sRadians = sAngle * radiansPerUnit;
	this.eRadians = eAngle * radiansPerUnit;

    this.fillcolour = fillcolour;
	this.outlinecolour = outlinecolour;
	this.drawingOptions = drawingOptions;
	this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Sector");
	this.obsName = root.currentObservableName();
}
}}$;

func Sector { ${{
	var x = arguments[0];
	var y = arguments[1];
	var r = arguments[2];
	var sAngle = arguments[3];
	var eAngle = arguments[4];
	var unitsInCircle, fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}

	var argsProcessed = 5;
	if (typeof(arguments[argsProcessed]) == "number") {
		unitsInCircle = arguments[argsProcessed];
		argsProcessed++;
	}
	if (argsProcessed <= processUpTo) {
		fillcolour = arguments[argsProcessed];
		argsProcessed++;
	}
	if (argsProcessed <= processUpTo) {
		outlinecolour = arguments[argsProcessed];
	}
	if (fillcolour === undefined && outlinecolour === undefined) {
		outlinecolour = "black";
	}
	return new Sector(x, y, r, sAngle, eAngle, unitsInCircle, fillcolour, outlinecolour, drawingOptions);
}}$; };
semicircleAngle ~> [Sector];

${{

Sector.prototype.draw = function (context, scale) {

	this.tracePath(context, scale);

	if (this.fillcolour !== undefined) {
		edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
		context.fill();
	}
	if (this.outlinecolour !== undefined) {
		context.strokeStyle = this.outlinecolour;
		context.stroke();
	}
};

Sector.prototype.tracePath = function (context, scale) {
	var anticlockwise;
	if (this.drawingOptions !== undefined && "direction" in this.drawingOptions) {
		switch (this.drawingOptions.direction) {
		case "anticlockwise":
		case "acw":
		case "ccw":
			anticlockwise = true;
			break;
		case "auto":
			anticlockwise = this.sAngle < this.eAngle;
			break;
		case "clockwise":
		case "cw":
			anticlockwise = false;
			break;
		default:
			//Invalid value specified.
			anticlockwise = true;
		}
	} else {
		//Default to "auto" 
		anticlockwise = this.sAngle < this.eAngle;
	}

	var sRadians = this.sRadians;
	var eRadians = this.eRadians;
	if (scale < 0) {
		sRadians = -sRadians;
		eRadians = -eRadians;
		anticlockwise = !anticlockwise;
	}
	var radius;
	if (this.outlinecolour === undefined) {
		radius = this.r;
	} else if (this.drawingOptions !== undefined && this.drawingOptions.lineWidth % 2 == 1) {
		context.translate(0.5 / scale, 0.5 / scale);
		radius = this.r - 0.5 * context.lineWidth - 0.5 / scale;
	} else {
		radius = this.r - 0.5 * context.lineWidth;
	}

	context.beginPath();
	context.arc(this.x, this.y, radius, -sRadians, -eRadians, anticlockwise);
	context.lineTo(this.x, this.y);
	context.closePath();
};

Sector.prototype.isHit = function (context, scale, x, y) {
	this.tracePath(context, scale);
	return context.isPointInPath(x,y);
}

Sector.prototype.toString = function() {
	var s = "Sector(" + Eden.edenCodeForValues(this.x, this.y, this.r, this.sAngle, this.eAngle,
		this.unitsInCircle, this.fillcolour, this.outlinecolour);

	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
}

Sector.prototype.getEdenCode = Sector.prototype.toString;

}}$;

${{console.log("Got Here");}}$;
## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

func Shadow {
	${{
		var colour, blur, xOffset, yOffset, scale;

		var processUpTo;
		var numArgs = arguments.length;
		var lastArg = arguments[numArgs - 1];
		if (lastArg === true || lastArg === false || numArgs == 5) {
			scale = lastArg;
			processUpTo = numArgs - 1;
		} else {
			processUpTo = numArgs;
		}

		var argsProcessed;
		if (typeof(arguments[0]) == "string" || (arguments[0] === undefined && processUpTo > 3)) {
			colour = arguments[0];
			argsProcessed = 1;
		} else {
			argsProcessed = 0;
		}
		if (colour == undefined) {
			colour = "#3b3b3b";
		}

		xOffset = arguments[argsProcessed];
		argsProcessed++;
		yOffset = arguments[argsProcessed];
		argsProcessed++;
		blur = arguments[argsProcessed];
		return new Shadow(colour, xOffset, yOffset, blur, scale);
	}}$;
}

${{
	function Shadow(colour, xOffset, yOffset, blur, scale) {
		this.colour = colour;
		this.blur = blur;
		this.xOffset = xOffset;
		this.yOffset = yOffset;
		this.scale = scale;
	}

	Shadow.prototype.toString = function() {
		return "Shadow(" + Eden.edenCodeForValues(this.colour, this.xOffset, this.yOffset, this.blur, this.scale) + ")";
	}

	Shadow.prototype.getEdenCode = Shadow.prototype.toString;

}}$;

${{console.log("Got Here");}}$;
## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Slider = function(name, min, max, step, labelInterval, tickMarkInterval, labelDivisor, x, y, length, orientation, enabled) {
	this.name = name;
	this.obsName = root.currentObservableName();
	this.min = min;
	this.max = max;
	this.step = step;
	this.labelInterval = labelInterval;
	this.tickMarkInterval = tickMarkInterval;
	this.labelDivisor = labelDivisor;
	this.x = x;
	this.y = y;
	this.length = length;
	this.orientation = orientation;
	this.enabled = enabled;
}

Slider.prototype.hash = function () {
	return this.name+"$$"+
				this.min+"$$"+
				this.max+"$$"+
				this.step+"$$"+
				this.labelInterval+"$$"+
				this.tickMarkInterval+"$$"+
				this.labelDivisor+"$$"+
				this.x+"$$"+
				this.y+"$$"+
				this.length+"$$"+
				this.orientation+"$$"+
				this.enabled;
};
}}$;

/**
 * Create a slider input control
 * 
 * @param [name] Prefix for _value and _preview observables.  Default is the name of the observable being defined.
 * @param min Minimum value of the slider
 * @param max Maximum value of the slider
 * @param [step Step interval
 * @param [label_interval How frequently to display labels
 * @param [tick_mark_interval How frequently to display tick marks
 * @param [label_divisor]]]] Each label is divided by label_divisor before display 
 * @param x X-position
 * @param y Y-position
 * @param size Size in pixels
 * @param [orientation] Either "horizontal", "vertical", "up", or "down"
 * @param [enabled] Boolean True or False
 *
 * #canvas #input #slider
 * 
 */
func Slider { ${{
	var argsProcessed;

	var name;
	if (typeof(arguments[0]) == "string") {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("Slider: Every slider must have a name."), "error");
			return undefined;
		}
	}
	var min = arguments[argsProcessed];
	argsProcessed++;
	var max = arguments[argsProcessed];
	argsProcessed++;

	var step, labelInterval, labelDivisor, tickMarkInterval, x, y, length, orientation, enabled;
	var arg, argType;
	if (typeof(arguments[argsProcessed + 6]) == "number") {
		step = arguments[argsProcessed];
		labelInterval = arguments[argsProcessed + 1];
		tickMarkInterval = arguments[argsProcessed + 2];
		labelDivisor = arguments[argsProcessed + 3];
		argsProcessed = argsProcessed + 4;
	} else if (typeof(arguments[argsProcessed + 5]) == "number") {
		step = arguments[argsProcessed];
		labelInterval = arguments[argsProcessed + 1];
		tickMarkInterval = arguments[argsProcessed + 2];
		argsProcessed = argsProcessed + 3;
	} else if (typeof(arguments[argsProcessed + 4]) == "number") {
		step = arguments[argsProcessed];
		labelInterval = arguments[argsProcessed + 1];
		argsProcessed = argsProcessed + 2;
	} else if (typeof(arguments[argsProcessed + 3]) == "number") {
		step = arguments[argsProcessed];
		argsProcessed++;
	} else if (max - min > 1 && Math.floor(min) == min && Math.floor(max) == max) {
		step = 1;
	}
	x = arguments[argsProcessed];
	y = arguments[argsProcessed + 1];
	length = arguments[argsProcessed + 2];
	argsProcessed = argsProcessed + 3;
	arg = arguments[argsProcessed];
	argType = typeof(arg);
	if (arg === undefined || argType == "string") {
		orientation = arguments[argsProcessed];
		argsProcessed++;
		arg = arguments[argsProcessed];
	}
	enabled = arg;

	if (labelInterval !== undefined) {
		if (labelDivisor === undefined) {
			labelDivisor = 1;
		}
		if (tickMarkInterval === undefined) {
			tickMarkInterval = labelInterval;
		}
	}
	if (orientation === undefined) {
		orientation = "horizontal";
	}
	if (enabled === undefined) {
		enabled = true;
	}

	return new Slider(name, min, max, step, labelInterval, tickMarkInterval, labelDivisor, x, y, length, orientation, enabled);
}}$; }

${{

Slider.prototype.draw = function (context) {

	if (this.elements === undefined) {
		var name = this.name;
		var me = this;
		var agent = root.lookup("Slider");

		var cssClass;
		if (this.orientation == "down"){
			cssClass = "slider-down"
		} else if (this.orientation == "up" || this.orientation == "vertical") {
			cssClass = "slider-up"
		} else {
			cssClass = "slider-horizontal";
		}
		var disabled = this.enabled === false? "disabled=\"disabled\"" : "";
		var inputHTML = '<input ' +
			disabled +
			'type="range" ' +
			'min="' + this.min + '" ' +
			'max="' + this.max + '" ';
		if (this.step === undefined) {
			inputHTML = inputHTML + 'step="0.0000001"';		
		} else {
			inputHTML = inputHTML + 'step="' + this.step + '"';
		}
		inputHTML = inputHTML + '/>';
		var inputJQ = $(inputHTML);
		var inputElem = inputJQ.get(0);
		this.sliderElement = inputElem;

		var valueSym = root.lookup(name + "_value");
		var previewSym = root.lookup(name + "_preview");

		function setValue(obs, value, force) {
			if (typeof(value) != "number") {
				return;
			}
			var previewSym = root.lookup(name + "_preview");
			var previewValue = previewSym.value();
			if (previewValue !== value || force) {
				var roundedValue;
				if (value >= me.min && value <= me.max) {
					inputElem.value = value;
					roundedValue = parseFloat(inputElem.value);
					if (roundedValue != value) {
						//Value didn't match the step size.
						obs.assign(roundedValue, root.scope, agent);
					}
				} else {
					if (value < me.min) {
						inputElem.value = me.min;
					} else {
						inputElem.value = me.max;
					}
					if (me.step !== undefined) {
						roundedValue = Math.round(((value - me.min) / me.step).toPrecision(16)) * me.step + me.min;
						if (roundedValue != value) {
							obs.assign(roundedValue, root.scope, agent);
						}
					} else {
						roundedValue = value;
					}
				}
				if (previewValue != roundedValue) {
					previewSym.assign(roundedValue, root.scope, EdenSymbol.hciAgent);
				}
			}
		}

		valueSym.addJSObserver("updateUI", setValue);
		previewSym.addJSObserver("updateUI", function (obs, preview) {
			if (typeof(preview) != "number") {
				return;
			}
			var previewSym = root.lookup(name + "_preview");
			var valueSym = root.lookup(name + "_value");
			if (previewSym.last_modified_by !== EdenSymbol.hciAgent.name) {
				var roundedValue;
				if (preview >= me.min && preview <= me.max) {
					inputElem.value = preview;
					roundedValue = parseFloat(inputElem.value);
					if (roundedValue != preview) {
						//Value didn't match the step size.
						obs.assign(roundedValue, root.scope, agent);
					}
				} else {
					if (preview < me.min) {
						inputElem.value = me.min;
					} else {
						inputElem.value = me.max;
					}
					if (me.step !== undefined) {
						roundedValue = Math.round(((preview - me.min) / me.step).toPrecision(16)) * me.step + me.min;
						if (roundedValue != value) {
							obs.assign(roundedValue, root.scope, agent);
						}
					} else {
						roundedValue = preview;
					}
				}
				valueSym.assign(roundedValue, root.scope, agent);
			}
		});

		inputJQ
		.on("input", function(){
			root.lookup(name + "_preview").assign(parseFloat(this.value), root.scope, EdenSymbol.hciAgent, true);
		})
		.on("mousedown", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseDownZone").assign(undefined, root.scope, EdenSymbol.hciAgent, mouseFollow);
		})
		.on("mouseup", function () {
			root.lookup(name + "_value").assign(parseFloat(this.value), root.scope, EdenSymbol.hciAgent, true);
			edenUI.plugins.Canvas2D.endClick();
		})
		.on("keyup", function () {
			root.lookup(name + "_value").assign(parseFloat(this.value), root.scope, EdenSymbol.hciAgent, true);		
		})
		.on("mouseenter", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		});

		var outerDiv = $('<div class="' + cssClass + '" ></div>');
		if ((this.tickMarkInterval > 0 || this.labelInterval > 0) && this.max > this.min) {
			var innerDiv = $('<div style="position: relative; height: 100%"></div>');
			outerDiv.append(innerDiv);
			if (this.tickMarkInterval > 0) {
				for (var i = this.min; i <= this.max; i = i + this.tickMarkInterval) {
					var percentage = (i - this.min) / (this.max - this.min) * 100;
					//The offset is to get the centre of the slider thumb positioned exactly on the tick mark.
					var offset = Math.round((50 - percentage) / 100 * 10);
					var position = 'calc(' + percentage + '% + ' + offset + 'px)';
					var tickMark = $('<div"></div>');
					if (this.orientation == "horizontal") {
						tickMark.css("left", position);
					} else {
						tickMark.css("top", position);
					}
					if ((i - this.min) % this.labelInterval == 0) {
						tickMark.addClass("slider-major-tick-mark");
					} else {
						tickMark.addClass("slider-minor-tick-mark");
					}
					innerDiv.append(tickMark);
				}
			}
			inputJQ.css("width", "100%");
			innerDiv.append(inputJQ);
			if (this.labelInterval > 0) {
				if (this.orientation == "horizontal") {
					var labelWidth = 100 / ((this.max - this.min) / this.labelInterval);
					var halfLabelWidth = labelWidth / 2;
					for (var i = this.min; i <= this.max; i = i + this.labelInterval) {
						var percentage = (i - this.min) / (this.max - this.min) * 100 - halfLabelWidth;
						var offset = Math.round((50 - percentage) / 100 * 10);
						var labelText = i / this.labelDivisor;
						var label = $(
							'<div ' + 
								'class="slider-label" ' +
								'style="left: calc(' + percentage + '% + ' + offset + 'px); width: ' + labelWidth + '%"' +
							'>' +
								labelText +
							'</div>'
						);
						innerDiv.append(label);
					}
				} else {
					for (var i = this.max; i >= this.min; i = i - this.labelInterval) {
						var percentage = (this.max - i) / (this.max - this.min) * 100;
						var offset = Math.round((50 - percentage) / 100 * 10 + 1);
						var labelText;
						if (this.orientation == "down") {
							labelText = (this.max - i) / this.labelDivisor;
						} else {
							labelText = i / this.labelDivisor;
						}
						var label = $(
							'<div ' +
								'class="slider-label" ' +
								'style="top: calc(' + percentage + '% + ' + offset + 'px - 0.5em)"' +
							'>' +
								labelText +
							'</div>'
						);
						innerDiv.append(label);
					}
				}
			}
		} else {
			outerDiv.append(inputJQ);
		}
		this.elements = [outerDiv.get(0)];

		//Initialization
		var value = valueSym.value();
		var previewValue = previewSym.value();
		if (value === undefined) {
			if (previewValue === undefined) {
				var defaultValue = (this.max - this.min) / 2 + this.min;
				valueSym.assign(defaultValue, root.scope, agent);
				setValue(valueSym, defaultValue, true);
			} else {
				valueSym.assign(previewValue, root.scope, agent);
				setValue(valueSym, previewValue, true);
			}
		} else {
			setValue(valueSym, value, true);
		}
	}
};

Slider.prototype.scale = function (scale, zoom, origin) {
	if (!this.sliderElement) {
		return;
	}
	var slider = this.sliderElement;
	var sliderStyle = slider.style;
	var divStyle = this.elements[0].style;
	var width = Math.round(this.length * scale);
	var isVertical = this.orientation == "up" || this.orientation == "down" || this.orientation == "vertical";
	if (isVertical) {
		sliderStyle.left = Math.round(-this.length / 2 * scale) + "px";
		sliderStyle.top = Math.round((this.length / 2 - 10) * scale) + "px";
		sliderStyle.width = width + "px";
		divStyle.height = width + "px";
	} else {
		divStyle.width = width + "px";	
	}

	divStyle.fontSize = zoom + "em";
	divStyle.left = Math.round((this.x + origin.x) * scale) + "px";
	divStyle.top =  Math.round((this.y + origin.y) * scale) + "px";

	if (this.step == undefined) {
		slider.step = String((slider.max - slider.min) / (width  - 1)).slice(0, 16);
	}
};

Slider.prototype.toString = function() {
	if (this.name == this.obsName) {
		return "Slider(" + Eden.edenCodeForValues(this.min, this.max, this.step, this.labelInterval,
			this.tickMarkInterval, this.labelDivisor, this.x, this.y, this.length, this.orientation,
			this.enabled) + ")";
	} else {
		return "Slider(" + Eden.edenCodeForValues(this.name, this.min, this.max, this.step,
			this.labelInterval, this.tickMarkInterval, this.labelDivisor, this.x, this.y,
			this.length, this.orientation, this.enabled) + ")";
	}
};

Slider.prototype.getEdenCode = Slider.prototype.toString;

}}$;

${{console.log("Got Here");}}$;
## Copyright (c) 2016, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

func TableLayout {
${{
	var x = arguments[0];
	var y = arguments[1];
	var width, content, drawingOptions;

	var argsProcessed = 2;
	var arg = arguments[2];

	if (Array.isArray(arg)) {
		content = arg;
		argsProcessed++;
	} else {
		width = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		content = arg;
		argsProcessed++;
	}

	arg = arguments[argsProcessed];

	if (typeof(arg) == "object") {
		drawingOptions = arg;
	}

	return new TableLayout(x, y, width, content, drawingOptions);
}}$;
}

${{
	TableLayout = function (x, y, width, content, drawingOptions) {
		this.obsName = root.currentObservableName();
		this.x = x;
		this.y = y;
		this.width = width;
		this.content = content;
		this.drawingOptions = drawingOptions;

		var rows = [ [] ];
		var numRows = 1;
		if (Array.isArray(this.content)) {
			var maxCol = 0;
			for (var i = 0; i < this.content.length; i++) {
				var item = this.content[i];
				var columnNo = item.x;
				var rowNo = item.y;
				if (columnNo !== undefined && rowNo !== undefined) {
					columnNo--;
					rowNo--;
					if (rowNo > numRows - 1) {
						for (var j = numRows; j <= rowNo; j++) {
							rows[j] = [];
						}
						numRows = rowNo + 1;
					}
					var row = rows[rowNo];
					var numColumns = row.length;
					if (columnNo > numColumns - 1) {
						for (var j = numColumns; j <= columnNo; j++) {
							row[j] = [];
						}
						if (columnNo > maxCol) {
							maxCol = columnNo;
						}
					}
					var cell = row[columnNo];
					cell.push(item);
				}
			}
		}
		this.rows = rows;
		this.maxCol = maxCol;
	}

	TableLayout.prototype.hash = function () {
		var hash = this.x + "$$" +
			this.y + "$$" +
			this.width + "$$";

		if (Array.isArray(this.content)) {
			for (var i = 0; i < this.content.length; i++) {
				var item = this.content[i];
				if (item.elements === undefined) {
					return hash + Math.random();
				} else {
					hash = hash + item.hash() + "$$";
				}
			}
		}

		if (this.drawingOptions !== undefined) {

		}

		return hash;
	};

	TableLayout.prototype.toString = function () {
		return "TableLayout(" + Eden.edenCodeForValues(this.x, this.y, this.width, this.content,
			this.drawingOptions) + ")";
	};

	TableLayout.prototype.draw = function (context, scale, viewName) {
		if (this.elements === undefined && Array.isArray(this.content)) {
			var me = this;

			var tableJQ = $(
				'<table class="canvashtml-item canvashtml-table-layout-item" ' +
					'style="left: ' + this.x + 'px; top: ' + this.y + 'px"' +
				'></table>'
			);

			for (var j = 0; j < this.rows.length; j++) {
				var rowItems = this.rows[j];
				var rowJQ = $('<tr class="canvashtml-table-layout-row"></tr>');
				tableJQ.append(rowJQ);
				var rowLength = rowItems.length;
				for (var i = 0; i < rowLength; i++) {
					var cellJQ = $('<td class="canvashtml-table-layout-cell"></td>');
					rowJQ.append(cellJQ);
					var cellItems = rowItems[i];
					var numItems = cellItems.length;
					for (var k = 0; k < numItems; k++) {
						var item = cellItems[k];
						item.draw(context, scale, viewName);
						cellJQ.append(item.elements);
						if (k != numItems - 1) {
							cellJQ.append('<br/>');
						}
					}
				}
				for (i = rowLength; i <= this.maxCol; i++) {
					rowJQ.append('<td class="canvashtml-table-layout-cell">&nbsp;</td>');
				}
			}

			this.elements = tableJQ;
		}
	}

	TableLayout.prototype.resize = function () {
		var scale = this.cachedScale;
		if (scale === undefined) {
			//Not yet added drawn onto a canvas.
			return;
		}

		var element = this.elements[0];
		var style = element.style;
		var autoWidth = this.width === undefined;

		var agent = root.lookup("TableLayout");
		var widthSymName = this.obsName + "_width";
		var heightSymName = this.obsName + "_height";

		if (autoWidth || widthSymName in root.symbols) {
			root.lookup(widthSymName).assign(element.offsetWidth / scale, eden.root.scope, agent);
		}
		root.lookup(heightSymName).assign(element.offsetHeight / scale, eden.root.scope, agent);
	}

	TableLayout.prototype.scale = function (scale, zoom, origin) {
		if (!Array.isArray(this.content)) {
			return;
		}

		var container = this.elements;
		var containerStyle = container[0].style;
		if (this.width !== undefined) {
			containerStyle.width = Math.round(this.width * scale) + "px";
		}
		containerStyle.left = Math.round((this.x + origin.x) * scale) + "px";
		containerStyle.top =  Math.round((this.y + origin.y) * scale) + "px";

		var children = container.children();
		for (var i = 0; i < this.content.length; i++) {
			var item = this.content[i];
			item.scale(scale, zoom, origin);
		}

		this.cachedScale = scale;
		this.resize();
	}

	TableLayout.prototype.getEdenCode = TableLayout.prototype.toString;
}}$;

${{console.log("Got Here");}}$;
## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Text = function(text, x, y, size, fillcolour, outlinecolour, options, valign, align) {
	this.text = text;
	this.x = x;
	this.y = y;
	this.size = size;
	this.fillcolour = fillcolour;
	this.outlinecolour = outlinecolour;

	var optionsType = typeof(options);
	var css;

	if (optionsType == "object") {

		this.drawingOptions = options;

		if (options.italic) {
			css = "italic ";
		} else {
			css = "";
		}
		if (options.smallCaps) {
			css = css + "small-caps ";
		}
		if (options.bold) {
			css = css + "bold ";
		}
		if (size !== undefined) {
			css = css + size + "px ";
		} else {
			css = css + edenUI.plugins.Canvas2D.defaultFontSizePx + "px ";
		}
		if (options.fontFace === undefined) {
			css = css + "sans-serif";
		} else {
			css = css + options.fontFace + ", sans-serif";
		}

	} else if (optionsType == "string") {

		this.drawingOptions = {align: align, valign: valign};
		css = options;

	} else {

		this.drawingOptions = {align: "top"};
		if (size !== undefined) {
			css = size + "px sans-serif";
		} else {
			css = edenUI.plugins.Canvas2D.defaultFontSizePx + "px sans-serif";
		}

	}

	if (this.drawingOptions.align == "centre") {
		this.drawingOptions.align = "center";
	}
	if (this.drawingOptions.valign == "baseline") {
		this.drawingOptions.valign = "alphabetic";
	}

	this.css = css;
	this.optionsType = optionsType;
	this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(options, "Text");
	this.obsName = root.currentObservableName();
}

// RegExp groups: (valign) (align) (style) (size) (font)
Text.cssRegExp = new RegExp(
		"^\\s*(" +
		"?:(top|middle|baseline|alphabetic|ideographic|bottom)?\\s*" + 
		"(\\b(?:left|right|center|centre))?\\s*" +
		"((?:\\bitalic)?\\s*" +
		"(?:\\bsmall-caps)?\\s*" +
		"(?:\\bbold)?)\\s*" +
		"(\\b(?:smaller|larger|(?:\\d+(?:\\.\\d+)?[a-zA-Z%]+)))?\\s*" +
		"(\\b(?:.+,)?\\s*(?:(?:sans-)?serif|monospace|cursive|fantasy))?" +
		")\\s*$"
);

}}$;

#! Create a drawable text object for a canvas. See [drawing options](@external CanvasExamples > drawingoptions) for more font and style options.
# 
# ##Usage Example
#  `Text("Message", x, y);`
#  `Text("Hello", x, y, 20, "red");`
#
# @param text Text string to display
# @param x X-coordinate
# @param y Y-coordinate
# @param [size] Size in pixels, or can be specified as a string with a unit (e.g., "30pt", "2em", etc.)
# @param [fill_colour Text colour in HTML form
# @param [outline_colour]]
# @param [options] Options, in string or object format
# 
#  #canvas #text #label #draw
func Text {
	${{
		var text = arguments[0];
		var x = arguments[1];
		var y = arguments[2];
		var size, fillcolour, outlinecolour, options, valign, align;

		var numArgs = arguments.length;
		var argsLeft = numArgs - 3;
		var argsProcessed = 3;

		if (arguments[3] === undefined || typeof(arguments[3]) == "number") {
			size = arguments[3];
			argsProcessed++;
			argsLeft--;
		}

		var lastArg = arguments[numArgs - 1];
		var argType = typeof(lastArg);
		var match;

		if (argType == "string") {
			match = lastArg.match(Text.cssRegExp);
		}

		if (match) {
			argsLeft--;
			valign = match[1];
			align = match[2];
			if (match[3]) {
				// italic, bold, etc.
				options = match[3];
			} else {
				options = "";
			}
			if (match[4]) {
				// size
				options = options + " " + match[4];
			} else if (size !== undefined) {
				options = options + " " + size + "px";
			} else {
				options = options + " " + edenUI.plugins.Canvas2D.defaultFontSizePx + "px";
			}
			if (match[5]) {
				// font family
				options = options + " " + match[5];
			} else {
				options = options + " sans-serif";
			}

		} else if (argType == "object" && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
			argsLeft--;
			options = lastArg;
		}

		if (argsLeft > 0) {
			fillcolour = arguments[argsProcessed];
			argsLeft--;
			argsProcessed++;
			if (argsLeft > 0) {
				outlinecolour = arguments[argsProcessed];
			}
		}

		if (outlinecolour === undefined && fillcolour === undefined) {
			fillcolour = "black";
		}
		return new Text(text, x, y, size, fillcolour, outlinecolour, options, valign, align);
	}}$;
}

${{

Text.prototype.draw = function (context, scale) {

	if (scale != 1) {
		var inverseScale = 1 / scale;
		if (scale >= 0) {
			context.scale(inverseScale, inverseScale);
		} else {
			context.scale(-inverseScale, inverseScale);
		}
	}
	context.font = this.css;
	if (this.drawingOptions.valign) {
		context.textBaseline = this.drawingOptions.valign;
	} else {
		context.textBaseline = "top";
	}

	var lineWidth;
	if (this.outlinecolour !== undefined) {
		lineWidth = context.lineWidth;
	} else {
		lineWidth = 0;
	}

	var x = (this.x + lineWidth / 2) * scale + 1;
	var y = this.y * scale + 1;

	var align = this.drawingOptions.align;
	if (align) {
		context.textAlign = align;
		if (align == "center") {
			x--;
		}
	}

	if (this.fillcolour !== undefined) {
		edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
		context.fillText(this.text, x, y);
	}
	if (this.outlinecolour !== undefined) {
		context.lineWidth = lineWidth * scale;
		context.strokeStyle = this.outlinecolour;
		context.strokeText(this.text, x, y);	
	}
};



Text.prototype.toString = function() {
	var s = "Text(" + Eden.edenCodeForValues(this.text, this.x, this.y, this.size, this.fillcolour,
		this.outlinecolour);
	var optionsType = this.optionsType;

	if (optionsType == "string") {
		s = s + ", \"";
		if (this.drawingOptions.valign) {
			s = s + this.drawingOptions.valign + " ";
		}
		if (this.drawingOptions.align) {
			s = s + this.drawingOptions.align + " ";
		}
		s = s + this.css + "\")";
	} else if (optionsType == "object") {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions) + ")";
	}
	return s;
};

Text.prototype.getEdenCode = Text.prototype.toString;

Text.parseArgs = function () {
	var text = arguments[0];
	var size;
	var css, optionsObj, scale;

	var argsProcessed = 1;
	var arg = arguments[1];
	var argType = typeof(arg);

	if (arg === undefined || argType == "number") {
		size = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}

	if (argType == "string") {

		var match = arg.match(Text.cssRegExp);
		if (match) {
			if (match[3]) {
				// italic, bold, etc.
				css = match[3];
			} else {
				css = "";
			}
			if (match[4]) {
				// size
				css = css + " " + match[4];
			} else if (size !== undefined) {
				css = css + " " + size + "px";
			} else {
				css = css + " 1em";
			}
			if (match[5]) {
				// font family
				css = css + " " + match[5];
			} else {
				css = css + " sans-serif";
			}
		} else {
			css = arg;
		}

		argsProcessed++;
		arg = arguments[argsProcessed];

	} else if (argType == "object") {

		optionsObj = arg;
		if (arg.italic) {
			css = "italic ";
		} else {
			css = "";
		}
		if (arg.smallCaps) {
			css = css + "small-caps ";
		}
		if (arg.bold) {
			css = css + "bold ";
		}
		if (size) {
			css = css + size + "px ";
		} else {
			css = css + "1em ";
		}
		if (arg.fontFace === undefined) {
			css = css + "sans-serif";
		} else {
			css = css + arg.fontFace + ", sans-serif";
		}

		argsProcessed++;
		arg = arguments[argsProcessed];

	} else if (arg === undefined) {

		if (size !== undefined) {
			css = size + "px sans-serif";
		} else {
			css = edenUI.plugins.Canvas2D.defaultFontSizePx + "px sans-serif";
		}

		argsProcessed++;
		arg = arguments[argsProcessed];

	}

	scale = arg;
	if (scale === undefined) {
		scale = 1;
	}

	return [css, optionsObj, scale];
};

}}$;

${{console.log("Got Here");}}$;
## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Textbox = function (name, x, y, width, height, placeholder, maxlength, enabled) {
	this.name = name;
	this.obsName = root.currentObservableName();
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.placeholder = placeholder;
	this.maxlength = maxlength;
    this.enabled = enabled;
}

Textbox.prototype.hash = function () {
	return this.name+"$$"+
				this.x+"$$"+
				this.y+"$$"+
				this.width+"$$"+
				this.height+"$$"+
				this.placeholder+"$$"+
				this.maxlength+"$$"+
				this.enabled;
};
}}$;

/**
 * Creates a text input box for drawing on the canvas
 * 
 * @param [name] Prefix for _value observable.  Default is the name of the observable being defined.
 * @param x X-position
 * @param y Y-position
 * @param [width
 * @param [height]]
 * @param [placeholder_text] Text to be displayed by default
 * @param [max_characters] Maximum number of characters allowed in input box
 * @param [enabled] Boolean (true or false) to enable or disable input
 * 
 * #canvas #input #text #textbox
 */

	
func Textbox { ${{
	var argsProcesssed;

	var name;
	if (typeof(arguments[0]) == "string") {
		name = arguments[0];
		argsProcessed = 1;
	} else {
		name = root.currentObservableName();
		argsProcessed = 0;
		if (name === undefined) {
			eden.error(new Error("Textbox: Every text box must have a name."), "error");
			return undefined;
		}
	}

	var x = arguments[argsProcessed];
	argsProcessed++;
	var y = arguments[argsProcessed];
	argsProcessed++;

	var width, height, placeholder, maxlength, enabled;
	var arg = arguments[argsProcessed];
	var argType = typeof(arg);

	if (arg === undefined || argType == "number") {
		width = arguments[argsProcessed];
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}

	if (arg === undefined || argType == "number") {
		height = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}
	if (arg === undefined || argType == "string") {
		placeholder = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		argType = typeof(arg);
	}
	if (arg === undefined || argType == "number") {
		maxlength = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
	}
	enabled = arg;
	return new Textbox(name, x, y, width, height, placeholder, maxlength, enabled);
}}$; }

${{
Textbox.prototype.draw = function(context) {	

	if(this.elements === undefined) {
		var me = this;
		var name = this.name;

		var disabled = this.enabled === false? 'disabled="disabled"' : '';
		var placeholder;
		var maxlength = this.maxlength !== undefined? ' maxlength="' + this.maxlength + '"' : '';
		var jQuery;
		if (this.height === undefined) {
			placeholder = ' placeholder="' +
				(this.placeholder === undefined? name : this.placeholder) + '"';
			jQuery = $('<input type="text" ' + disabled + placeholder + maxlength + ' class="canvashtml-item" />');
		} else {
			// Placeholder text for textarea tag is buggy in IE11, so don't use it by default.
			placeholder = this.placeholder !== undefined && this.placeholder != ""?
				' placeholder="' + this.placeholder + '"' :
				'';
			jQuery = $('<textarea ' + disabled + placeholder + maxlength + ' class="canvashtml-item"></textarea>');
		}

		var element = jQuery.get(0);
		var valueSymbol = root.lookup(name + "_value");
		var value = valueSymbol.value();
		if (value === undefined) {
			valueSymbol.assign("", root.scope, root.lookup("Textbox"));
		} else {
			element.value = value;
		}
		valueSymbol.addJSObserver("updateTextbox", function (obs, value) {
			me.elements[0].value = value;
		});

		jQuery
		.on("input", function(event) {
			root.lookup(name + "_value").assign(event.target.value, root.scope, EdenSymbol.hciAgent, true);
		})
		.on("mousedown", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseDownZone").assign(undefined, root.scope, EdenSymbol.hciAgent, mouseFollow);
		})
		.on("mouseup", function () {
			edenUI.plugins.Canvas2D.endClick();
		})
		.on("mouseenter", function () {
			var mouseFollow = root.lookup("mouseFollow").value();
			root.lookup("mouseZone").assign(name, root.scope, EdenSymbol.hciAgent, mouseFollow);
		});

		this.elements = [element];
  }
};

Textbox.prototype.scale = function (scale, zoom, origin) {
	var style = this.elements[0].style;
	style.left = Math.round((this.x + origin.x) * scale) + "px";
	style.top =  Math.round((this.y + origin.y) * scale) + "px";
	style.width = Math.round(this.width * scale - 6) + "px";
	if (this.height !== undefined) {
		var lineHeight = edenUI.plugins.Canvas2D.defaultLineHeight;
		var rows = Math.floor(Math.round(this.height * scale - 4) / (lineHeight * zoom));	//See css/eden.css
		if (rows == 0) {
			rows = 1;
		}
		style.height = (rows * lineHeight * zoom) + "px";
	}
	style.fontSize = (edenUI.plugins.Canvas2D.defaultFontSizePx * zoom) + "px";
	style.transform = "scale("+zoom+")";
};

Textbox.prototype.toString = function() {
	if (this.name == this.obsName) {
		return "Textbox(" + Eden.edenCodeForValues(this.x, this.y, this.width,
			this.height, this.placeholder, this.enabled) + ")";
	} else {
		return "Textbox(" + Eden.edenCodeForValues(this.name, this.x, this.y, this.width,
			this.height, this.placeholder, this.enabled) + ")";	
	}
};

Textbox.prototype.getEdenCode = Textbox.prototype.toString;

}}$;

${{console.log("Got Here");}}$;
## Copyright (c) 2015, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{

	Translation = function (centreX, centreY, x, y, items) {
		this.centreX = centreX;
		this.centreY = centreY;
		this.x = x;
		this.y = y;
		this.items = items;
	}

	Translation.prototype = new EdenUI.plugins.Canvas2D.Transform;

	Translation.prototype.transform = function (context) {
		context.translate(this.x - this.centreX, this.y - this.centreY);
	}
	
	Translation.prototype.getCSS = function (scale) {
		var x = (this.x - this.centreX) * scale;
		var y = (this.y - this.centreY) * scale;
		return "translate(" + x + "px, " + y + "px)";
	}

	Translation.prototype.inverse = function (x, y) {
		return new Point(x - (this.x - this.centreX), y - (this.y - this.centreY));
	}

	Translation.prototype.toString = function () {
		return "Translate(" + Eden.edenCodeForValues(this.centreX, this.centreY, this.x, this.y, this.items) + ")";
	}

	Translation.prototype.getEdenCode = Translation.prototype.toString;

}}$;

func Translate {
	${{
		var centreX, centreY, x, y, items;
		var argNum = arguments.length - 1;
		if (argNum == 0) {
			eden.error(new Error("Translate: This function requires at least 2 arguments."), "error");
			return undefined;
		}
		items = arguments[argNum];
		argNum--;
		arg = arguments[argNum];
		if (arg instanceof Point) {
			x = arg.x;
			y = arg.y;
			argNum--;
		} else if (argNum >= 1) {
			y = arg;
			argNum--;
			x = arguments[argNum];
			argNum--;
		}
		if (argNum >= 0) {
			arg = arguments[argNum];
			if (arg instanceof Point) {
				centreX = arg.x;
				centreY = arg.y;
				argNum--;
			} else if (argNum >= 1) {
				centreY = arg;
				argNum--;
				centreX = arguments[argNum];
				argNum--;
			}		
		}
		if (argNum >= 0) {
			eden.error(new Error("Translate: invalid parameters."), "error");
			return undefined;
		}

		if (typeof(x) !== "number") {
			eden.error(new Error("Translate: The destination X coordinate must be a number, not a " + typeof(x)), "error");
			return undefined;
		}
		if (typeof(y) !== "number") {
			eden.error(new Error("Translate: The destination Y coordinate must be a number, not a " + typeof(y)), "error");
			return undefined;
		}
		if (centreX === undefined) {
			centreX = 0;
		}
		if (centreY === undefined) {
			centreY = 0;
		}
		return new Translation(centreX, centreY, x, y, items);
	}}$;
}


# Copyright (c) 2013, Empirical Modelling Group
# All rights reserved.
#
# See LICENSE.txt

${{
View = function (name, type, x, y, width, height) {
	this.type = type;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.name = name;
}

View.prototype.hash = function () {
	return this.x+"$$"+
		this.y+"$$"+
		this.width+"$$"+
		this.height+"$$"+
		this.type+"$$"+
		this.name+"$$";
};
}}$

/**
 * Create a View tag to display an embedded view
 * 
 * @param name
 * @param type
 * @param x X-coordinate
 * @param y Y-coordinate
 * @param [width Width in pixels or as a string or undefined
 * @param [height]] Height in pixels or as a string or undefined
 * #canvas #view #embedded
 */
func View { ${{
	var name = arguments[0];
	var type = arguments[1];
	var x = arguments[2];
	var y = arguments[3];
	var width, height;   //Number of pixels, string (e.g. "50%") or undefined (automatic)
	
	var argsProcessed = 4;
	var argType = typeof(arguments[4]);
	
	if (argType == "number" || argType == "undefined") {
		width = arguments[4];
		argsProcessed++;
		
		argType = typeof(arguments[5]);
		if (argType == "number" || argType == "undefined") {
			height = arguments[5];
			argsProcessed++;
		}
	}

	return new View(name, type, x, y, width, height);
}}$ }

${{


View.prototype.resize = function () {
	var scale = this.cachedScale;
	if (scale === undefined) {
		//Not yet added drawn onto a canvas.
		return;
	}

	var element = this.elements[0];
	var style = element.style;
	//style.transform = "scale("+scale+")";
	var autoWidth = this.width === undefined;
	var autoHeight = this.height === undefined;

	/*if (autoWidth) {
		var savedHeight = style.height;
		style.width = "auto";
		style.height = "auto";
		var contentWidth = element.clientWidth;
		style.width = contentWidth + "px";
		style.height = savedHeight;
		var scrollBarSize = element.offsetWidth - element.clientWidth;
		if (scrollBarSize > 0) {
			scrollBarSize = scrollBarSize + 2;
			style.width = String(contentWidth + scrollBarSize) + "px";
		} else {
			style.width = "auto";
		}
	}*/

	if (this.name !== undefined) {
		var agent = root.lookup("Div");
		var widthSymName = this.name + "_width";
		var heightSymName = this.name + "_height";

		if (autoWidth || widthSymName in eden.root.symbols) {
			root.lookup(widthSymName).assign(element.offsetWidth / scale, root.scope, agent);
		}
		if (autoHeight || heightSymName in eden.root.symbols) {
			root.lookup(heightSymName).assign(element.offsetHeight / scale, root.scope, agent);
		}
	}
}

View.prototype.scale = function (scale, zoom , origin) {
	var style = this.elements[0].style;
	style.left = Math.round((this.x + origin.x) * scale) + "px";
	style.top = Math.round((this.y + origin.y) * scale) + "px";

	if (this.width !== undefined) {
		style.width = Math.round(this.width) + "px";
	}
	if (this.height !== undefined) {
		style.height = Math.round(this.height) + "px";
	}
	/*if (this.fontSizeSpecified) {
		style.fontSize = String(this.fontSizeNumber * zoom) + this.fontSizeUnits;
	} else {
		if (zoom == 1) {
			style.fontSize = ""; //Could be specified by a CSS class.
		} else {
			style.fontSize = zoom + "em";
		}
	}*/
	if (scale != this.cachedScale) {
		style.transform = "scale("+scale+")";
		this.transformCSS = "scale("+scale+")";
	}
	this.cachedScale = scale;
	this.resize();
};

View.prototype.toString = function() {
	return this.getEdenCode();
};

View.prototype.getEdenCode = function () {
	var s = "View(" + Eden.edenCodeForValues(this.name, this.type, this.x, this.y, this.width, this.height)+")";
	return s;
};

}}$;
