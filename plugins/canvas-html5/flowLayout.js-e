## Copyright (c) 2016, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

func FlowLayout {
${{
	var x = arguments[0];
	var y = arguments[1];
	var width, content, drawingOptions;

	var argsProcessed = 2;
	var arg = arguments[2];

	if (Array.isArray(arg)) {
		content = arg;
		argsProcessed++;
	} else {
		width = arg;
		argsProcessed++;
		arg = arguments[argsProcessed];
		content = arg;
		argsProcessed++;
	}

	arg = arguments[argsProcessed];

	if (typeof(arg) == "object") {
		drawingOptions = arg;
	}

	return new FlowLayout(x, y, width, content, drawingOptions);
}}$;
}

${{
	FlowLayout = function(x, y, width, content, drawingOptions) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.content = content;
		this.drawingOptions = drawingOptions;
	};

	FlowLayout.prototype.hash = function () {
		var hash = this.x + "$$" +
			this.y + "$$" +
			this.width + "$$";

		if (Array.isArray(this.content)) {
			for (var i = 0; i < this.content.length; i++) {
				hash = hash + this.content[i].hash() + "$$";
			}
		}
		
		if (this.drawingOptions !== undefined) {
			hash = hash +
				this.drawingOptions.align + "$$" +
				this.drawingOptions.valign + "$$" +
				this.drawingOptions.spacing + "$$" +
				this.drawingOptions.vspacing;
		}

		return hash;
	};

	FlowLayout.prototype.toString = function () {
		return "FlowLayout(" + Eden.edenCodeForValues(this.x, this.y, this.width, this.content,
			this.drawingOptions) + ")";
	};

	FlowLayout.prototype.draw = function (context, scale, viewName) {
		if (this.elements === undefined && Array.isArray(this.content)) {
			var container = $(
				'<div class="canvashtml-item canvashtml-flow-layout-item" ' +
				'style="left: ' + this.x + 'px; top: ' + this.y + 'px"' +
				'></div>'
			);
			
			if (this.drawingOptions !== undefined) {
				var align = this.drawingOptions.align;
				if (align == "right") {
					container.css("justify-content", "flex-end");
				} else if (align == "centre" || align == "center") {
					container.css("justify-content", "center");
				} else if (align == "justify") {
					container.css("justify-content", "space-between");
				}
				var vAlign = this.drawingOptions.valign;
				if (vAlign == "bottom") {
					container.css("align-items", "flex-end");
				} else if (vAlign == "baseline") {
					container.css("align-items", "baseline");
				} else if (vAlign !== "top") {
					container.css("align-items", "center");
				}
			}

			for (var i = 0; i < this.content.length; i++) {
				var item = this.content[i];
				item.draw(context, scale, viewName);
				var childContainer = $('<div></div>');
				childContainer.append(item.elements);
				container.append(childContainer);
			}
			this.elements = container;
		}
	}

	FlowLayout.prototype.scale = function(scale, zoom, origin) {
		if (!Array.isArray(this.content)) {
			return;
		}

		var align, vAlign, spacing, vSpacing;
		if (this.drawingOptions !== undefined) {
			align = this.drawingOptions.align;
			vAlign = this.drawingOptions.valign;
			spacing = this.drawingOptions.spacing;
			vSpacing = this.drawingOptions.vspacing;
		}
		if (spacing === undefined) {
			spacing = 14;
		}
		if (vSpacing === undefined) {
			vSpacing = 10;
		}

		var container = this.elements;
		var children = container.children();

		var actualLeft, actualTop;
		var padLeft, padRight, padTop, padBottom;

		if (align == "centre" || align == "center") {
			//Place padding on both sides (left and right)
			padLeft = spacing / 2;
			padRight = spacing / 2;
			actualLeft = this.x - this.width / 2 - spacing / 2;
		} else {
			//Place padding on the left side.
			padLeft = spacing;
			padRight = 0;
			actualLeft = this.x - spacing;
		}

		if (vAlign === undefined || vAlign == "middle") {
			//Place padding on both sides (top and bottom)
			padTop = vSpacing / 2;
			padBottom = vSpacing / 2;
			actualTop = this.y - vSpacing / 2;
		} else {
			//Place padding on the top side
			padTop = vSpacing;
			padBottom = 0;
			actualTop = this.y - vSpacing;
		}

		var containerStyle = container[0].style;
		if (this.width !== undefined) {
			actualWidth = this.width + spacing;
			containerStyle.width = Math.round(actualWidth * scale) + "px";
		}
		if (align == "centre" || align == "center") {
			containerStyle.left = "calc(" + Math.round((this.x + origin.x) * scale) + "px - 50%)";
			containerStyle.width = "100%";
		} else {
			containerStyle.left = Math.round((actualLeft + origin.x) * scale) + "px";
		}
		containerStyle.top =  Math.round((actualTop + origin.y) * scale) + "px";

		for (var i = 0; i < children.length; i++) {
			var item = this.content[i];
			var childStyle = children[i].style;
			childStyle.paddingRight = Math.ceil((padRight + item.x) * scale) + "px";
			childStyle.paddingBottom = Math.ceil((padBottom + item.y) * scale) + "px";
			item.scale(scale, zoom, origin);
		}
		children.css("padding-left", Math.floor(padLeft * scale) + "px");
		children.css("padding-top", Math.floor(padTop * scale) + "px");

	};

	FlowLayout.prototype.getEdenCode = FlowLayout.prototype.toString;
}}$;