
mouseButton = "";
mouseButtons = "";
mouseCapture = false;
mouseCaptured = false;
mouseContextMenuEnabled = false;
mouseDoubleClicks = 0;
mouseDown = @;
mouseDownView = @;
mouseDownZone = @;
mouseFollow = false;
mousePosition = @;
mousePressed = false;
mouseUp = @;
mouseWheel = 0;
mouseWheelEnabled = false;
mouseWheelVelocity = 0;
mouseView = @;
mouseX is @ if mousePosition == @ else mousePosition["x"];
mouseY is @ if mousePosition == @ else mousePosition["y"];
mouseZone = @;
pixel is 1 / _view_picture_scale;
touchPanX = 0;
touchPanXSpeed = 0;
touchPinch = 0;
touchPinchEnabled = false;


${{
root.lookup("mouseCapture").addJSObserver("releaseCapture", function (obs, lock) {
if (!lock && document.exitPointerLock) {
document.exitPointerLock();
}
});
}}$;

proc attemptMouseCapture {
${{
var canvasName = root.lookup("mouseView").value();
if (canvasName !== undefined) {
canvases[canvasName].requestPointerLock();
}
}}$;
}

proc createCanvas {
para p1, p2, p3;
auto obsName, viewTitle, viewName;
auto titleSymName, contentSymName, addJSObserver;
auto argc;
argc = ${{ arguments.length }}$;

if (argc == 1) {
obsName = p1;
} else if (argc == 2) {
obsName = p1;
viewTitle = p2;
} else if (argc == 3) {
viewName = p1;
obsName = p2;
viewTitle = p3;
if (!isString(viewName)) {
error("createCanvas: The first argument must be a string, not a " // type(viewName));
return;
}
} else {
error("createCanvas: This procedure requires at least 1 argument and at most 3 arguments.");
return;
}



if (isPointer(obsName)) {
obsName = nameof(obsName);
} else if (!isString(obsName)) {
error("createCanvas: The observable name must be expressed as a string or a pointer, not a " // type(obsName));
return;
}

if (viewName == @) {
viewName = obsName;
}

if (viewTitle != @ && !isString(viewTitle)) {
error("createCanvas: The window title must be a string, not a " // type(viewTitle));
return;
}

if (`obsName` == @) {
`obsName` = [];
}

createView(viewName, "Canvas2D");
execute2("_view_" // viewName // "_content is " // obsName // ";");
if (viewTitle == @) {
viewTitle = "Canvas " // obsName;
}
`"_view_" // viewName // "_title"` = viewTitle;
}

func canvasURL {
${{
var canvasName;
if (arguments.length > 1) {
eden.error(new Error("canvasURL: This function requires at most one argument."), "error");
return "";
} else if (arguments.length == 0) {
canvasName = "picture";
} else {
canvasName = arguments[0];
if (canvasName === undefined) {
return "";
} else if (typeof(canvasName) == "string") {
if (!(canvasName in canvases)) {
return "";
}
} else {
eden.error(new Error("canvasURL: The first argument must be a string, not a " + typeof(canvasName)), "error");
return "";
}
}

return canvases[canvasName].toDataURL();
}}$;
}

func shapeOnTopAt {
${{
var target = arguments[0];
var x, y, testAll;
if (arguments.length < 2 || arguments.length > 4) {
eden.error(new Error("shapeOnTopAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
return undefined;
}
if (arguments[1] instanceof Point) {
x = arguments[1].x;
y = arguments[1].y;
testAll = arguments[2];
} else {
x = arguments[1];
y = arguments[2];
testAll = arguments[3];
}

if (target === undefined || x === undefined || y === undefined) {
return undefined;
}
if (target instanceof Symbol) {
var match = target.name.match(/^\/_view_(.*)_content$/);
if (match === null) {
eden.error(new Error("shapeOnTopAt: The first argument must be either a string or a pointer to a _view_xxx_content observable, not " +
Eden.edenCodeForValue(target)), "error");
return undefined;
} else {
target = match[1];
}
} else if (typeof(target) != "string") {
eden.error(new Error("shapeOnTopAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");
return undefined;
}
if (typeof(x) != "number") {
eden.error(new Error("shapeOnTopAt: The x-coordinate must be a number, not a " + typeof(x)), "error");
return undefined;
} else if (typeof(y) != "number") {
eden.error(new Error("shapeOnTopAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
return undefined;
}
return edenUI.plugins.Canvas2D.findDrawableHit(target, x, y, false, testAll);
}}$;
}

func shapeOnBottomAt {
${{
var target = arguments[0];
var x, y, testAll;
if (arguments.length < 2 || arguments.length > 4) {
eden.error(new Error("shapeOnBottomAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
return undefined;
}
if (arguments[1] instanceof Point) {
x = arguments[1].x;
y = arguments[1].y;
testAll = arguments[2];
} else {
x = arguments[1];
y = arguments[2];
testAll = arguments[3];
}

if (target === undefined || x === undefined || y === undefined) {
return undefined;
}
if (target instanceof Symbol) {
var match = target.name.match(/^\/_view_(.*)_content$/);
if (match === null) {
eden.error(new Error("shapeOnBottomAt: The first argument must be either a string or a pointer to a _view_xxx_content observable, not " +
Eden.edenCodeForValue(target)), "error");
return undefined;
} else {
target = match[1];
}
} else if (typeof(target) != "string") {
eden.error(new Error("shapeOnBottomAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");
return undefined;
}
if (typeof(x) != "number") {
eden.error(new Error("shapeOnBottomAt: The x-coordinate must be a number, not a " + typeof(x)), "error");
return undefined;
} else if (typeof(y) != "number") {
eden.error(new Error("shapeOnBottomAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
return undefined;
}
return edenUI.plugins.Canvas2D.findDrawableHit(target, x, y, true, testAll);
}}$;
}

func zoneOnTopAt {
auto drawable;
drawable = apply(shapeOnTopAt, ${{ arguments }}$);
if (drawable == @) {
return @;
} else {
return drawable["name"];
}
}

func zoneOnBottomAt {
auto drawable;
drawable = apply(shapeOnBottomAt, ${{ arguments }}$);
if (drawable == @) {
return @;
} else {
return drawable["name"];
}
}

func observableForShape {
${{
var drawable = arguments[0];
if (drawable === undefined) {
return undefined;
} else if ("obsName" in drawable) {
return drawable["obsName"];
} else {
return drawable["name"];
}
}}$;
}

func observableOnTopAt {
auto drawable;
drawable = apply(shapeOnTopAt, ${{ arguments }}$);
return observableForShape(drawable);
}

func observableOnBottomAt {
auto drawable;
drawable = apply(shapeOnBottomAt, ${{ arguments }}$);
return observableForShape(drawable);
}

func shapesAt {
${{
var target = arguments[0];
var x, y, testAll;
if (arguments.length < 2 || arguments.length > 4) {
eden.error(new Error("shapesAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
return undefined;
}
if (arguments[1] instanceof Point) {
x = arguments[1].x;
y = arguments[1].y;
testAll = arguments[2];
} else {
x = arguments[1];
y = arguments[2];
testAll = arguments[3];
}

if (target === undefined || x === undefined || y === undefined) {
return undefined;
}
if (target instanceof Symbol) {
var match = target.name.match(/^\/_view_(.*)_content$/);
if (match === null) {
eden.error(new Error("shapesAt: The first argument must be either a string or a pointer to a _view_xxx_content observable, not " +
Eden.edenCodeForValue(target)), "error");
return undefined;
} else {
target = match[1];
}
} else if (typeof(target) != "string") {
eden.error(new Error("shapesAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");
return undefined;
}
if (typeof(x) != "number") {
eden.error(new Error("shapesAt: The x-coordinate must be a number, not a " + typeof(x)), "error");
return undefined;
} else if (typeof(y) != "number") {
eden.error(new Error("shapesAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
return undefined;
}
return edenUI.plugins.Canvas2D.findAllDrawablesHit(target, x, y, testAll);
}}$;
}

func zonesAt {
auto drawables, zones, i;
drawables = apply(shapesAt, ${{ arguments }}$);
zones = [];
for (i = 1; i <= drawables#; i++) {
append zones, drawables[i]["name"];
}
return zones;
}

func observablesAt {
auto drawables, obsList, obsName, i;
drawables = apply(shapesAt, ${{ arguments }}$);
obsList = [];
for (i = 1; i <= drawables#; i++) {
obsName = observableForShape(drawables[i]);
if (obsName != @) {
append obsList, obsName;
}
}
return obsList;
}

import plugins/canvas/arc;
import plugins/canvas/arrowhead;
import plugins/canvas/button;
import plugins/canvas/checkbox;
import plugins/canvas/circle;
import plugins/canvas/combobox;
import plugins/canvas/curve;
import plugins/canvas/div;
import plugins/canvas/dropdownlist;
import plugins/canvas/ellipse;
import plugins/canvas/fillpattern;
import plugins/canvas/flowlayout;
import plugins/canvas/greypixellist;
import plugins/canvas/canvasimage;
import plugins/canvas/htmlimage;
import plugins/canvas/line;
import plugins/canvas/lineargradient;
import plugins/canvas/linesequence;
import plugins/canvas/polygon;
import plugins/canvas/rectangle;
import plugins/canvas/slider;
import plugins/canvas/text;
import plugins/canvas/pixel;
import plugins/canvas/pixellist;
import plugins/canvas/radialgradient;
import plugins/canvas/radiobuttons;
import plugins/canvas/regularpolygon;
import plugins/canvas/rotation;
import plugins/canvas/roundedrectangle;
import plugins/canvas/scaling;
import plugins/canvas/sector;
import plugins/canvas/shadow;
import plugins/canvas/textbox;
import plugins/canvas/translation;
import plugins/canvas/video;


