
mouseButton = "";
mouseButtons = "";
mouseCapture = false;
mouseCaptured = false;
mouseContextMenuEnabled = false;
mouseDoubleClicks = 0;
mouseDown = @;
mouseDownView = @;
mouseDownZone = @;
mouseFollow = false;
mousePosition = @;
mousePressed = false;
mouseUp = @;
mouseWheel = 0;
mouseWheelEnabled = false;
mouseWheelVelocity = 0;
mouseView = @;
mouseX is mousePosition == @? @ : mousePosition["x"];
mouseY is mousePosition == @? @ : mousePosition["y"];
mouseZone = @;
pixel is 1 / _view_picture_scale;
touchPanX = 0;
touchPanXSpeed = 0;
touchPinch = 0;
touchPinchEnabled = false;


${{
root.lookup("mouseCapture").addJSObserver("releaseCapture", function (obs, lock) {
if (!lock && document.exitPointerLock) {
document.exitPointerLock();
}
});
}}$;

proc attemptMouseCapture {
${{
var canvasName = root.lookup("mouseView").value();
if (canvasName !== undefined) {
canvases[canvasName].requestPointerLock();
}
}}$;
}

proc createCanvas {
auto obsName, viewTitle, viewName;
auto titleSymName, contentSymName, addJSObserver;
if ($# == 1) {
obsName = $[1];
} else if ($# == 2) {
obsName = $[1];
viewTitle = $[2];
} else if ($# == 3) {
viewName = $[1];
obsName = $[2];
viewTitle = $[3];
if (!isString(viewName)) {
error("createCanvas: The first argument must be a string, not a " // type(viewName));
return;
}
} else {
error("createCanvas: This procedure requires at least 1 argument and at most 3 arguments.");
return;
}

if (isPointer(obsName)) {
obsName = nameof(obsName);
} else if (!isString(obsName)) {
error("createCanvas: The observable name must be expressed as a string or a pointer, not a " // type(obsName));
return;
}
if (viewName == @) {
viewName = obsName;
}
if (viewTitle != @ && !isString(viewTitle)) {
error("createCanvas: The window title must be a string, not a " // type(viewTitle));
return;
}

if (`obsName` == @) {
`obsName` = [];
}

createView(viewName, "Canvas2D");
execute("_view_" // viewName // "_content is " // obsName // ";");
if (viewTitle == @) {
viewTitle = "Canvas " // obsName;
}
`"_view_" // viewName // "_title"` = viewTitle;
}

func canvasURL {
${{
var canvasName;
if (arguments.length > 1) {
eden.error(new Error("canvasURL: This function requires at most one argument."), "error");
return "";
} else if (arguments.length == 0) {
canvasName = "picture";
} else {
canvasName = arguments[0];
if (canvasName === undefined) {
return "";
} else if (typeof(canvasName) == "string") {
if (!(canvasName in canvases)) {
return "";
}
} else {
eden.error(new Error("canvasURL: The first argument must be a string, not a " + typeof(canvasName)), "error");
return "";
}
}

return canvases[canvasName].toDataURL();
}}$;
}

func shapeOnTopAt {
${{
var target = arguments[0];
var x, y, testAll;
if (arguments.length < 2 || arguments.length > 4) {
eden.error(new Error("shapeOnTopAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
return undefined;
}
if (arguments[1] instanceof Point) {
x = arguments[1].x;
y = arguments[1].y;
testAll = arguments[2];
} else {
x = arguments[1];
y = arguments[2];
testAll = arguments[3];
}

if (target === undefined || x === undefined || y === undefined) {
return undefined;
}
if (target instanceof Symbol) {
var match = target.name.match(/^\/_view_(.*)_content$/);
if (match === null) {
eden.error(new Error("shapeOnTopAt: The first argument must be either a string or a pointer to a _view_xxx_content observable, not " +
Eden.edenCodeForValue(target)), "error");
return undefined;
} else {
target = match[1];
}
} else if (typeof(target) != "string") {
eden.error(new Error("shapeOnTopAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");
return undefined;
}
if (typeof(x) != "number") {
eden.error(new Error("shapeOnTopAt: The x-coordinate must be a number, not a " + typeof(x)), "error");
return undefined;
} else if (typeof(y) != "number") {
eden.error(new Error("shapeOnTopAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
return undefined;
}
return edenUI.plugins.Canvas2D.findDrawableHit(target, x, y, false, testAll);
}}$;
}

func shapeOnBottomAt {
${{
var target = arguments[0];
var x, y, testAll;
if (arguments.length < 2 || arguments.length > 4) {
eden.error(new Error("shapeOnBottomAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
return undefined;
}
if (arguments[1] instanceof Point) {
x = arguments[1].x;
y = arguments[1].y;
testAll = arguments[2];
} else {
x = arguments[1];
y = arguments[2];
testAll = arguments[3];
}

if (target === undefined || x === undefined || y === undefined) {
return undefined;
}
if (target instanceof Symbol) {
var match = target.name.match(/^\/_view_(.*)_content$/);
if (match === null) {
eden.error(new Error("shapeOnBottomAt: The first argument must be either a string or a pointer to a _view_xxx_content observable, not " +
Eden.edenCodeForValue(target)), "error");
return undefined;
} else {
target = match[1];
}
} else if (typeof(target) != "string") {
eden.error(new Error("shapeOnBottomAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");
return undefined;
}
if (typeof(x) != "number") {
eden.error(new Error("shapeOnBottomAt: The x-coordinate must be a number, not a " + typeof(x)), "error");
return undefined;
} else if (typeof(y) != "number") {
eden.error(new Error("shapeOnBottomAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
return undefined;
}
return edenUI.plugins.Canvas2D.findDrawableHit(target, x, y, true, testAll);
}}$;
}

func zoneOnTopAt {
auto drawable;
drawable = apply(shapeOnTopAt, $);
if (drawable == @) {
return @;
} else {
return drawable.name;
}
}

func zoneOnBottomAt {
auto drawable;
drawable = apply(shapeOnBottomAt, $);
if (drawable == @) {
return @;
} else {
return drawable.name;
}
}

func observableForShape {
${{
var drawable = arguments[0];
if (drawable === undefined) {
return undefined;
} else if ("obsName" in drawable) {
return drawable.obsName;
} else {
return drawable.name;
}
}}$;
}

func observableOnTopAt {
auto drawable;
drawable = apply(shapeOnTopAt, $);
return observableForShape(drawable);
}

func observableOnBottomAt {
auto drawable;
drawable = apply(shapeOnBottomAt, $);
return observableForShape(drawable);
}

func shapesAt {
${{
var target = arguments[0];
var x, y, testAll;
if (arguments.length < 2 || arguments.length > 4) {
eden.error(new Error("shapesAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
return undefined;
}
if (arguments[1] instanceof Point) {
x = arguments[1].x;
y = arguments[1].y;
testAll = arguments[2];
} else {
x = arguments[1];
y = arguments[2];
testAll = arguments[3];
}

if (target === undefined || x === undefined || y === undefined) {
return undefined;
}
if (target instanceof Symbol) {
var match = target.name.match(/^\/_view_(.*)_content$/);
if (match === null) {
eden.error(new Error("shapesAt: The first argument must be either a string or a pointer to a _view_xxx_content observable, not " +
Eden.edenCodeForValue(target)), "error");
return undefined;
} else {
target = match[1];
}
} else if (typeof(target) != "string") {
eden.error(new Error("shapesAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");
return undefined;
}
if (typeof(x) != "number") {
eden.error(new Error("shapesAt: The x-coordinate must be a number, not a " + typeof(x)), "error");
return undefined;
} else if (typeof(y) != "number") {
eden.error(new Error("shapesAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
return undefined;
}
return edenUI.plugins.Canvas2D.findAllDrawablesHit(target, x, y, testAll);
}}$;
}

func zonesAt {
auto drawables, zones, i;
drawables = apply(shapesAt, $);
zones = [];
for (i = 1; i <= drawables#; i++) {
append zones, drawables[i].name;
}
return zones;
}

func observablesAt {
auto drawables, obsList, obsName, i;
drawables = apply(shapesAt, $);
obsList = [];
for (i = 1; i <= drawables#; i++) {
obsName = observableForShape(drawables[i]);
if (obsName != @) {
append obsList, obsName;
}
}
return obsList;
}



${{
Arc = function(x, y, r, sAngle, eAngle, colour, drawingOptions) {
this.x = x;
this.y = y;
this.r = r;
this.sAngle = sAngle;
this.eAngle = eAngle;
var radiansPerUnit = Math.PI / root.lookup("semicircleAngle").value();
var sRadians = sAngle * radiansPerUnit;
var eRadians = eAngle * radiansPerUnit;
var twoPI = 2 * Math.PI;
sRadians = sRadians % twoPI;
if (sRadians < 0) {
sRadians = sRadians + twoPI;
}
eRadians = eRadians % twoPI;
if (eRadians < 0) {
eRadians = eRadians + twoPI;
}
this.sRadians = sRadians;
this.eRadians = eRadians;

this.colour = colour
this.drawingOptions = drawingOptions;
}
}}$;

func Arc { ${{
var x = arguments[0];
var y = arguments[1];
var r = arguments[2];
var sAngle = arguments[3];
var eAngle = arguments[4];
var colour, drawingOptions;
if (arguments.length == 6 && typeof(arguments[5]) == "object" && !(arguments[5] instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
colour = "black";
drawingOptions = arguments[5];
} else {
colour = arguments[5];
drawingOptions = arguments[6];
if (colour === undefined) { colour = "black"; }
}
return new Arc(x, y, r, sAngle, eAngle, colour, drawingOptions);
}}$; };
semicircleAngle ~> [Arc];

${{

Arc.prototype.draw = function(context, scale) {
var anticlockwise;
if (this.drawingOptions !== undefined && "direction" in this.drawingOptions) {
var directionName = this.drawingOptions.direction;
var turnedThroughAC = this.eRadians - this.sRadians;
if (this.eRadians < this.sRadians) {
turnedThroughAC = turnedThroughAC + 2 * Math.PI;
}
switch (directionName) {
case "anticlockwise":
case "acw":
case "ccw":
anticlockwise = true;
break;
case "auto":
anticlockwise = this.sAngle < this.eAngle;
break;
case "clockwise":
case "cw":
anticlockwise = false;
break;
case "major":
anticlockwise = turnedThroughAC > Math.PI;
break;
case "minor":
anticlockwise = turnedThroughAC <= Math.PI;
break;
default:
//Invalid value specified.
anticlockwise = true;
}
} else {
//Default to "auto"
anticlockwise = this.sAngle < this.eAngle;
}
var sRadians = this.sRadians;
var eRadians = this.eRadians;
var r = this.r - context.lineWidth / 2;
context.beginPath();
context.arc(this.x, this.y, r, -sRadians, -eRadians, anticlockwise);
context.strokeStyle = this.colour;
context.stroke();

if (this.drawingOptions !== undefined && this.drawingOptions.arrowhead instanceof Arrowhead) {
var cos1 = Math.cos(-sRadians);
var sin1 = Math.sin(-sRadians);
var cos2 = Math.cos(-eRadians);
var sin2 = Math.sin(-eRadians);
var x1 = this.x + r * cos1;
var y1 = this.y + r * sin1;
var x2 = this.x + r * cos2;
var y2 = this.y + r * sin2;
var gradient1 = -cos1 / sin1;
var gradient2 = -cos2 / sin2;
var reverse1, reverse2;
if (anticlockwise) {
reverse1 = sRadians <= Math.PI;
reverse2 = eRadians <= Math.PI;
} else {
reverse1 = sRadians > Math.PI;
reverse2 = eRadians > Math.PI;
}
this.drawingOptions.arrowhead.draw(context, scale, x1, y1, gradient1, reverse1, x2, y2,
gradient2, reverse2);
}
};

Arc.prototype.toString = function() {
var s = "Arc(" + Eden.edenCodeForValues(this.x, this.y, this.r, this.sAngle, this.eAngle, this.colour);

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
}

Arc.prototype.getEdenCode = Arc.prototype.toString;

}}$;


${{
Arrowhead = function(start, end, length, width, filled) {
this.start = start;
this.end = end;
this.length = length;
this.width = width;
this.filled = filled;
};

Arrowhead.prototype.toString = function () {
return "Arrowhead(" + Eden.edenCodeForValues(this.start, this.end, this.length, this.width,
this.filled) + ")";
};

Arrowhead.prototype.getEdenCode = Arrowhead.prototype.toString;

Arrowhead.prototype.draw = function (context, scale, x1, y1, gradient1, reverse1, x2, y2, gradient2, reverse2) {
var invGradient, len1, len2, len3, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y;
var lineWidth = context.lineWidth;
var adjustment = lineWidth / 4;
var filled = this.filled;

var width = this.width;
var length = this.length;

if (length === undefined) {
if (lineWidth <= 4) {
length = 10 / scale;
} else {
length = lineWidth * 2.5 / scale;
}
} else {
length = length / scale;
}
if (width === undefined) {
width = length / 2;
} else {
width = (width / 2) / scale;
}

context.fillStyle = context.strokeStyle;

if (this.start) {
invGradient = - 1 / gradient1;
if ((reverse1 && invGradient == Infinity) || (!reverse1 && invGradient == -Infinity)) {
//Horizontal left
p1x = x1 + length;
p1y = y1 - width;
p2x = p1x;
p2y = y1 + width;
p3x = x1 + adjustment;
p3y = y1;
} else if (gradient1 == 0) {
//Horizontal right
p1x = x1 - length;
p1y = y1 - width;
p2x = p1x;
p2y = y1 + width;
p3x = x1 - adjustment;
p3y = y1;
} else if ((reverse1 && gradient1 == -Infinity) || (!reverse1 && gradient1 == Infinity)) {
//Vertical upward
p1x = x1 - width;
p1y = y1 + length;
p2x = x1 + width;
p2y = p1y;
p3x = x1;
p3y = y1 + adjustment;
} else if (gradient1 == Infinity || gradient1 == -Infinity) {
//Vertical downward
p1x = x1 - width;
p1y = y1 - length;
p2x = x1 + width;
p2y = p1y;
p3x = x1;
p3y = y1 - adjustment;
} else {
len1 = Math.sqrt(length * length / (1 + gradient1 * gradient1));
if (reverse1) {
len1 = -len1;
}
p0x = x1 + len1;
p0y = y1 + len1 * gradient1;
len2 = Math.sqrt(width * width / (1 + invGradient * invGradient));
p1x = p0x - len2;
p1y = p0y - len2 * invGradient;
p2x = p0x + len2;
p2y = p0y + len2 * invGradient;
len3 = Math.sqrt(adjustment * adjustment / (1 + gradient1 * gradient1));
p3x = x1 - len3;
p3y = y1 - len3 * gradient1
}

context.beginPath();
context.moveTo(p1x, p1y);
context.lineTo(p3x, p3y);
context.lineTo(p2x, p2y);
if (filled) {
context.closePath();
context.fill();
}
context.stroke();
}

if (this.end) {
invGradient = - 1 / gradient2;
if ((reverse2 && invGradient == -Infinity) || (!reverse2 && invGradient == Infinity)) {
//Horizontal left
p1x = x2 + length;
p1y = y2 - width;
p2x = p1x;
p2y = y2 + width;
p3x = x2 + adjustment;
p3y = y2;
} else if (gradient2 == 0) {
//Horizontal right
p1x = x2 - length;
p1y = y2 - width;
p2x = p1x;
p2y = y2 + width;
p3x = x2 - adjustment;
p3y = y2;
} else if ((reverse2 && gradient2 == Infinity) || (!reverse2 && gradient2 == -Infinity)) {
//Vertical upward
p1x = x2 - width;
p1y = y2 + length;
p2x = x2 + width;
p2y = p1y;
p3x = x2;
p3y = y2 + adjustment;
} else if (gradient2 == Infinity || gradient2 == -Infinity) {
//Vertical downward
p1x = x2 - width;
p1y = y2 - length;
p2x = x2 + width;
p2y = p1y;
p3x = x2;
p3y = y2 - adjustment;
} else {
len1 = Math.sqrt(length * length / (1 + gradient2 * gradient2));
if (reverse2) {
len1 = -len1;
}
p0x = x2 - len1;
p0y = y2 - len1 * gradient2;
len2 = Math.sqrt(width * width / (1 + invGradient * invGradient));
p1x = p0x - len2;
p1y = p0y - len2 * invGradient;
p2x = p0x + len2;
p2y = p0y + len2 * invGradient;
len3 = Math.sqrt(adjustment * adjustment / (1 + gradient2 * gradient2));
p3x = x2 - len3;
p3y = y2 - len3 * gradient2
}

context.beginPath();
context.moveTo(p1x, p1y);
context.lineTo(p3x, p3y);
context.lineTo(p2x, p2y);
if (filled) {
context.closePath();
context.fill();
}
context.stroke();
}
};

}}$;

func Arrowhead {
${{
var argsProcessed;
var numArgs = arguments.length;
var arg = arguments[0];
var argType = typeof(arg);

var start, end, length, width, filled;

if ((argType == "boolean" && numArgs >= 2 &&
(typeof(arguments[1]) == "boolean" || arguments[1] === undefined)) ||
numArgs == 5
) {
start = arg;
end = arguments[1];
argsProcessed = 2;
arg = arguments[2];
argType = typeof(arg);
} else {
start = false;
end = true;
argsProcessed = 0;
}

if (argType == "number" || arg === undefined) {
length = arg;
argsProcessed++;
arg = arguments[argsProcessed];
argType = typeof(arg);
}

if (argType == "number" || arg === undefined) {
width = length;
length = arg;
argsProcessed++;
}

if (argsProcessed < numArgs) {
filled = arguments[argsProcessed];
}

if (filled === undefined) {
filled = true;
}

return new Arrowhead(start, end, length, width, filled);
}}$;
}


func Button {
${{
var argsProcessed, arg, argType;
var name, label, imageURL;
var nameSpecified = false;
for (argsProcessed = 0; argsProcessed < 3; argsProcessed++) {
arg = arguments[argsProcessed];
if (arg !== undefined && typeof(arg) != "string") {
break;
}
}

if (argsProcessed == 3) {
name = arguments[0];
label = arguments[1];
imageURL = arguments[2];
nameSpecified = true;
} else if (argsProcessed > 0) {
var str = arguments[argsProcessed - 1];
var found = false;
for (var i = 0; i < Button.imageFileSuffixes.length; i++) {
var filenameSuffix = Button.imageFileSuffixes[i];
if (str.substr(-filenameSuffix.length) == filenameSuffix) {
imageURL = str;
if (argsProcessed == 2) {
label = arguments[0];
}
found = true;
break;
}
}
if (!found) {
label = str;
if (argsProcessed == 2) {
name = arguments[0];
nameSpecified = true;
}
}
}
if (name === undefined) {
var obsName = root.currentObservableName();
if (!nameSpecified) {
name = obsName;
}
if (name === undefined) {
eden.error(new Error("Button: The button defined by observable " + obsName + " must have a name."), "error");
return undefined;
}
}

var x = arguments[argsProcessed];
argsProcessed++;
var y = arguments[argsProcessed];
argsProcessed++;
arg = arguments[argsProcessed];
argType = typeof(arg);

var width, minHeight, enabled;

if (argType == "number") {
width = arg;
argsProcessed++;
arg = arguments[argsProcessed];
argType = typeof(arg);

if (argType == "number") {
minHeight = arg;
argsProcessed++;
arg = arguments[argsProcessed];
argType = typeof(arg);
}
}

if (argType == "boolean") {
enabled = arg;
argsProcessed++;
arg = arguments[argsProcessed];
argType = typeof(arg);
} else {
enabled = true;
}

if (argsProcessed < arguments.length - 2) {
argsProcessed = arguments.length - 2;
}

var fillcolour = arguments[argsProcessed];
var textcolour = arguments[argsProcessed + 1];
return new Button(name, label, imageURL, x, y, width, minHeight, enabled, fillcolour, textcolour);
}}$;
}

${{
Button = function (name, label, imageURL, x, y, width, minHeight, enabled, fillcolour, textcolour) {
this.name = name;
this.obsName = root.currentObservableName();
this.label = label;
this.imageURL = imageURL;
this.x = x;
this.y = y;
this.width = width;
this.minHeight = minHeight;
this.enabled = enabled;
this.fillcolour = fillcolour;
this.textcolour = textcolour;
};

Button.imageFileSuffixes = [".jpg", ".jpeg", ".png", ".gif", ".svg", ".svgz", ".webp", ".bmp", ".ico"];

Button.prototype.hash = function () {
return this.name+"$$"+
this.label+"$$"+
this.imageURL+"$$"+
this.x+"$$"+
this.y+"$$"+
this.width+"$$"+
this.minHeight+"$$"+
this.enabled+"$$"+
this.fillcolour+"$$"+
this.textcolour;
};

Button.prototype.draw = function (context) {

if (this.elements === undefined) {
var name = this.name;

var disabled = this.enabled === false? "disabled=\"disabled\"" : "";
var inputHtml = '<button ' +
disabled +
'style="position: absolute; ';
if (this.fillcolour !== undefined) {
inputHtml = inputHtml + 'background-color: ' + this.fillcolour + '; ';
}
if (this.textcolour !== undefined) {
inputHtml = inputHtml + 'color: ' + this.textcolour + '; ';
}
inputHtml = inputHtml + '">';
if (this.imageURL !== undefined) {
inputHtml = inputHtml + '<img src="' + this.imageURL + '" style="max-width: 100%"/><br/>';
}
if (this.label !== undefined) {
inputHtml = inputHtml + this.label;
}
inputHtml = inputHtml + '</button>';

var inputJQ = $(inputHtml);
var clickSym = root.lookup(name + "_click");
if (clickSym.value() === undefined) {
var agent = root.lookup("Button");
clickSym.assign(false, root.scope, agent);
root.lookup(name + "_clicked").assign(false, root.scope, agent);
}

inputJQ
.click(function () {
root.lookup(name + "_clicked").assign(true, root.scope, Symbol.hciAgent, true);
root.lookup(name + "_clicked").assign(false, root.scope, Symbol.hciAgent, true);
})
.on("mousedown", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
})
.on("mouseup", function () {
edenUI.plugins.Canvas2D.endClick();
})
.on("mouseenter", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
});

var button = inputJQ.get(0);
this.elements = [button];

} else {

//Case when the user has performed direct assignment to one or more JavaScript properties.
var button = this.elements[0];
button.value = this.label;

if (this.enabled) {
button.disabled = false;
} else {
button.disabled = true;
}

var style = button.style;
var fillcolour = this.fillcolour;
if (style.backgroundColor != fillcolour) {
if (fillcolour === undefined) {
style.backgroundColor = "ButtonFace";
} else {
style.backgroundColor = fillcolour;
}
}
var textcolour = this.textcolour;
if (style.color != textcolour) {
if (textcolour === undefined) {
style.color = "ButtonText";
} else {
style.color = textcolour;
}
}
}
};

Button.prototype.scale = function (scale, zoom, origin) {
var style = this.elements[0].style;
style.left = Math.round(this.x * scale + origin.x) + "px";
style.top = Math.round(this.y * scale + origin.y) + "px";
style.fontSize = zoom + "em";

if (this.width === undefined) {
style.width = "";
} else {
style.width = Math.round(this.width * zoom) + "px";
}

if (this.minHeight === undefined) {
style.minHeight = "";
} else {
style.minHeight = Math.ceil(this.minHeight * zoom) + "px";
}
};

Button.prototype.toString = function () {
var s;
if (this.name == this.obsName) {
s = "Button(" + Eden.edenCodeForValues(this.label, this.imageURL, this.x, this.y, this.enabled);
} else {
s = "Button(" + Eden.edenCodeForValues(this.name, this.label, this.imageURL, this.x, this.y, this.enabled);
}
if (this.fillcolour !== undefined || this.textcolour !== undefined) {
s = s + ", " + Eden.edenCodeForValues(this.fillcolour, this.textcolour);
}
s = s + ")";
return s;
};

Button.prototype.getEdenCode = Button.prototype.toString;

}}$;


${{
Checkbox = function (name, label, x, y, tristate, enabled) {
this.name = name;
this.obsName = root.currentObservableName();
this.label = label;
this.x = x;
this.y = y;
this.tristate = tristate;
this.enabled = enabled;
}

Checkbox.prototype.hash = function () {
return this.label+"$$"+
this.name+"$$"+
this.x+"$$"+
this.y+"$$"+
this.tristate+"$$"+
this.enabled;
};
}}$;

func Checkbox { ${{
var argsProcessed;

var name;
if (typeof(arguments[1]) == "string" || arguments[1] === undefined) {
name = arguments[0];
argsProcessed = 1;
} else {
name = root.currentObservableName();
argsProcessed = 0;
if (name === undefined) {
eden.error(new Error("Checkbox: Every checkbox must have a name."), "error");
return undefined;
}
}

var label;
if (typeof(arguments[argsProcessed]) == "string" || arguments[argsProcessed] === undefined) {
label = arguments[argsProcessed];
argsProcessed++;
}

var x = arguments[argsProcessed];
var y = arguments[argsProcessed + 1];

var tristate = arguments[argsProcessed + 2];
if (tristate === undefined) tristate = false;

var enabled = arguments[argsProcessed + 3];
if (enabled === undefined) enabled = true;

return new Checkbox(name, label, x, y, tristate, enabled);
}}$; }

${{

Checkbox.prototype.draw = function(context) {

if (this.elements === undefined) {
var me = this;
var name = this.name;

var inputJQ = $('<input type="checkbox"/>');
var inputElement = inputJQ.get(0);
var element;
if (this.label === undefined) {
element = inputElement;
} else {
var labelJQ = $('<label> ' + this.label + '</label>');
labelJQ.prepend(inputJQ);
element  = labelJQ.get(0);
}
element.style.position = "absolute";

inputElement.disabled = (this.enabled === false);

var valueSym = root.lookup(name + "_checked");
var value = valueSym.value();
if (value === undefined) {
if (this.tristate) {
inputElement.indeterminate = true;
} else {
valueSym.assign(false, root.scope, root.lookup("Checkbox"));
}
} else {
inputElement.checked = value;
}
valueSym.addJSObserver("updateCheckbox", function (obs, value) {
var element = me.elements[0];
if (value === undefined) {
element.indeterminate = true;
element.checked = false;
} else {
element.indeterminate = false;
element.checked = (value == true);
}
});

inputJQ.change(function (event) {
var element = event.target;
var value;
if (element.indeterminate) {
element.indeterminate = false;
element.checked = true;
value = true;
} else if (me.tristate && valueSym.value() === false) {
element.indeterminate = true;
element.checked = false;
value = undefined;
} else {
value = element.checked;
}
valueSym.assign(value, root.scope, Symbol.hciAgent, true);
})
.on("mousedown", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(undefined, root.scope, Symbol.hciAgent, mouseFollow);
})
.on("mouseup", function () {
edenUI.plugins.Canvas2D.endClick();
})
.on("mouseenter", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
});

this.elements = [element];
}
};

Checkbox.prototype.scale = function (scale, zoom, origin) {
var outerElement = this.elements[0];
var inputElement;
if (outerElement.tagName.toLowerCase() == "label") {
inputElement = outerElement.children[0];
} else {
inputElement = outerElement;
}
var outerStyle = outerElement.style;
var inputStyle = inputElement.style;

outerStyle.left = Math.round(this.x * scale + origin.x) + "px";
outerStyle.top = Math.round(this.y * scale + origin.y) + "px";

var checkboxSize = Math.round(13 * zoom) + "px";
inputStyle.width = checkboxSize;
inputStyle.height = checkboxSize;
};

Checkbox.prototype.toString = function() {
if (this.name == this.obsName) {
return "Checkbox(" + Eden.edenCodeForValues(this.x, this.y, this.tristate, this.enabled) + ")";
} else {
return "Checkbox(" + Eden.edenCodeForValues(this.name, this.x, this.y, this.tristate, this.enabled) + ")";
}
};

Checkbox.prototype.getEdenCode = Checkbox.prototype.toString;

}}$;


${{
Circle = function(x, y, radius, fillcolour, outlinecolour, drawingOptions) {
this.x = x;
this.y = y;
this.radius = radius;
if (fillcolour === undefined && outlinecolour === undefined) {
this.fillcolour = undefined;
this.outlinecolour = "black";
} else {
this.fillcolour = fillcolour;
this.outlinecolour = outlinecolour;
}
this.drawingOptions = drawingOptions;
this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Circle");
this.obsName = root.currentObservableName();
}
}}$;

func Circle { ${{
var x = arguments[0];
var y = arguments[1];
var radius = arguments[2];
var fillcolour, outlinecolour, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}
if (processUpTo >= 3) {
fillcolour = arguments[3];
if (processUpTo == 4) {
outlinecolour = arguments[4];
}
}
if (fillcolour === undefined && outlinecolour === undefined) {
outlinecolour = "black";
}
return new Circle(x, y, radius, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

Circle.prototype.draw = function (context) {
if (this.radius > 0) {

this.tracePath(context);
if (this.fillcolour !== undefined) {
edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
context.fill();
}
if (this.outlinecolour !== undefined) {
context.strokeStyle = this.outlinecolour;
context.stroke();
}

}
};

Circle.prototype.tracePath = function (context) {
var halfLineWidth;
if (this.outlinecolour !== undefined) {
halfLineWidth = context.lineWidth / 2;
} else {
halfLineWidth = 0;
}

var adjustedRadius;
if (this.radius <= halfLineWidth) {
context.lineWidth = this.radius;
adjustedRadius = this.radius / 2;
} else {
adjustedRadius = this.radius - halfLineWidth;
}
context.beginPath();
context.arc(this.x, this.y, adjustedRadius, 0, 2 * Math.PI, false);
context.closePath();
}

Circle.prototype.isHit = function (context, scale, x, y) {
this.tracePath(context);
return context.isPointInPath(x,y);
}

Circle.prototype.toString = function() {
var s = "Circle(" + Eden.edenCodeForValues(this.x, this.y, this.radius, this.fillcolour, this.outlinecolour);

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
};

Circle.prototype.getEdenCode = Circle.prototype.toString;

Circle.prototype.imageMapArea = function () {
return "shape=\"circle\" coords=\"" + this.x + "," + this.y + "," + this.radius + "\"";
}

Circle.prototype.centre = function () {
return new Point(this.x, this.y);
}

}}$;


${{
Combobox = function (name, suggestions, x, y, width, placeholder, enabled) {
this.name = name;
this.obsName = root.currentObservableName();
this.suggestions = suggestions;
this.x = x;
this.y = y;
this.width = width;
this.placeholder = placeholder;
this.enabled = enabled;
}

Combobox.prototype.hash = function () {
return this.name+"$$"+
(Array.isArray(this.suggestions)? this.suggestions.join("$$") : "") +
this.x+"$$"+
this.y+"$$"+
this.width+"$$"+
this.placeholder+"$$"+
this.enabled;
};

}}$;

func Combobox { ${{
var argsProcessed;

var name;
if (typeof(arguments[0]) == "string") {
name = arguments[0];
argsProcessed = 1;
} else {
name = root.currentObservableName();
argsProcessed = 0;
if (name === undefined) {
eden.error(new Error("Combobox: Every combobox must have a name."), "error");
return undefined;
}
}

var suggestions = arguments[argsProcessed];
argsProcessed++;
var x = arguments[argsProcessed];
argsProcessed++;
var y = arguments[argsProcessed];
argsProcessed++;
var width, placeholder;

var arg = arguments[argsProcessed];
var argType = typeof(arg);
if (arg === undefined || argType == "number") {
width = arg;
argsProcessed++;
arg = arguments[argsProcessed];
argType = typeof(arg);
}
if (arg === undefined || argType == "string") {
placeholder = arg;
argsProcessed++;
arg = arguments[argsProcessed];
}
var enabled = arg;

return new Combobox(name, suggestions, x, y, width, placeholder, enabled);
}}$; }


${{

Combobox.prototype.makeOptionsHTML = function() {
var html = "";
for (var i = 0; i < this.suggestions.length; i++) {
html = html + '\n<option value="' + this.suggestions[i] + '"/>';
}
return html;
}

Combobox.prototype.draw = function(context) {
var input, suggestions;

if (this.elements === undefined) {
var me = this;
var name = this.name;

var disabled = this.enabled === false? 'disabled="disabled"' : '';
var placeholder = ' placeholder="' + (this.placeholder === undefined? name : this.placeholder) + '"';
var inputJQ = $('<input type="text" list="' + name + '-suggestions" ' + disabled +
placeholder + ' style="position: absolute"/>');

input = inputJQ.get(0);
var suggestionsJQ = $('<datalist id="' + this.name + '-suggestions"></datalist>');
suggestions = suggestionsJQ.get(0);
suggestionsJQ.html(this.makeOptionsHTML(this.values));

var valueSym = root.lookup(name + '_value');
var initialValue = valueSym.value();
if (initialValue !== undefined) {
input.value = initialValue;
}
valueSym.addJSObserver("updateCombobox", function (symbol, value) {
input.value = value;
});

inputJQ.on("input", function(event) {
valueSym.assign(event.target.value, root.scope, Symbol.hciAgent, true);
})
.on("mousedown", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(undefined, root.scope, Symbol.hciAgent, mouseFollow);
})
.on("mouseup", function () {
edenUI.plugins.Canvas2D.endClick();
})
.on("mouseenter", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
});

this.elements = [input, suggestions];

} else {

//Case when the user has performed direct assignment to one or more JavaScript properties.
input = this.elements[0];
suggestions = this.elements[1];
$(suggestions).html(this.makeOptionsHTML());

input.value = valueSym.value();

if (this.enabled == true) {
input.disabled = false;
} else {
input.disabled = true;
}

}
};

Combobox.prototype.scale = function (scale, zoom, origin) {
var style = this.elements[0].style;
style.left = Math.round(this.x * scale + origin.x) + "px";
style.top = Math.round(this.y * scale + origin.y) + "px";
if (this.width !== undefined) {
style.width = Math.round(this.width * scale - 6) + "px";
}
style.fontSize = zoom + "em";
};

Combobox.prototype.toString = function() {
if (this.name == this.obsName) {
return "Combobox(" + Eden.edenCodeForValues(this.suggestions, this.x, this.y, this.enabled) + ")";
} else {
return "Combobox(" + Eden.edenCodeForValues(this.name, this.suggestions, this.x, this.y, this.enabled) + ")";
}
};

Combobox.prototype.getEdenCode = Combobox.prototype.toString;

}}$;

${{
Curve = function (x1, y1, x2, y2, r, elasticity, theta1, theta2, mid, overshoot, dirSwitch, colours, drawingOptions) {
this.x1 = x1;
this.y1 = y1;
this.x2 = x2;
this.y2 = y2;
this.r = r;
this.elasticity = elasticity;
this.theta1 = theta1;
this.theta2 = theta2;
this.mid = mid;
this.overshoot = overshoot;
this.dirSwitch = dirSwitch;
this.colours = colours;
this.drawingOptions = drawingOptions;

elasticity = elasticity * 0.94;
var xDistance = x2 - x1;
var yDistance = y2 - y1;
this.theta3 = Math.atan2(yDistance, xDistance);
this.fullLength = Math.sqrt(xDistance * xDistance + yDistance * yDistance);
this.length1 = mid * this.fullLength;
var length2 = this.fullLength - this.length1;

var radiansPerUnit = Math.PI / root.lookup("semicircleAngle").value();
this.delta1 = elasticity * this.length1;
this.delta2 = elasticity * length2;
var fullTurn = 2 * Math.PI;

if (theta1 === undefined) {
this.deltaX1 = 0;
this.deltaY1 = 0;
} else {
var theta1Normalized = (theta1 * radiansPerUnit) % fullTurn;
if (theta1Normalized < 0) {
theta1Normalized = theta1Normalized + fullTurn;
}
var tanTheta1 = Math.abs(Math.tan(theta1Normalized));

if (theta1Normalized > fullTurn/4 && theta1Normalized <= fullTurn * 3/4) {
this.deltaX1 = -overshoot;
} else {
this.deltaX1 = Math.abs(this.length1 - this.delta1);
}

this.deltaY1 = Math.abs(this.deltaX1) * tanTheta1;
if (theta1Normalized > fullTurn/2) {
this.deltaY1 = -this.deltaY1;
} else if (this.deltaY1 > r) {
this.deltaY1 = r;
this.deltaX1 = r / tanTheta1;
}
}

if (theta2 === undefined) {
this.deltaX2 = 0;
this.deltaY2 = 0;
} else {
var theta2Normalized = (theta2 * radiansPerUnit) % fullTurn;
if (theta2Normalized < 0) {
theta2Normalized = theta2Normalized + fullTurn;
}
var tanTheta2 = Math.abs(Math.tan(theta2Normalized));

if (theta2Normalized > fullTurn/4 && theta2Normalized <= fullTurn * 3/4) {
this.deltaX2 = -overshoot;
} else {
this.deltaX2 = Math.abs(length2 - this.delta2);
}

this.deltaY2 = Math.abs(this.deltaX2) * tanTheta2;
if (theta2Normalized > fullTurn/2) {
this.deltaY2 = -this.deltaY2;
} else if (this.deltaY2 > r) {
this.deltaY2 = r;
this.deltaX2 = r / tanTheta2;
}
}

if (dirSwitch) {
this.radius = -r;
this.deltaY1 = -this.deltaY1;
this.deltaY2 = -this.deltaY2;
} else {
this.radius = r;
}
}

}}$;

func Curve {
${{
var x1 = arguments[0];
var y1 = arguments[1];
var x2 = arguments[2];
var y2 = arguments[3];
var r = arguments[4];
var elasticity = arguments[5];

var direction, theta1, theta2, mid = 0.5, overshoot = 150, direction, colours, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
lastArg = arguments[processUpTo];
} else {
processUpTo = arguments.length - 1;
}
if (typeof(lastArg) == "string") {
colours = [lastArg];
processUpTo--;
} else if (Array.isArray(lastArg)) {
colours = lastArg;
processUpTo--;
} else {
colours = ["black"];
}
lastArg = arguments[processUpTo];
if (typeof(lastArg) == "boolean") {
direction = lastArg;
processUpTo--;
}
if (processUpTo > 5) {
theta1 = arguments[6];
if (processUpTo > 6) {
theta2 = arguments[7];
if (processUpTo > 7) {
mid = arguments[8];
if (processUpTo > 8) {
overshoot = arguments[9];
}
}
} else {
theta2 = theta1;
}
}
return new Curve(x1, y1, x2, y2, r, elasticity, theta1, theta2, mid, overshoot, direction, colours, drawingOptions);
}}$;
}
semicircleAngle ~> [Curve];

${{
Curve.prototype.draw = function (context, scale) {
if (this.colours.length == 1) {
context.strokeStyle = this.colours[0];
} else {
var gradient = context.createLinearGradient(0, 0, this.fullLength, 0);
for (var i = 0; i < this.colours.length; i++) {
gradient.addColorStop(i / (this.colours.length - 1), this.colours[i]);
}
context.strokeStyle = gradient;
}

context.translate(this.x1, this.y1);
context.rotate(this.theta3);
context.beginPath();
context.moveTo(0, 0);
context.bezierCurveTo(this.deltaX1, this.deltaY1, this.length1 - this.delta1, this.radius, this.length1, this.radius);
context.bezierCurveTo(this.length1 + this.delta2, this.radius, this.fullLength - this.deltaX2, this.deltaY2, this.fullLength, 0);
context.stroke();

if (this.drawingOptions !== undefined && this.drawingOptions.arrowhead instanceof Arrowhead) {
var gradient1, gradient2, t, x1, y1;
if (this.deltaX1 == 0 && this.deltaY1 == 0) {
t = 0.01;
x1 = 3 * (1 - t) * t * t * (this.length1 - this.delta1) + t * t * t * this.length1;
y1 = 3 * (1 - t) * t * t * this.radius + t * t * t * this.radius;
gradient1 = y1 / x1;
} else {
gradient1 = this.deltaY1 / this.deltaX1;
}
if (this.deltaX2 == 0 && this.deltaY2 == 0) {
t = 0.99;
x1 = (1 - t) * (1 - t) * (1 - t) * this.length1 +
3 * (1 - t) * (1 - t) * t * (this.length1 + this.delta2) +
3 * (1 - t) * t * t * this.fullLength +
t * t * t * this.fullLength;
y1 = (1 - t) * (1 - t) * (1 - t) * this.radius + 3 * (1 - t) * (1 - t) * t * this.radius;
gradient2 = -y1 / (this.fullLength - x1);
} else {
gradient2 = -this.deltaY2 / this.deltaX2;
}
this.drawingOptions.arrowhead.draw(context, scale, 0, 0, gradient1, false, this.fullLength, 0, gradient2, false);
}
};

Curve.prototype.toString = function () {
return "Curve(" + Eden.edenCodeForValues(this.x1, this.y1, this.x2, this.y2, this.r, this.elasticity, this.theta1, this.theta2, this.mid, this.overshoot, this.dirSwitch, this.colours, this.drawingOptions) + ")";
}

Curve.prototype.getEdenCode = Curve.prototype.toString;
}}$;

${{
Div = function (html, x, y, width, height, id, classNames, style) {
this.html = html;
this.x = x;
this.y = y;
this.width = width;
this.height = height;
this.name = id;
this.obsName = root.currentObservableName();
this.classNames = classNames;
this.style = style;

//Separate font-size from other CSS information.
var matcher = style.match(/(^|;)\s*font-size:\s*([^;]*)(;|$)/);
if (matcher !== null) {
var matcher2 = matcher[2].match(/^(\d+(\.\d+)?)([a-z%]+)\s*$/);
if (matcher2 !== null) {
this.fontSizeNumber = Number(matcher2[1]);
this.fontSizeUnits = matcher2[3];
}
this.fontSizeSpecified = true;
} else {
matcher = style.match(/(^|;)\s*font:([^\/]+\s+)?(\d+(\.\d+)?)([a-z%]+)(\/|\s|;|$)/);
if (matcher === null) {
this.fontSizeSpecified = false;
} else {
this.fontSizeNumber = Number(matcher[3]);
this.fontSizeUnits = matcher[5];
this.fontSizeSpecified = true;
}
}
}

Div.prototype.hash = function () {
return this.x+"$$"+
this.y+"$$"+
this.width+"$$"+
this.height+"$$"+
this.html+"$$"+
this.name+"$$"+
this.classNames+"$$"+
this.style;
};
}}$;

func Div { ${{
var html = arguments[0];
var x = arguments[1];
var y = arguments[2];
var width, height;   //Number of pixels, string (e.g. "50%") or undefined (automatic)
var id, classNames;
var style = "";

var argsProcessed = 3;
var argType = typeof(arguments[3]);

if (argType == "number" || argType == "undefined" || (argType == "string" && /^\d/.test(arguments[3]))) {
width = arguments[3];
argsProcessed++;

argType = typeof(arguments[4]);
if (argType == "number" || argType == "undefined" || (argType == "string" && /^\d/.test(arguments[4]))) {
height = arguments[4];
argsProcessed++;
}
}

if (arguments.length > argsProcessed) {
if (arguments.length == argsProcessed + 3) {
id = arguments[argsProcessed];
classNames = arguments[argsProcessed + 1];
style = arguments[argsProcessed + 2];
} else {
if (Array.isArray(arguments[argsProcessed])) {
classNames = arguments[argsProcessed];
if (arguments.length == argsProcessed + 2) {
style = arguments[argsProcessed + 1];
}
} else if (arguments.length == argsProcessed + 2) {
id = arguments[argsProcessed];
if (Array.isArray(arguments[argsProcessed + 1])) {
classNames = arguments[argsProcessed + 1];
} else {
style = arguments[argsProcessed + 1];
}
} else {
argType = typeof(arguments[argsProcessed]);
if ((argType == "string" && arguments[argsProcessed].indexOf(":") !== -1) ||
argType == "object") {
style = arguments[argsProcessed];
} else {
id = arguments[argsProcessed];
}
}
}
}
return new Div(html, x, y, width, height, id, classNames, style);
}}$; }

${{

Div.prototype.draw = function(context) {

if (this.elements === undefined) {
var me = this;

var divElement = document.createElement("div");
if (this.name !== undefined) {
divElement.id = this.name;
}

if (Array.isArray(this.classNames)) {
divElement.setAttribute("class", "canvashtml-content-div " + this.classNames.join(" "));
} else {
divElement.setAttribute("class", "canvashtml-content-div");
}

CSSUtil.setStyle(divElement, this.style);
divElement.style.position = "absolute";
divElement.innerHTML = this.html;

if (typeof(this.x) == "string") {
divElement.style.left = this.x;
}
if (typeof(this.y) == "string") {
divElement.style.top = this.y;
}
if (typeof(this.width) == "string") {
divElement.style.width = this.width;
}
if (typeof(this.height) == "string") {
divElement.style.height = this.height;
}

if (this.name !== undefined) {
divElement.onmousedown = function (event) {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(event.target.id, root.scope, Symbol.hciAgent, mouseFollow);
};
divElement.onmouseup = function (event) {
edenUI.plugins.Canvas2D.endClick();
};
divElement.onmouseenter = function (event) {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(event.target.id, root.scope, Symbol.hciAgent, mouseFollow);
};
edenUI.plugins.Canvas2D.initZoneFromName(name, "Div")
}

//Create object properties that record the automatically generated width and/or height.
if (this.width === undefined || this.name !== undefined) {
var objectElement = document.createElement("object");
objectElement.setAttribute("style", "display: block; position: absolute; top: 0px; left: 0px; " +
"height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;");

objectElement.onload = function () {
me.resize();
}

objectElement.type = "text/html";
objectElement.data = "about:blank";
divElement.appendChild(objectElement);
}

this.elements = [divElement];
}
};

Div.prototype.resize = function () {
var scale = this.cachedScale;
if (scale === undefined) {
//Not yet added drawn onto a canvas.
return;
}

var element = this.elements[0];
var style = element.style;
var autoWidth = this.width === undefined;
var autoHeight = this.height === undefined;

if (autoWidth) {
var savedHeight = style.height;
style.width = "auto";
style.height = "auto";
var contentWidth = element.clientWidth;
style.width = contentWidth + "px";
style.height = savedHeight;
var scrollBarSize = element.offsetWidth - element.clientWidth;
if (scrollBarSize > 0) {
scrollBarSize = scrollBarSize + 2;
}
style.width = String(contentWidth + scrollBarSize) + "px";
}

if (this.name !== undefined) {
var agent = root.lookup("Div");
var widthSymName = this.name + "_width";
var heightSymName = this.name + "_height";

if (autoWidth || widthSymName in root.symbols) {
root.lookup(widthSymName).assign(element.offsetWidth / scale, root.scope, agent);
}
if (autoHeight || heightSymName in root.symbols) {
root.lookup(heightSymName).assign(element.offsetHeight / scale, root.scope, agent);
}
}
}

Div.prototype.scale = function (scale, zoom , origin) {
var style = this.elements[0].style;
if (typeof(this.x) == "number") {
style.left = Math.round(this.x * scale + origin.x) + "px";
}
if (typeof(this.y) == "number") {
style.top = Math.round(this.y * scale + origin.y) + "px";
}
if (typeof(this.width) == "number") {
style.width = Math.round(this.width * scale) + "px";
}
if (typeof(this.height) == "number") {
style.height = Math.round(this.height * scale) + "px";
}
if (this.fontSizeNumber !== undefined) {
style.fontSize = String(this.fontSizeNumber * zoom) + this.fontSizeUnits;
} else if (!this.fontSizeSpecified) {
if (zoom == 1) {
style.fontSize = ""; //Could be specified by a CSS class.
} else {
style.fontSize = zoom + "em";
}
}
this.cachedScale = scale;
this.resize();
};

Div.prototype.toString = function() {
return this.getEdenCode();
};

Div.prototype.getEdenCode = function () {
var s = "Div(" + Eden.edenCodeForValues(this.html, this.x, this.y, this.width, this.height);

if (this.name !== undefined) {
s = s + ", \"" + this.name + "\"";
}
if (this.classNames !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.classNames);
}
if (this.style != "") {
s = s + ", \"" + this.style + "\"";
}
s = s + ")";
return s;
};

}}$;


${{
DropDownList = function (name, values, labels, x, y, enabled) {
this.name = name;
this.obsName = root.currentObservableName();
this.values = values;
this.labels = labels;
this.x = x;
this.y = y;
this.enabled = enabled;
}

DropDownList.prototype.hash = function () {
return this.name+"$$"+
(Array.isArray(this.values)? this.values.join("$$") : "") +
(Array.isArray(this.labels)? this.labels.join("$$") : "") +
this.x+"$$"+
this.y+"$$"+
this.enabled;
};

}}$;

func DropDownList { ${{
var argsProcesed;

var name;
if (typeof(arguments[0]) == "string") {
name = arguments[0];
argsProcessed = 1;
} else {
name = root.currentObservableName();
argsProcessed = 0;
if (name === undefined) {
eden.error(new Error("DropDownList: Every DropDownList must have a name."), "error");
return undefined;
}
}

var values = arguments[argsProcessed];
argsProcessed++;
var labels;
if (Array.isArray(arguments[argsProcessed])) {
labels = arguments[argsProcessed];
argsProcessed++;
} else {
labels = values;
}
var x = arguments[argsProcessed];
argsProcessed++;
var y = arguments[argsProcessed];
argsProcessed++;
var enabled = arguments[argsProcessed];

return new DropDownList(name, values, labels, x, y, enabled);
}}$; }


${{

DropDownList.prototype.makeOptionsHTML = function() {
var html = "";
for (var i = 0; i < this.values.length; i++) {
html = html + '\n<option value="' + this.values[i] + '">' + this.labels[i] + '</option>';
}
return html;
}

DropDownList.prototype.draw = function(context) {
var dropDownList;

if (this.elements === undefined) {
var me = this;
var name = this.name;

var disabled = this.enabled === false? 'disabled="disabled"' : '';
var dropDownListJQ = $('<select ' + disabled + ' style="position: absolute"></select>');
dropDownListJQ.html(this.makeOptionsHTML(this.values));

dropDownList = dropDownListJQ.get(0);
var valueSym = root.lookup(name + '_value');
var initialValue = valueSym.value();
if (initialValue === undefined) {
valueSym.assign(me.values[0], root.scope, root.lookup("DropDownList"), true);
} else {
dropDownList.value = initialValue;
}
valueSym.addJSObserver("updateDropDownList", function (symbol, value) {
dropDownList.value = value;
});

dropDownListJQ.change(function(event) {
valueSym.assign(event.target.value, root.scope, Symbol.hciAgent, true);
})
.on("mousedown", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(undefined, root.scope, Symbol.hciAgent, mouseFollow);
})
.on("mouseup", function () {
edenUI.plugins.Canvas2D.endClick();
})
.on("mouseenter", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
});

this.elements = [dropDownList];

} else {

//Case when the user has performed direct assignment to one or more JavaScript properties.
dropDownList = this.elements[0];
$(dropDownList).html(this.makeOptionsHTML());

dropDownList.value = valueSym.value();

if (this.enabled == true) {
dropDownList.disabled = false;
} else {
dropDownList.disabled = true;
}

}
};

DropDownList.prototype.scale = function (scale, zoom, origin) {
var style = this.elements[0].style;
style.left = Math.round(this.x * scale + origin.x) + "px";
style.top = Math.round(this.y * scale + origin.y) + "px";
style.fontSize = zoom + "em";
};

DropDownList.prototype.toString = function() {
if (this.name == this.obsName) {
return "DropDownList(" + Eden.edenCodeForValues(this.values, this.labels, this.x,
this.y, this.enabled) + ")";
} else {
return "DropDownList(" + Eden.edenCodeForValues(this.name, this.values, this.labels, this.x,
this.y, this.enabled) + ")";
}
};

DropDownList.prototype.getEdenCode = DropDownList.prototype.toString;

}}$;


${{
Ellipse = function(x, y, xradius, yradius, fillcolour, outlinecolour, drawingOptions) {
this.x = x;
this.y = y;
this.xradius = xradius;
this.yradius = yradius;
this.fillcolour = fillcolour;
this.outlinecolour = outlinecolour;
this.drawingOptions = drawingOptions;
this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Ellipse");
this.obsName = root.currentObservableName();
}
}}$;

func Ellipse { ${{
var x = arguments[0];
var y = arguments[1];
var xradius = arguments[2];
var yradius = arguments[3];
var fillcolour, outlinecolour, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}
if (processUpTo >= 4) {
fillcolour = arguments[4];
if (processUpTo == 5) {
outlinecolour = arguments[5];
}
}

if (fillcolour === undefined && outlinecolour === undefined) {
outlinecolour = "black";
}
return new Ellipse(x, y, xradius, yradius, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

Ellipse.prototype.draw = function (context) {
if (this.xradius > 0 && this.yradius > 0) {

var scaleOutline;
if (this.outlinecolour === undefined || this.outlinecolour == "transparent") {
scaleOutline = false;
} else if (this.drawingOptions === undefined || !("scaleOutline" in this.drawingOptions)) {
scaleOutline = (this.fillcolour !== undefined && this.fillcolour != "transparent");
} else {
scaleOutline = this.drawingOptions.scaleOutline;
}
if (!scaleOutline) {
context.save();
}

var lineWidth = this.tracePath(context, scaleOutline);

if (this.fillcolour !== undefined) {
edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
context.fill();
}

if (!scaleOutline) {
context.restore();
context.lineWidth = lineWidth;
}
if (this.outlinecolour !== undefined) {
context.strokeStyle = this.outlinecolour;
context.stroke();
}

}
};

Ellipse.prototype.tracePath = function (context, scaleOutline) {
var scaleFactor = this.yradius / this.xradius;
var lineWidth;
if (this.outlinecolour !== undefined && this.outlinecolour != "transparent") {
if (scaleOutline) {
lineWidth = context.lineWidth;
} else {
lineWidth = context.lineWidth / scaleFactor;
}
} else {
lineWidth = 0;
}

var adjustedXRadius;
//Not sure what to do when xradius is bigger than 1/2 line width but less than line width, but it isn't correct atm.
if (this.xradius <= context.lineWidth / 2) {
lineWidth = this.xradius;
context.lineWidth = lineWidth;
adjustedXRadius = this.xradius / 2;
} else {
adjustedXRadius = this.xradius - lineWidth / 2;
}
context.scale(1, scaleFactor);
context.beginPath();
context.arc(this.x, this.y / scaleFactor, adjustedXRadius, 0, 2 * Math.PI, false);
context.closePath();
return lineWidth;
}

Ellipse.prototype.isHit = function (context, scale, x, y) {
this.tracePath(context, false);
return context.isPointInPath(x,y);
}

Ellipse.prototype.toString = function() {
var s = "Ellipse(" + Eden.edenCodeForValues(this.x, this.y, this.xradius, this.yradius, this.fillcolour, this.outlinecolour);

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
};

Ellipse.prototype.getEdenCode = Ellipse.prototype.toString;

}}$;



${{
FillPattern = function (url) {
this.image = new Image();
this.canvasesToRepaint = {};
this.loaded = false;

var me = this;

this.image.onload = function(){
me.loaded = true;
for (var viewName in me.canvasesToRepaint) {
edenUI.plugins.Canvas2D.drawPicture(viewName);
}
}
this.image.src = url;
};
}}$;

func FillPattern {
${{
return new FillPattern(arguments[0]);
}}$;
}

${{
FillPattern.prototype = new EdenUI.plugins.Canvas2D.FillStyle();

FillPattern.prototype.getColour = function (context) {
return context.createPattern(this.image, 'repeat');
}

FillPattern.prototype.toString = function() {
return "FillPattern(\"" + this.image.src + "\")";
}

FillPattern.prototype.getEdenCode = FillPattern.prototype.toString;

}}$;

/*
func greyMap {
auto data, i, j, v;
data = [];
for (j = 0; j <= 255; j++) {
for (i = 0; i <= 255; i++) {
v = sqrt((i - 128) * (i - 128) + (j - 128) * (j - 128));
if (v > 115) {
append data, @;
} else {
append data, ((i - 128) * (i - 128) + (j - 128) * (j - 128)) % 256;
}
}
}
return data;
}
pixelData is greyMap();
pixels is GreyPixelList(&pixelData, mousePosition.x - 128, mousePosition.y - 128, 256);
picture is [pixels];
*/
func GreyPixelList {
${{
var name;
var argsProcessed;
if (typeof(arguments[0]) == "string") {
name = arguments[0];
argsProcessed = 1;
} else {
argsProcessed = 0;
}
var ptrToData = arguments[argsProcessed];
argsProcessed++;
var x = arguments[argsProcessed];
argsProcessed++;
var y = arguments[argsProcessed];
argsProcessed++;
var width = arguments[argsProcessed];
argsProcessed++;
var redMultiply = arguments[argsProcessed];
if (redMultiply === undefined) redMultiply = 1;
argsProcessed++;
var greenMultiply = arguments[argsProcessed];
if (greenMultiply === undefined) greenMultiply = 1;
argsProcessed++;
var blueMultiply = arguments[argsProcessed];
if (blueMultiply === undefined) blueMultiply = 1;
argsProcessed++;
var redAdd = arguments[argsProcessed];
if (redAdd === undefined) redAdd = 0;
argsProcessed++;
var greenAdd = arguments[argsProcessed];
if (greenAdd === undefined) greenAdd = 0;
argsProcessed++;
var blueAdd = arguments[argsProcessed];
if (blueAdd === undefined) blueAdd = 0;
argsProcessed++;
return new GreyPixelList(name, ptrToData, x, y, width, redMultiply, greenMultiply, blueMultiply, redAdd, greenAdd, blueAdd);
}}$;
}

${{
function GreyPixelList(name, ptrToData, x, y, width, redMultiply, greenMultiply, blueMultiply, redAdd, greenAdd, blueAdd) {
this.name = edenUI.plugins.Canvas2D.initZoneFromName(name, "GreyPixelList");
this.obsName = root.currentObservableName();
this.ptr = ptrToData;
this.data = ptrToData instanceof Symbol? ptrToData.value() : [];
this.x = x;
this.y = y;
this.width = width;
this.height = this.data.length / width;
this.redMultiply = redMultiply;
this.greenMultiply = greenMultiply;
this.blueMultiply = blueMultiply;
this.redAdd = redAdd;
this.greenAdd = greenAdd;
this.blueAdd = blueAdd;
}

GreyPixelList.prototype.draw = function(context) {
var imageData = context.createImageData(this.width, this.height);
var imageArr = imageData.data;
var dataArr = this.data;
var dataArrayLen = dataArr.length;
var imageArrayLen = dataArrayLen * 4;
var offset;

offset = 0;
for (var i = 0; i < dataArrayLen; i++) {
imageArr[offset] = this.redMultiply * dataArr[i] + this.redAdd;
offset = offset + 4;
}

offset = 1;
for (var i = 0; i < dataArrayLen; i++) {
imageArr[offset] = this.greenMultiply * dataArr[i] + this.greenAdd;
offset = offset + 4;
}

offset = 2;
for (var i = 0; i < dataArrayLen; i++) {
imageArr[offset] = this.blueMultiply * dataArr[i] + this.blueAdd;
offset = offset + 4;
}

offset = 3;
for (var i = 0; i < dataArrayLen; i++) {
if (dataArr[i] !== undefined) {
imageArr[offset] = 255;
}
offset = offset + 4;
}

context.putImageData(imageData, this.x, this.y);
}

GreyPixelList.prototype.isHit = function (context, scale, x, y) {
return x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height &&
this.data[(y - this.y) * this.width + x - this.x] !== undefined;
}


GreyPixelList.prototype.toString = function() {
var s = "GreyPixelList(";
if (this.name !== undefined) {
s = s + Eden.edenCodeForValue(this.name) + ", ";
}
s = s + Eden.edenCodeForValues(this.ptr, this.x, this.y, this.width, this.redMultiply,
this.redAdd, this.greenMultiply, this.greenAdd, this.blueMultiply, this.blueAdd) + ")";
return s;
}

GreyPixelList.prototype.getEdenCode = GreyPixelList.prototype.toString;

}}$;



${{
CanvasImage = function (name, dx, dy, dWidth, dHeight, sx1, sy1, sx2, sy2, smoothed, file) {
this.name = edenUI.plugins.Canvas2D.initZoneFromName(name, "Image");
this.obsName = root.currentObservableName();

var temp;
if (sx2 !== undefined) {
if (sx1 > sx2) {
temp = sx1;
sx1 = sx2;
sx2 = temp;
}
this.sWidth = sx2 - sx1;
}
if (sy2 !== undefined) {
if (sy1 > sy2) {
temp = sy1;
sy1 = sy2;
sy2 = temp;
}
this.sHeight = sy2 - sy1;
}

this.originalDWidth = dWidth;
this.originalDHeight = dHeight;
this.originalSX2 = sx2;
this.originalSY2 = sy2;

this.dx = dx;
this.dy = dy;
this.dWidth = dWidth;
this.dHeight = dHeight;
this.sx = sx1;
this.sy = sy1;
this.smoothed = smoothed;

this.image = new Image();
this.canvasesToRepaint = {};
this.loaded = false;

var me = this;

this.image.onload = function() {
if (me.sWidth === undefined) {
me.sWidth = me.image.width - me.sx;
}
if (me.sHeight === undefined) {
me.sHeight = me.image.height - me.sy;
}
if (me.dWidth === undefined && me.dHeight === undefined) {
me.dWidth = me.sWidth;
me.dHeight = me.sHeight;
} else if (me.dWidth === undefined) {
me.dWidth = me.sWidth * me.dHeight / me.sHeight;
} else if (me.dHeight === undefined) {
me.dHeight = me.sHeight * me.dWidth / me.sWidth;
}

me.loaded = true;
for (var viewName in me.canvasesToRepaint) {
edenUI.plugins.Canvas2D.drawPicture(viewName);
}
}
this.image.src = file;
};
}}$;

func Image {
${{
var numArgs = arguments.length;
var argsProcessed;
var name;
if (typeof(arguments[0]) == "string") {
name = arguments[0];
argsProcessed = 1;
} else {
argsProcessed = 0;
}

var dx = arguments[argsProcessed];
argsProcessed++;
var dy = arguments[argsProcessed];
argsProcessed++;

var dWidth, dHeight, sx1 = 0, sy1 = 0, sx2, sy2, smoothed = true, file;

if (numArgs - 1 > argsProcessed) {
dWidth = arguments[argsProcessed];
argsProcessed++;
}
if (numArgs - 1 > argsProcessed) {
dHeight = arguments[argsProcessed];
argsProcessed++;
}
if (numArgs - 1 > argsProcessed) {
sx1 = arguments[argsProcessed];
argsProcessed++;
}
if (numArgs - 1 > argsProcessed) {
sy1 = arguments[argsProcessed];
argsProcessed++;
}
if (numArgs - 1 > argsProcessed) {
sx2 = arguments[argsProcessed];
argsProcessed++;
}
if (numArgs - 1 > argsProcessed) {
sy2 = arguments[argsProcessed];
argsProcessed++;
}
if (numArgs - 1 > argsProcessed) {
smoothed = arguments[argsProcessed];
argsProcessed++;
}
file = arguments[numArgs - 1];
return new CanvasImage(name, dx, dy, dWidth, dHeight, sx1, sy1, sx2, sy2, smoothed, file);
}}$;
}

${{
CanvasImage.prototype.draw = function(context, scale, viewName) {
if (this.loaded) {
var smoothed = this.smoothed;
context.mozImageSmoothingEnabled = smoothed;
context.msImageSmoothingEnabled = smoothed;
context.imageSmoothingEnabled = smoothed;
context.drawImage(this.image, this.sx, this.sy, this.sWidth, this.sHeight, this.dx, this.dy, this.dWidth, this.dHeight);
} else {
this.canvasesToRepaint[viewName] = true;
}
};

CanvasImage.prototype.isHit = function (context, scale, x, y) {
return x >= this.dx && x < this.dx + this.dWidth && y >= this.dy && y < this.dy + this.dHeight;
}

CanvasImage.prototype.toString = function() {
return "Image(" +	Eden.edenCodeForValues(this.name, this.dx, this.dy, this.originalDWidth,
this.originalDHeight, this.sx, this.sy, this.originalSX2, this.originalSY2, this.smoothed, this.image.src) + ")";
};

CanvasImage.prototype.getEdenCode = CanvasImage.prototype.toString;

}}$;



${{
HTMLImage = function (name, x, y, width, height, asPercent, scaleFactor, url, imageMap) {
this.name = name;
this.obsName = root.currentObservableName();
this.x = x;
this.y = y;
this.width = width;
this.height = height;
this.asPercent = asPercent;
this.scaleFactor = scaleFactor;
this.scaledWidth = width;
this.scaledHeight = height;
this.url = url;
this.imageMap = imageMap;
}

HTMLImage.prototype.hash = function () {
return this.name+"$$"+
this.x+"$$"+
this.y+"$$"+
this.width+"$$"+
this.height+"$$"+
this.isPercent+"$$"+
this.scaleFactor+"$$"+
this.url+"$$"+
this.imageMap;
};
}}$;

func HTMLImage { ${{
var numArgs = arguments.length;
var argsProcessedFirst, arg, argType;

var name;
if (typeof(arguments[0]) == "string") {
name = arguments[0];
argsProcessedFirst = 1;
} else {
argsProcessedFirst = 0;
}

var x = arguments[argsProcessedFirst];
argsProcessedFirst++;
var y = arguments[argsProcessedFirst];
argsProcessedFirst++;

var width, height, asPercent, url, imageMap;
var scaleFactor = 1;
var argsLeft = numArgs - argsProcessedFirst;

if (numArgs == 9 || Array.isArray(arguments[numArgs - 1])) {
imageMap = arguments[numArgs - 1];
url = arguments[numArgs - 2];
argsLeft = argsLeft - 2;
} else {
url = arguments[numArgs - 1];
argsLeft--;
}


if (argsLeft > 0) {
arg = arguments[argsProcessedFirst];
argType = typeof(arg);
if (argType == "number" || arg === undefined) {
width = arg;
argsProcessedFirst++;
argsLeft--;
arg = arguments[argsProcessedFirst];
argType = typeof(arg);
}
}
if (argsLeft > 0 && (argType == "number" || arg === undefined)) {
height = arg;
argsProcessedFirst++;
argsLeft--;
arg = arguments[argsProcessedFirst];
argType = typeof(arg);
}
if (argsLeft > 0 && (argType == "boolean" || arg === undefined)) {
asPercent = arg;
argsProcessedFirst++;
argsLeft--;
arg = arguments[argsProcessedFirst];
argType = typeof(arg);
}
if (argsLeft > 0 && argType == "number") {
scaleFactor = arg;
}

return new HTMLImage(name, x, y, width, height, asPercent, scaleFactor, url, imageMap);
}}$; }

${{
HTMLImage.prototype.draw = function(context) {
if (this.elements === undefined) {
var id = "canvas_" + this.name;
var name = this.name;
var me = this;

var html = '<img style="position: absolute"';
if (this.imageMap !== undefined) {
html = html + ' usemap="#' + id + '-map" draggable="false" class="noselect"';
}
html = html + '/>';
var imageJQ = $(html);

if (this.scaledWidth === undefined || this.scaledHeight === undefined || this.asPercent) {
imageJQ.on("load", function (event) {
var image = event.target;
var canvasName = edenUI.plugins.Canvas2D.canvasNameFromElement(image);
var canvasScale = root.lookup("_view_" + canvasName + "_scale").value() * root.lookup("_view_" + canvasName + "_zoom").value();

if (me.asPercent) {
if (me.width !== undefined) {
me.scaledWidth = me.width / 100 * image.naturalWidth;
}
if (me.height !== undefined) {
me.scaledHeight = me.height / 100 * image.naturalHeight;
}
}
if (me.scaledWidth === undefined && me.scaledHeight === undefined) {
me.scaledWidth = image.naturalWidth;
me.scaledHeight = image.naturalHeight;
} else if (me.scaledWidth === undefined) {
me.scaledWidth = image.naturalWidth * me.scaledHeight / image.naturalHeight;
}
if (me.scaledHeight === undefined) {
me.scaledHeight = image.naturalHeight * me.scaledWidth / image.naturalWidth;
}
image.width = Math.round(me.scaledWidth * canvasScale / me.scaleFactor);
image.height = Math.round(me.scaledHeight * canvasScale / me.scaleFactor);
});
}
imageJQ[0].src = this.url;
this.elements = [imageJQ.get(0)];

imageJQ.on("mousemove", function (event) {
var image = event.target;
var canvasName = edenUI.plugins.Canvas2D.canvasNameFromElement(image);
var canvasScale = root.lookup("_view_" + canvasName + "_scale").value() * root.lookup("_view_" + canvasName + "_zoom").value();
var mouseFollow = root.lookup("mouseFollow").value();
var imagePos = $(this).offset();
var x = (event.pageX - Math.round(imagePos.left)) / canvasScale;
var y = (event.pageY - Math.round(imagePos.top)) / canvasScale;
root.lookup("mousePosition").assign(new Point(x, y), root.scope, Symbol.hciAgent, mouseFollow);
});

if (name !== undefined) {
edenUI.plugins.Canvas2D.initZoneFromName(name, "HTMLImage");
imageJQ.on("mousedown", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
})
.on("mouseup", function () {
edenUI.plugins.Canvas2D.endClick();
})
.on("mouseenter", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
});
}

if (this.imageMap !== undefined) {
var mapJQ = $("<map name=\"" + id + "-map\" id=\"" + id + "-map\"></map>");

var setAreaEvents = function (area, regionName) {
area.on("mouseenter", function (event) {
var followMouse = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(regionName, root.scope, Symbol.hciAgent, followMouse);
})
.on("mousedown", function (event) {
var followMouse = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(regionName, root.scope, Symbol.hciAgent, followMouse);

}).on("mouseup", function (event) {
edenUI.plugins.Canvas2D.endClick();
});
};

for (var i = this.imageMap.length - 1; i >= 0; i--) {
var shape = this.imageMap[i];
var regionName;
if (shape.drawingOptions !== undefined) {
regionName = shape.drawingOptions.name;
} else {
regionName = undefined;
}
var areaJQ = $('<area ' + shape.imageMapArea() + '/>');
if (regionName !== undefined) {
setAreaEvents(areaJQ, regionName);
} else if (name !== undefined) {
setAreaEvents(areaJQ, name);
}
mapJQ.append(areaJQ);

if (eden.isValidIdentifier(regionName)) {
var clickSym = root.lookup(regionName + "_click");
if (clickSym.value() === undefined) {
clickSym.assign(false, root.scope, root.lookup("HTMLImage"));
}
}
}
this.elements.push(mapJQ.get(0));
}
}
};

HTMLImage.prototype.scale = function (scale, zoom, origin) {
var imageElem = this.elements[0];
var style = imageElem.style;
style.left = Math.round(this.x * scale + origin.x) + "px";
style.top = Math.round(this.y * scale + origin.y) + "px";
imageElem.width = Math.round(this.scaledWidth * scale / this.scaleFactor);
imageElem.height = Math.round(this.scaledHeight * scale / this.scaleFactor);
};

HTMLImage.prototype.toString = function() {
return "HTMLImage(" + Eden.edenCodeForValues(this.name, this.x, this.y, this.width, this.height, this.url, this.imageMap) + ")";
};

HTMLImage.prototype.getEdenCode = HTMLImage.prototype.toString;

}}$;

func imageWithZones {
auto name, width, height, url, imageMap, testing, items, argsProcessed;
auto i, shape, zoneName, centre;
items = [];
if (isString($[2])) {
name = $[1];
url = $[2];
argsProcessed = 2;
} else if (isList($[2])) {
url = $[1];
argsProcessed = 1;
} else if (isString($[1])) {
name = $[1];
width = $[2];
height = $[3];
url = $[4];
argsProcessed = 4;
} else {
width = $[1];
height = $[2];
url = $[3];
argsProcessed = 3;
}
imageMap = $[argsProcessed + 1];
testing = $[argsProcessed + 2];

if (testing) {
append items, Image(name, 0, 0, width, height, url);
for (i = 1; i <= imageMap#; i++) {
shape = imageMap[i];
append items, shape;
zoneName = shape.drawingOptions == @? @ : shape.drawingOptions.name;
if (zoneName != @) {
centre = shape.centre();
append items, Div(zoneName, centre.x - 5.5 * zoneName#, centre.y - 15, @, @, "color: white; background-color: black; font-size: 20px; font-family: monospace");
}
}
} else {
append items, HTMLImage(name, 0, 0, width, height, url, imageMap);
}
return items;
}


${{
Line = function(x1, y1, x2, y2, colours, drawingOptions) {
this.x1 = x1;
this.y1 = y1;
this.x2 = x2;
this.y2 = y2;
var align, valign, shift;
if (drawingOptions !== undefined) {
align = drawingOptions.align;
valign = drawingOptions.valign;
}
if (this.x1 == this.x2) {
if (align == "left") {
shift = -1;
} else if (align == "right") {
shift = 1;
} else {
shift = 0;
}
this.xShift1 = shift;
this.xShift2 = shift;
this.yShift1 = 0;
this.yShift2 = 0;
} else if (this.y1 == this.y2) {
if (valign == "top") {
shift = -1;
} else if (valign == "bottom") {
shift = 1;
} else {
shift = 0;
}
this.xShift1 = 0;
this.xShift2 = 0;
this.yShift1 = shift;
this.yShift2 = shift;
} else {
this.xShift1 = this.x2 > this.x1? 1 : -1;
this.xShift2 = -this.xShift1;
this.yShift1 = this.y2 > this.y1? 1 : -1;
this.yShift2 = -this.yShift1;
}
this.colours = colours;
this.drawingOptions = drawingOptions;
}
}}$;

func Line { ${{
var x1 = arguments[0];
var y1 = arguments[1];
var x2 = arguments[2];
var y2 = arguments[3];
var colours, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}
if (processUpTo == 4) {
colours = arguments[4];
}

if (colours === undefined) {
colours = ["black"];
} else if (!Array.isArray(colours)) {
colours = [colours];
} else if (colours.length == 0) {
colours = ["black"];
}
return new Line(x1, y1, x2, y2, colours, drawingOptions);
}}$; };

${{

Line.prototype.draw = function(context, scale) {
context.beginPath();
var xShift1, xShift2, yShift1, yShift2;
if (this.drawingOptions !== undefined) {
var zoom = (this.drawingOptions.lineWidth || edenUI.plugins.Canvas2D.defaultLineWidth) / context.lineWidth;
var width = (context.lineWidth / 2 + 0.5 / zoom) / Math.SQRT2;
xShift1 = this.xShift1 * width;
xShift2 = this.xShift2 * width;
yShift1 = this.yShift1 * width;
yShift2 = this.yShift2 * width;
if ((this.xShift1 == 0 || this.yShift1 == 0) && this.drawingOptions.lineWidth % 2 == 1) {
context.translate(0.5 / zoom, 0.5 / zoom);
}
} else {
xShift1 = 0;
xShift2 = 0;
yShift1 = 0;
yShift2 = 0;
}
var x1 = this.x1 + xShift1;
var y1 = this.y1 + yShift1;
var x2 = this.x2 + xShift2;
var y2 = this.y2 + yShift2;

if (this.colours.length == 1) {
context.strokeStyle = this.colours[0];
} else {
var colourGradient = context.createLinearGradient(x1, y1, x2, y2);
for (var i = 0; i < this.colours.length; i++) {
colourGradient.addColorStop(i / (this.colours.length - 1), this.colours[i]);
}
context.strokeStyle = colourGradient;
}

context.moveTo(x1, y1);
context.lineTo(x2, y2);
context.stroke();

if (this.drawingOptions !== undefined && this.drawingOptions.arrowhead instanceof Arrowhead) {
var gradient = (y2 - y1) / (x2 - x1);
var reversed = x1 > x2;
this.drawingOptions.arrowhead.draw(context, scale, x1, y1, gradient, reversed, x2, y2, gradient, reversed);
}
};

Line.prototype.toString = function() {
var s = "Line(" + Eden.edenCodeForValues(this.x1, this.y1, this.x2, this.y2) + ", ";

if (this.colours.length > 1) {
s = s + Eden.edenCodeForValue(this.colours);
} else {
s = s + Eden.edenCodeForValue(this.colours[0]);
}

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
};

Line.prototype.getEdenCode = Line.prototype.toString;

}}$;

func distanceMoved {
${{
var from, to;
if (arguments.length == 1) {
if (arguments[0] instanceof Line) {
var line = arguments[0];
from = new Point(line.x1, line.y1);
to = new Point(line.x2, line.y2);
} else {
to = arguments[0];
from = new Point(0, 0);
}
} else if (arguments.length == 2) {
from = arguments[0];
to = arguments[1];
if (from === undefined) {
return undefined;
} else if (!(from instanceof Point)) {
eden.error(new Error("distanceMoved: The first argument must be a Point, not a " + typeof(from)), "error");
return undefined;
}
} else {
eden.error(new Error("distanceMoved: This function requires at least 1 argument and at most 2 arguments"), "error");
return undefined;
}
if (to === undefined) {
return undefined;
} else if (!(to instanceof Point)) {
eden.error(new Error("distanceMoved: The destination point must be a Point or a Line, not a " + typeof(to)), "error");
return undefined;
}
if (from.x == undefined || from.y == undefined || to.x == undefined || to.y == undefined) {
return undefined;
}
var xDist = to.x - from.x;
var yDist = to.y - from.y;
return Math.sqrt(xDist * xDist + yDist * yDist);
}}$;
}

func angleTurned {
${{
var from, to;
if (arguments[0] instanceof Folder) {
//Probably not an actual function call but semicircleAngle observable changed.
return undefined;
} else if (arguments.length == 1) {
to = arguments[0];
from = new Point(0, 0);
} else if (arguments.length == 2) {
from = arguments[0];
to = arguments[1];
if (from === undefined) {
return undefined;
} else if (!(from instanceof Point)) {
eden.error(new Error("angleTurned: The first argument must be a Point, not a " + typeof(from)), "error");
return undefined;
}
} else {
eden.error(new Error("angleTurned: This function requires at at least 1 argument and most 2 arguments"), "error");
return undefined;
}
if (to === undefined) {
return undefined;
} else if (!(to instanceof Point)) {
eden.error(new Error("angleTurned: The destination point must be a Point, not a " + typeof(to)), "error");
return undefined;
}
if (from.x == undefined || from.y == undefined || to.x == undefined || to.y == undefined) {
return undefined;
}
var relativeX = to.x - from.x;
var relativeY = to.y - from.y;
return Math.atan2(relativeY, relativeX) * root.lookup("semicircleAngle").value() / Math.PI;
}}$;
}
semicircleAngle ~> [angleTurned];


/*
x = 50;
y = 50;
width = 400;
height = 250;
gradient is LinearGradient(x, y, x + width, y + height, "cyan", "blue");
rect is Rectangle(x, y, width, height, gradient);
picture is [rect];
*/

func LinearGradient {
${{
var x1 = arguments[0];
var y1 = arguments[1];
var x2 = arguments[2];
var y2 = arguments[3];
var colourStops;
if (Array.isArray(arguments[4])) {
colourStops = arguments[4];
} else {
if (Array.isArray(arguments[6])) {
colourStops = arguments[6];
} else {
colourStops = [];
}

var start_colour = arguments[4];
if (typeof(start_colour) != "string") {
start_colour = "black";
}

var end_colour = arguments[5];
if (typeof(end_colour) != "string") {
end_colour = "white";
}

colourStops.push([0, start_colour]);
colourStops.push([1, end_colour]);
}
return new LinearGradient(x1, y1, x2, y2, colourStops);
}}$;
}

${{
function LinearGradient(x1, y1, x2, y2, colourStops) {
this.x1 = x1;
this.y1 = y1;
this.x2 = x2;
this.y2 = y2;
this.colourStops = colourStops;
}

LinearGradient.prototype = new EdenUI.plugins.Canvas2D.FillStyle();

LinearGradient.prototype.getColour = function (context) {
var gradient = context.createLinearGradient(this.x1, this.y1, this.x2, this.y2);
var colourStop;
for (var i = 0; i < this.colourStops.length; i++) {
colourStop = this.colourStops[i];
gradient.addColorStop(colourStop[0], colourStop[1]);
}
return gradient;
};

LinearGradient.prototype.toString = function() {
return "LinearGradient(" + Eden.edenCodeForValues(this.x1, this.y1, this.x2, this.y2, this.colourStops) + ")";

};

LinearGradient.prototype.getEdenCode = LinearGradient.prototype.toString;

}}$;


${{
LineSequence = function(vertices, colours, drawingOptions) {
this.vertices = vertices;
this.colours = colours;
this.drawingOptions = drawingOptions;

this.minX = this.vertices[0].x;
this.minY = this.vertices[0].y;
this.maxX = this.minX, this.maxY = this.minY;
for (var i = 1; i < this.vertices.length; i++) {
var vertex = this.vertices[i];
if (vertex.x < this.minX) {
this.minX = vertex.x;
} else if (vertex.x > this.maxX) {
this.maxX = vertex.x;
}
if (vertex.y < this.minY) {
this.minY = vertex.y;
} else if (vertex.y > this.maxY) {
this.maxY = vertex.y;
}
}
}
}}$;

func LineSequence { ${{
var vertices = arguments[0];
var colours, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}
if (processUpTo == 1) {
colours = arguments[1];
}

if (colours === undefined) {
colours = ["black"];
} else if (!Array.isArray(colours)) {
colours = [colours];
} else if (colours.length == 0) {
colours = ["black"];
}

return new LineSequence(vertices, colours, drawingOptions);
}}$; };

${{
LineSequence.prototype.draw = function(context, scale) {
if (this.drawingOptions !== undefined && this.drawingOptions.lineWidth % 2 == 1) {
var zoom = this.drawingOptions.lineWidth / context.lineWidth;
context.translate(0.5 / zoom, 0.5 / zoom);
}

context.beginPath();
var maxVertex = this.vertices.length - 1;
if (this.colours.length == 1) {
context.strokeStyle = this.colours[0];
} else {
var gradient = context.createLinearGradient(this.minX, this.minY, this.maxX, this.maxY);
for (var i = 0; i < this.colours.length; i++) {
gradient.addColorStop(i / (this.colours.length - 1), this.colours[i]);
}
context.strokeStyle = gradient;
}

context.moveTo(this.vertices[0].x, this.vertices[0].y);
for (var i = 1; i <= maxVertex; i++) {
context.lineTo(this.vertices[i].x, this.vertices[i].y);
}

context.stroke();

if (this.drawingOptions !== undefined && this.drawingOptions.arrowhead instanceof Arrowhead) {
var vertex0 = this.vertices[0];
var vertex1 = this.vertices[1];
var vertexN = this.vertices[maxVertex];
var vertexNMinus1 = this.vertices[maxVertex - 1];
var gradient1 = (vertex1.y - vertex0.y) / (vertex1.x - vertex0.x);
var gradient2 = (vertexN.y - vertexNMinus1.y) / (vertexN.x - vertexNMinus1.x);
var reverse1 = vertex0.x > vertex1.x;
var reverse2 = vertexNMinus1.x > vertexN.x;
this.drawingOptions.arrowhead.draw(context, scale, vertex0.x, vertex0.y, gradient1, reverse1,
vertexN.x, vertexN.y, gradient2, reverse2);
}
};

LineSequence.prototype.toString = function() {
var s = "LineSequence(" + Eden.edenCodeForValue(this.vertices) + ",";

if (this.colours.length > 1) {
s = s + Eden.edenCodeForValue(this.colours);
} else {
s = s + Eden.edenCodeForValue(this.colours[0]);
}

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
};

LineSequence.prototype.getEdenCode = LineSequence.prototype.toString;

}}$;


${{
Polygon = function(vertices, fillcolour, outlinecolour, drawingOptions) {
this.vertices = vertices;
this.fillcolour = fillcolour;
this.outlinecolour = outlinecolour;
this.drawingOptions = drawingOptions;
this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Polygon");
this.obsName = root.currentObservableName();
}
}}$;

func Polygon { ${{
var vertices = arguments[0];
if (vertices[0].x != vertices[vertices.length - 1].x || vertices[0].y != vertices[vertices.length - 1].y) {
vertices.push(vertices[0]);
}

var fillcolour, outlinecolour, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}
if (processUpTo >= 1) {
fillcolour = arguments[1];
if (processUpTo == 2) {
outlinecolour = arguments[2];
}
}

if (outlinecolour === undefined) {
if (fillcolour === undefined) {
outlinecolour = "black";
}
}

return new Polygon(vertices, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

Polygon.prototype.draw = function (context) {
if (this.drawingOptions !== undefined && this.drawingOptions.lineWidth % 2 == 1) {
var scale = this.drawingOptions.lineWidth / context.lineWidth;
context.translate(0.5 / scale, 0.5 / scale);
}

this.tracePath(context);

if (this.fillcolour !== undefined) {
edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
context.fill();
}

if (this.outlinecolour !== undefined) {
context.strokeStyle = this.outlinecolour;
context.stroke();
}
};

Polygon.prototype.tracePath = function (context) {
context.beginPath();
context.moveTo(this.vertices[0].x, this.vertices[0].y);
for (var i = 1; i < this.vertices.length; i++) {
context.lineTo(this.vertices[i].x, this.vertices[i].y);
}
context.closePath();
}

Polygon.prototype.isHit = function (context, scale, x, y) {
this.tracePath(context);
return context.isPointInPath(x,y);
}

Polygon.prototype.toString = function() {
var s = "Polygon(" + Eden.edenCodeForValues(this.vertices, this.fillcolour, this.outlinecolour);

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
};

Polygon.prototype.getEdenCode = Polygon.prototype.toString;

Polygon.prototype.imageMapArea = function () {
var s = "shape=\"poly\" coords=\"";
for (var i = 0; i < this.vertices.length; i++) {
var vertex = this.vertices[i];
s = s + vertex.x + "," + vertex.y + ",";
}
s = s.slice(0, -1);
s = s + "\"";
return s;
}

Polygon.prototype.centre = function () {
var centreX = 0, centreY = 0;
for (var i = 0; i < this.vertices.length; i++) {
centreX = centreX + this.vertices[i].x;
centreY = centreY + this.vertices[i].y;
}
centreX = centreX / this.vertices.length;
centreY = centreY / this.vertices.length;
return new Point(centreX, centreY);
}

}}$;


${{
Rectangle = function(x, y, width, height, fillcolour, outlinecolour, drawingOptions) {
this.x = x;
this.y = y;
this.width = width;
this.height = height;
this.fillcolour = fillcolour;
this.outlinecolour = outlinecolour;
this.drawingOptions = drawingOptions;
this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Rectangle");
this.obsName = root.currentObservableName();
}
}}$;

func Rectangle { ${{
var x = arguments[0];
var y = arguments[1];
var width = arguments[2];
var height = arguments[3];
var fillcolour, outlinecolour, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}
if (processUpTo >= 4) {
fillcolour = arguments[4];
if (processUpTo == 5) {
outlinecolour = arguments[5];
}
}
if (fillcolour === undefined && outlinecolour === undefined) {
outlinecolour = "black";
}
return new Rectangle(x, y, width, height, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

Rectangle.prototype.draw = function (context) {
var lineWidth;
if (this.outlinecolour !== undefined) {
lineWidth = context.lineWidth;
if (this.drawingOptions !== undefined) {
if (!("join" in this.drawingOptions) && lineWidth < 10) {
//Bug in Chrome v44, shape isn't drawn when miter join is used with larger line widths.
context.lineJoin = "miter"
}
}
} else {
lineWidth = 0;
}
if (this.fillcolour !== undefined) {
edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
context.fillRect(this.x + lineWidth, this.y + lineWidth, this.width - 2 * lineWidth, this.height - 2 * lineWidth);
}
if (this.outlinecolour !== undefined) {
context.strokeStyle = this.outlinecolour;
context.strokeRect(this.x + lineWidth / 2, this.y + lineWidth / 2, this.width - lineWidth, this.height - lineWidth);
}
};

Rectangle.prototype.isHit = function (context, scale, x, y) {
return x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height;
}

Rectangle.prototype.toString = function() {
var s = "Rectangle(" + Eden.edenCodeForValues(this.x, this.y, this.width, this.height, this.fillcolour, this.outlinecolour);

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
};

Rectangle.prototype.getEdenCode = Rectangle.prototype.toString;

Rectangle.prototype.imageMapArea = function () {
return "shape=\"rect\" coords=\"" + this.x + "," + this.y + "," + (this.x + this.width) + "," +
(this.y + this.height) + "\"";
}

Rectangle.prototype.centre = function () {
return new Point(this.x + this.width / 2, this.y + this.height / 2);
}

}}$;


${{
Slider = function(name, min, max, step, labelInterval, tickMarkInterval, labelDivisor, x, y, length, orientation, enabled) {
this.name = name;
this.obsName = root.currentObservableName();
this.min = min;
this.max = max;
this.step = step;
this.labelInterval = labelInterval;
this.tickMarkInterval = tickMarkInterval;
this.labelDivisor = labelDivisor;
this.x = x;
this.y = y;
this.length = length;
this.orientation = orientation;
this.enabled = enabled;
}

Slider.prototype.hash = function () {
return this.name+"$$"+
this.min+"$$"+
this.max+"$$"+
this.step+"$$"+
this.labelInterval+"$$"+
this.tickMarkInterval+"$$"+
this.labelDivisor+"$$"+
this.x+"$$"+
this.y+"$$"+
this.length+"$$"+
this.orientation+"$$"+
this.enabled;
};
}}$;

func Slider { ${{
var argsProcessed;

var name;
if (typeof(arguments[0]) == "string") {
name = arguments[0];
argsProcessed = 1;
} else {
name = root.currentObservableName();
argsProcessed = 0;
if (name === undefined) {
eden.error(new Error("Slider: Every slider must have a name."), "error");
return undefined;
}
}
var min = arguments[argsProcessed];
argsProcessed++;
var max = arguments[argsProcessed];
argsProcessed++;

var step, labelInterval, labelDivisor, tickMarkInterval, x, y, length, orientation, enabled;
var arg, argType;
if (typeof(arguments[argsProcessed + 6]) == "number") {
step = arguments[argsProcessed];
labelInterval = arguments[argsProcessed + 1];
tickMarkInterval = arguments[argsProcessed + 2];
labelDivisor = arguments[argsProcessed + 3];
argsProcessed = argsProcessed + 4;
} else if (typeof(arguments[argsProcessed + 5]) == "number") {
step = arguments[argsProcessed];
labelInterval = arguments[argsProcessed + 1];
tickMarkInterval = arguments[argsProcessed + 2];
argsProcessed = argsProcessed + 3;
} else if (typeof(arguments[argsProcessed + 4]) == "number") {
step = arguments[argsProcessed];
labelInterval = arguments[argsProcessed + 1];
argsProcessed = argsProcessed + 2;
} else if (typeof(arguments[argsProcessed + 3]) == "number") {
step = arguments[argsProcessed];
argsProcessed++;
} else if (max - min > 1 && Math.floor(min) == min && Math.floor(max) == max) {
step = 1;
}
x = arguments[argsProcessed];
y = arguments[argsProcessed + 1];
length = arguments[argsProcessed + 2];
argsProcessed = argsProcessed + 3;
arg = arguments[argsProcessed];
argType = typeof(arg);
if (arg === undefined || argType == "string") {
orientation = arguments[argsProcessed];
argsProcessed++;
arg = arguments[argsProcessed];
}
enabled = arg;

if (labelInterval !== undefined) {
if (labelDivisor === undefined) {
labelDivisor = 1;
}
if (tickMarkInterval === undefined) {
tickMarkInterval = labelInterval;
}
}
if (orientation === undefined) {
orientation = "horizontal";
}
if (enabled === undefined) {
enabled = true;
}

return new Slider(name, min, max, step, labelInterval, tickMarkInterval, labelDivisor, x, y, length, orientation, enabled);
}}$; }

${{

Slider.prototype.draw = function (context) {

if (this.elements === undefined) {
var name = this.name;
var me = this;
var agent = root.lookup("Slider");

var cssClass;
if (this.orientation == "down"){
cssClass = "slider-down"
} else if (this.orientation == "up" || this.orientation == "vertical") {
cssClass = "slider-up"
} else {
cssClass = "slider-horizontal";
}
var disabled = this.enabled === false? "disabled=\"disabled\"" : "";
var inputHTML = '<input ' +
disabled +
'type="range" ' +
'min="' + this.min + '" ' +
'max="' + this.max + '" ';
if (this.step === undefined) {
inputHTML = inputHTML + 'step="0.0000001"';
} else {
inputHTML = inputHTML + 'step="' + this.step + '"';
}
inputHTML = inputHTML + '/>';
var inputJQ = $(inputHTML);
var inputElem = inputJQ.get(0);
this.sliderElement = inputElem;

var valueSym = root.lookup(name + "_value");
var previewSym = root.lookup(name + "_preview");

function setValue(obs, value, force) {
var previewSym = root.lookup(name + "_preview");
var previewValue = previewSym.value();
if (previewValue !== value || force) {
var roundedValue;
if (value >= me.min && value <= me.max) {
inputElem.value = value;
roundedValue = parseFloat(inputElem.value);
if (roundedValue != value) {
//Value didn't match the step size.
obs.assign(roundedValue, root.scope, agent);
}
} else {
if (value < me.min) {
inputElem.value = me.min;
} else {
inputElem.value = me.max;
}
if (me.step !== undefined) {
roundedValue = Math.round(((value - me.min) / me.step).toPrecision(16)) * me.step + me.min;
if (roundedValue != value) {
obs.assign(roundedValue, root.scope, agent);
}
} else {
roundedValue = value;
}
}
if (previewValue != roundedValue) {
previewSym.assign(roundedValue, root.scope, Symbol.hciAgent);
}
}
}

valueSym.addJSObserver("updateUI", setValue);
previewSym.addJSObserver("updateUI", function (obs, preview) {
var previewSym = root.lookup(name + "_preview");
var valueSym = root.lookup(name + "_value");
if (previewSym.last_modified_by !== Symbol.hciAgent.name) {
var roundedValue;
if (preview >= me.min && preview <= me.max) {
inputElem.value = preview;
roundedValue = parseFloat(inputElem.value);
if (roundedValue != preview) {
//Value didn't match the step size.
obs.assign(roundedValue, root.scope, agent);
}
} else {
if (preview < me.min) {
inputElem.value = me.min;
} else {
inputElem.value = me.max;
}
if (me.step !== undefined) {
roundedValue = Math.round(((preview - me.min) / me.step).toPrecision(16)) * me.step + me.min;
if (roundedValue != value) {
obs.assign(roundedValue, root.scope, agent);
}
} else {
roundedValue = preview;
}
}
valueSym.assign(roundedValue, root.scope, agent);
}
});

inputJQ
.on("input", function(){
root.lookup(name + "_preview").assign(parseFloat(this.value), root.scope, Symbol.hciAgent, true);
})
.on("mousedown", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(undefined, root.scope, Symbol.hciAgent, mouseFollow);
})
.on("mouseup", function () {
root.lookup(name + "_value").assign(parseFloat(this.value), root.scope, Symbol.hciAgent, true);
edenUI.plugins.Canvas2D.endClick();
})
.on("keyup", function () {
root.lookup(name + "_value").assign(parseFloat(this.value), root.scope, Symbol.hciAgent, true);
})
.on("mouseenter", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
});

var outerDiv = $('<div class="' + cssClass + '" ></div>');
if ((this.tickMarkInterval > 0 || this.labelInterval > 0) && this.max > this.min) {
var innerDiv = $('<div style="position: relative; height: 100%"></div>');
outerDiv.append(innerDiv);
if (this.tickMarkInterval > 0) {
for (var i = this.min; i <= this.max; i = i + this.tickMarkInterval) {
var percentage = (i - this.min) / (this.max - this.min) * 100;
//The offset is to get the centre of the slider thumb positioned exactly on the tick mark.
var offset = Math.round((50 - percentage) / 100 * 10);
var position = 'calc(' + percentage + '% + ' + offset + 'px)';
var tickMark = $('<div"></div>');
if (this.orientation == "horizontal") {
tickMark.css("left", position);
} else {
tickMark.css("top", position);
}
if ((i - this.min) % this.labelInterval == 0) {
tickMark.addClass("slider-major-tick-mark");
} else {
tickMark.addClass("slider-minor-tick-mark");
}
innerDiv.append(tickMark);
}
}
inputJQ.css("width", "100%");
innerDiv.append(inputJQ);
if (this.labelInterval > 0) {
if (this.orientation == "horizontal") {
var labelWidth = 100 / ((this.max - this.min) / this.labelInterval);
var halfLabelWidth = labelWidth / 2;
for (var i = this.min; i <= this.max; i = i + this.labelInterval) {
var percentage = (i - this.min) / (this.max - this.min) * 100 - halfLabelWidth;
var offset = Math.round((50 - percentage) / 100 * 10);
var labelText = i / this.labelDivisor;
var label = $(
'<div ' +
'class="slider-label" ' +
'style="left: calc(' + percentage + '% + ' + offset + 'px); width: ' + labelWidth + '%"' +
'>' +
labelText +
'</div>'
);
innerDiv.append(label);
}
} else {
for (var i = this.max; i >= this.min; i = i - this.labelInterval) {
var percentage = (this.max - i) / (this.max - this.min) * 100;
var offset = Math.round((50 - percentage) / 100 * 10 + 1);
var labelText;
if (this.orientation == "down") {
labelText = (this.max - i) / this.labelDivisor;
} else {
labelText = i / this.labelDivisor;
}
var label = $(
'<div ' +
'class="slider-label" ' +
'style="top: calc(' + percentage + '% + ' + offset + 'px - 0.5em)"' +
'>' +
labelText +
'</div>'
);
innerDiv.append(label);
}
}
}
} else {
outerDiv.append(inputJQ);
}
this.elements = [outerDiv.get(0)];

//Initialization
var value = valueSym.value();
var previewValue = previewSym.value();
if (value === undefined) {
if (previewValue === undefined) {
var defaultValue = (this.max - this.min) / 2 + this.min;
valueSym.assign(defaultValue, root.scope, agent);
setValue(valueSym, defaultValue, true);
} else {
valueSym.assign(previewValue, root.scope, agent);
setValue(valueSym, previewValue, true);
}
} else {
setValue(valueSym, value, true);
}
}
};

Slider.prototype.scale = function (scale, zoom, origin) {
if (!this.sliderElement) {
return;
}
var slider = this.sliderElement;
var sliderStyle = slider.style;
var divStyle = this.elements[0].style;
var width = Math.round(this.length * scale);
var isVertical = this.orientation == "up" || this.orientation == "down" || this.orientation == "vertical";
if (isVertical) {
sliderStyle.left = Math.round(-this.length / 2 * scale) + "px";
sliderStyle.top = Math.round((this.length / 2 - 10) * scale) + "px";
sliderStyle.width = width + "px";
divStyle.height = width + "px";
} else {
divStyle.width = width + "px";
}

divStyle.fontSize = zoom + "em";
divStyle.left = Math.round(this.x * scale + origin.x) + "px";
divStyle.top = Math.round(this.y * scale + origin.y) + "px";

if (this.step == undefined) {
slider.step = String((slider.max - slider.min) / (width  - 1)).slice(0, 16);
}
};

Slider.prototype.toString = function() {
if (this.name == this.obsName) {
return "Slider(" + Eden.edenCodeForValues(this.min, this.max, this.step, this.labelInterval,
this.tickMarkInterval, this.labelDivisor, this.x, this.y, this.length, this.orientation,
this.enabled) + ")";
} else {
return "Slider(" + Eden.edenCodeForValues(this.name, this.min, this.max, this.step,
this.labelInterval, this.tickMarkInterval, this.labelDivisor, this.x, this.y,
this.length, this.orientation, this.enabled) + ")";
}
};

Slider.prototype.getEdenCode = Slider.prototype.toString;

}}$;


${{
Text = function(text, x, y, size, fillcolour, outlinecolour, options) {
this.text = text;
this.x = x;
this.y = y;
this.size = size;
this.fillcolour = fillcolour;
this.outlinecolour = outlinecolour;

var css;

if (options instanceof Object) {
if (!("valign" in options)) {
options.valign = "top";
}
this.drawingOptions = options;

if (options.italic) {
css = "italic ";
} else {
css = "";
}
if (options.smallCaps) {
css = css + "small-caps ";
}
if (options.bold) {
css = css + "bold ";
}
css = css + size + " ";
if (options.fontFace === undefined) {
css = css + "sans-serif";
} else {
css = css + options.fontFace + ", sans-serif";
}

} else if (typeof(options) == "string") {
this.optionString = options;
var valignRE = /\b(top|hanging|middle|baseline|alphabetic|ideographic|bottom)\b/;
var searchResults = valignRE.exec(options);
if (searchResults === null) {
this.drawingOptions = {valign: "top"};
} else {
this.drawingOptions = {valign: searchResults[0]};
options = options.replace(valignRE, "");
}
var halignRE = /\b(left|right|center|centre|start|end)\b/;
searchResults = halignRE.exec(options);
if (searchResults !== null) {
this.drawingOptions.align = searchResults[0];
options = options.replace(halignRE, "");
}
css = options;
} else {
css = size + " sans-serif";
this.drawingOptions = {valign: "top"};
}
if (this.drawingOptions.align == "centre") {
this.drawingOptions.align = "center";
}
if (this.drawingOptions.valign == "baseline") {
this.drawingOptions.valign = "alphabetic";
}
this.css = css;
this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(options, "Text");
this.obsName = root.currentObservableName();
}
}}$;

func Text {
${{
var text = arguments[0];
var x = arguments[1];
var y = arguments[2];
var size, fillcolour, outlinecolour, options;

var argType = typeof(arguments[3]);
var sizePresent = argType == "number" ||
(argType == "string" && /^\d+(\.\d+)?[a-zA-Z%]+$/.test(arguments[3]));
//N.B. First \d+ above cannot be \d* as that matches "red".

var numArgs = arguments.length;
var lastArg = arguments[numArgs - 1];
argType = typeof(lastArg);
if (argType == "string" && !sizePresent && (numArgs == 6 || lastArg.indexOf(" ") !== -1)) {
options = lastArg;
if (numArgs > 4) {
fillcolour = arguments[3];
if (numArgs > 5) {
outlinecolour = arguments[4];
}
}
} else if (argType == "object" && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
options = lastArg;
if (numArgs > 4) {
var argsProcessed;
if (sizePresent || arguments[3] === undefined) {
size = arguments[3];
argsProcessed = 4;
} else {
argsProcessed = 3;
}
if (numArgs > argsProcessed + 1) {
fillcolour = arguments[argsProcessed];
argsProcessed++;
if (numArgs > argsProcessed + 1) {
outlinecolour = arguments[argsProcessed];
}
}
}
} else {
size = arguments[3];
fillcolour = arguments[4];
outlinecolour = arguments[5];
options = arguments[6]; //Deliberately left in, even though size parameter will currently be ignored if this is specified.
}

if (size === undefined) {
size = "1em";
} else if (typeof(size) == "number") {
size = size + "px";
}
if (outlinecolour === undefined && fillcolour === undefined) {
fillcolour = "black";
}
return new Text(text, x, y, size, fillcolour, outlinecolour, options);
}}$;
}

${{

Text.prototype.draw = function (context, scale) {

if (scale != 1) {
var inverseScale = 1 / scale;
context.scale(inverseScale, inverseScale);
}
context.font = this.css;
context.textBaseline = this.drawingOptions.valign;
if ("align" in this.drawingOptions) {
context.textAlign = this.drawingOptions.align;
}
var lineWidth = context.lineWidth;
var x = (this.x + lineWidth / 2) * scale + 1;
var y = this.y * scale + 1;

if (this.fillcolour !== undefined) {
edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
context.fillText(this.text, x, y);
}
if (this.outlinecolour !== undefined) {
context.lineWidth = lineWidth * scale;
context.strokeStyle = this.outlinecolour;
context.strokeText(this.text, x, y);
}
};

Text.prototype.isHit = function (context, scale, px, py) {
var x = this.x + 1 / scale;
var y = this.y + 1 / scale;
var width, height;

if (this.width === undefined) {
var div = document.createElement("div");
div.innerHTML = this.text;
div.style.position = 'absolute';
div.style.top  = '-9999px';
div.style.font = this.css;
document.body.appendChild(div);
this.width = div.offsetWidth;
this.height = div.offsetHeight;
document.body.removeChild(div);
}

var lineWidth = context.lineWidth;
width = this.width / scale + lineWidth;
height = this.height / scale + lineWidth / 2;

return px >= x && px < x + width && py >= y && py < y + height;
}

Text.prototype.toString = function() {
var s = "Text(" + Eden.edenCodeForValues(this.text, this.x, this.y) + ", ";

if (this.optionString !== undefined) {
s = s + Eden.edenCodeForValues(this.fillcolour, this.outlinecolour) + ", " +
"\"" + this.optionString + "\")";
} else {
s = s + Eden.edenCodeForValues(this.size, this.fillcolour, this.outlinecolour, this.drawingOptions) + ")";
}
return s;
};

Text.prototype.getEdenCode = Text.prototype.toString;

Text.parseArgs = function () {
var text = arguments[0];

var size, options, optionsObj, scale;
var argsProcessed = 1;
var arg = arguments[1];
var argType = typeof(arg);

if (arg === undefined || argType == "number" || (argType == "string" && /^\d+(\.\d+)?[a-zA-Z%]+$/.test(arg))) {
//N.B. First \d+ above cannot be \d* as that matches "red".
size = arg;
argsProcessed++;
arg = arguments[argsProcessed];
argType = typeof(arg);
}
if (argType === undefined || argType == "object" || argType == "string") {
options = arg;
argsProcessed++;
arg = arguments[argsProcessed];
}
scale = arg;

if (typeof(options) == "string") {
if (size !== undefined) {
eden.error(new Error("textWidth/textHeight: The size argument cannot be specified when the options parameter is given as a string.  The font size should be included in the options string.  See https://drafts.csswg.org/css2/fonts.html#font-shorthand"), "error");
return undefined;
}
} else {
if (size === undefined) {
size = "1em";
} else if (typeof(size) == "number") {
size = size + "px";
}
}

if (scale === undefined) {
scale = 1;
}

var css;
if (options instanceof Object) {
optionsObj = options;
if (options.italic) {
css = "italic ";
} else {
css = "";
}
if (options.smallCaps) {
css = css + "small-caps ";
}
if (options.bold) {
css = css + "bold ";
}
css = css + size + " ";
if (options.fontFace === undefined) {
css = css + "sans-serif";
} else {
css = css + options.fontFace + ", sans-serif";
}
} else if (typeof(options) == "string") {
options = options.replace(/\b(top|hanging|middle|baseline|alphabetic|ideographic|bottom|left|right|center|centre|start|end)\b\s*/g, "");
css = options;
optionsObj = {};
} else {
css = size + " sans-serif";
optionsObj = {};
}
return [css, optionsObj, scale];
};

}}$;

func textWidth {
${{
var text = arguments[0];
var options = Text.parseArgs.apply(undefined, arguments);
var css = options[0];
var optionsObj = options[1];
var scale = options[2];

//Find an existing canvas (any one).
var canvas;
for (var canvasName in canvases) {
canvas =  canvases[canvasName];
break;
}
if (canvas === undefined) {
return undefined;
}

var context = canvas.getContext("2d");
context.save();
edenUI.plugins.Canvas2D.configureContextDefaults(context, 1);
edenUI.plugins.Canvas2D.configureContext(context, 1, 1, optionsObj);
context.font = css;
context.textBaseline = "top";
var metrics = context.measureText(text);
var width = Math.ceil(metrics.width + context.lineWidth) / scale;
context.restore();
return width;
}}$;
}

func textHeight {
${{
var text = arguments[0];
var options = Text.parseArgs.apply(undefined, arguments);
var fontCSS = options[0];
var optionsObj = options[1];
var scale = options[2];

var lineWidth = optionsObj.lineWidth;
if (lineWidth === undefined) {
lineWidth = 2;
}

var div = document.createElement("div");
div.innerHTML = text;
var style = div.style;
style.position = 'absolute';
style.top  = '-9999px';
style.borderWidth = "0pt";
style.padding = "0pt";
style.whiteSpace = "nowrap";
style.font = fontCSS;

//Find an existing canvas (any one).
var canvas, parent;
for (var canvasName in canvases) {
canvas =  canvases[canvasName];
break;
}
if (canvas) {
parent = canvas.parentNode;
}
if (!parent) {
parent = document.body;
}

parent.appendChild(div);
var height = div.scrollHeight;
parent.removeChild(div);
/* N.B. even when the vertical alignment is "top" Chrome still leaves a small top margin
* where as Firefox doesn't.
*/
return (height + lineWidth / 2) / scale;
}}$;
}


${{
Pixel = function(x, y, colour) {
this.x = x;
this.y = y;
this.colour = colour;
}
}}$;

func Pixel { ${{
var x = arguments[0];
var y = arguments[1];
var colour = arguments[2];
return new Pixel(x, y, colour);
}}$; };

${{
Pixel.prototype.toString = function() {
return "Pixel("+ Eden.edenCodeForValues(this.x, this.y, this.colour) + ")";
};

Pixel.prototype.getEdenCode = Pixel.prototype.toString;
}}$;

${{
Pixel.prototype.draw = function(context) {
context.fillStyle = this.colour;
context.fillRect( this.x, this.y, 1, 1);
};
}}$;

/*
func colourMap {
para b;
auto data, i, j;
data = [];
for (j = 0; j <= 255; j++) {
for (i = 0; i <= 255; i++) {
append data, i;
append data, j;
append data, b;
append data, 255;
}
}
return data;
}

blue = 50;
pixelData is colourMap(blue);
pixels is PixelList(&pixelData, 20, 20, 256);
picture is [pixels];
*/

func PixelList {
${{
var name;
var argsProcessed;
if (typeof(arguments[0]) == "string") {
name = arguments[0];
argsProcessed = 1;
} else {
argsProcessed = 0;
}
var ptrToData = arguments[argsProcessed];
argsProcessed++;
var x = arguments[argsProcessed];
argsProcessed++;
var y = arguments[argsProcessed];
argsProcessed++;
var width = arguments[argsProcessed];
argsProcessed++;
return new PixelList(name, ptrToData, x, y, width);
}}$;
}

${{
function PixelList(name, ptrToData, x, y, width) {
this.name = edenUI.plugins.Canvas2D.initZoneFromName(name, "PixelList");
this.obsName = root.currentObservableName();
this.ptr = ptrToData;
this.data = ptrToData instanceof Symbol? ptrToData.value() : [];
this.x = x;
this.y = y;
this.width = width;
this.height = this.data.length / (4 * width);
}

PixelList.prototype.draw = function (context) {
var imageData = context.createImageData(this.width, this.height);
var imageArr = imageData.data;
var dataArr = this.data;
var arrayLen = dataArr.length;
for (var i = 0; i < arrayLen; i++) {
imageArr[i] = dataArr[i];
}
context.putImageData(imageData, this.x, this.y);
}

PixelList.prototype.isHit = function (context, scale, x, y) {
return x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height;
}

PixelList.prototype.toString = function() {
var s = "PixelList(";
if (this.name !== undefined) {
s = s + Eden.edenCodeForValue(this.name) + ", ";
}
s = s + Eden.edenCodeForValues(this.ptr, this.x, this.y, this.width) + ")";
return s;
}

PixelList.prototype.getEdenCode = PixelList.prototype.toString;

}}$;



func RadialGradient {
${{
var x1, y1, r1, x2, y2, r2, colourStops;
x1 = arguments[0];
y1 = arguments[1];

switch (arguments.length) {
case 4:
r1 = 0;
x2 = x1;
y2 = y1;
r2 = arguments[2];
colourStops = arguments[3];
break;
}
return new RadialGradient(x1, y1, r1, x2, y2, r2, colourStops);
}}$;
}

${{
function RadialGradient(x1, y1, r1, x2, y2, r2, colourStops) {
this.x1 = x1;
this.y1 = y1;
this.r1 = r1;
this.x2 = x2;
this.y2 = y2;
this.r2 = r2;
this.colourStops = colourStops;
}

RadialGradient.prototype = new EdenUI.plugins.Canvas2D.FillStyle();

RadialGradient.prototype.getColour = function (context) {
var gradient = context.createRadialGradient(this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);
var colourStop;
for (var i = 0; i < this.colourStops.length; i++) {
colourStop = this.colourStops[i];
gradient.addColorStop(colourStop[0], colourStop[1]);
}
return gradient;
};

RadialGradient.prototype.toString = function() {
return "RadialGradient(" + Eden.edenCodeForValues(this.x1, this.y1, this.r1, this.x2, this.y2, this.r2, this.colourStops) + ")";

};

RadialGradient.prototype.getEdenCode = RadialGradient.prototype.toString;

}}$;


${{
RadioButtons = function (name, values, labels, x, y, width, horizontal, enabled) {
this.name = name;
this.obsName = root.currentObservableName();
this.values = values;
this.labels = labels;
this.x = x;
this.y = y;
this.width = width;
this.horizontal = horizontal;
this.enabled = enabled;
}

RadioButtons.prototype.hash = function () {
return this.name+"$$"+
(Array.isArray(this.values)? this.values.join("$$") : "") +
(Array.isArray(this.labels)? this.labels.join("$$") : "") +
this.x+"$$"+
this.y+"$$"+
this.width+"$$"+
this.horizontal+"$$"+
this.enabled
};
}}$;

func RadioButtons { ${{
var argsProcessed;

var name;
if (typeof(arguments[0]) == "string") {
name = arguments[0];
argsProcessed = 1;
} else {
name = root.currentObservableName();
argsProcessed = 0;
if (name === undefined) {
eden.error(new Error("RadioButtons: Every group of radio buttons must have a name."), "error");
return undefined;
}
}

var values = arguments[argsProcessed];
argsProcessed++;
var labels;
if (Array.isArray(arguments[argsProcessed])) {
labels = arguments[argsProcessed];
argsProcessed++;
} else {
labels = values;
}
var x = arguments[argsProcessed];
argsProcessed++;
var y = arguments[argsProcessed];
argsProcessed++;
var width;
if (typeof(arguments[argsProcessed]) ==  "number" || arguments.length - argsProcessed > 2) {
width = arguments[argsProcessed];
argsProcessed++;
}
var horizontal = arguments[argsProcessed];
argsProcessed++;
var enabled = arguments[argsProcessed];

return new RadioButtons(name, values, labels, x, y, width, horizontal, enabled);
}}$; }

${{

RadioButtons.prototype.makeHTML = function() {
var build = "";

for (var i = 0; i < this.values.length; i++) {
build = build + '<label><input type="radio" name="' + this.name + '" value="' + this.values[i] + '"/> ' +
this.labels[i] + '</label> &nbsp;<br/>';
}

if (this.horizontal) {
return '<form style="position: absolute" class="canvas-horizontal-radio-buttons">' + build + '</form>';
} else {
return '<form style="position: absolute">' + build + '</form>';
}
};

RadioButtons.prototype.draw = function (context) {

if(this.elements === undefined) {
var name = this.name;

//Make the HTML
var formJQ = $(this.makeHTML());

var formElement = formJQ.get(0);
var updateValue = function (buttonGroup, value) {
for (var i = 0; i < buttonGroup.length; i++) {
if (buttonGroup[i].value == value) {
buttonGroup[i].checked = true;
break;
} else {
//Possibility of having no radio button selected.
buttonGroup[i].checked = false;
}
}

};
var valueSym = root.lookup(name + "_value");
var initialValue = valueSym.value();
if (initialValue !== undefined) {
updateValue(formElement.elements, initialValue);
}
valueSym.addJSObserver("updateUI", function (symbol, value) {
updateValue(formElement.elements, value);
});

formJQ.change(function(event) {
root.lookup(name + "_value").assign(event.target.value, root.scope, Symbol.hciAgent, true);
})
.on("mousedown", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(undefined, root.scope, Symbol.hciAgent, mouseFollow);
})
.on("mouseup", function () {
edenUI.plugins.Canvas2D.endClick();
})
.on("mouseenter", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
});

this.elements = [formElement];
}
};

RadioButtons.prototype.scale = function (scale, zoom, origin) {
var elem = this.elements[0];
var style = elem.style;
style.left = Math.round(this.x * scale + origin.x) + "px";
style.top = Math.round(this.y * scale + origin.y) + "px";
if (this.width === undefined) {
style.width = "";
} else {
style.width = Math.round(this.width * scale) + "px";
}
style.fontSize = zoom + "em";
var buttonSize = Math.round(13 * zoom) + "px";
$(elem).find("input").css({width: buttonSize, height: buttonSize});
};

RadioButtons.prototype.toString = function() {
if (this.name == this.obsName) {
return "RadioButtons(" + Eden.edenCodeForValues(this.values, this.labels, this.x,
this.y, this.width, this.horizontal, this.enabled) + ")";
} else {
return "RadioButtons(" + Eden.edenCodeForValues(this.name, this.values, this.labels, this.x,
this.y, this.width, this.horizontal, this.enabled) + ")";
}
};

RadioButtons.prototype.getEdenCode = RadioButtons.prototype.toString;

}}$;

${{
RegularPolygon = function (x, y, r, n, star, rotation, interiorOutline, fillcolour, outlinecolour, drawingOptions) {
this.x = x;
this.y = y;
this.r = r;
this.n = n;
this.star = star;
this.interiorOutline = interiorOutline;
this.rotation = rotation;
this.rotationInRadians = rotation * Math.PI / root.lookup("semicircleAngle").value();
this.fillcolour = fillcolour;
this.outlinecolour = outlinecolour;
this.drawingOptions = drawingOptions;
this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "RegularPolygon");
this.obsName = root.currentObservableName();

this.exteriorAngle = (2 * Math.PI) / n;
this.vertices = [];
var pointsDone = new Array(n);
var px, py;
var currentPolygonVertices, currentPoint;
var nudge;
if (drawingOptions !== undefined && drawingOptions.valign == "bottom") {
if (drawingOptions.lineWidth !== undefined) {
nudge = drawingOptions.lineWidth;
} else {
nudge = 2;
}
} else {
nudge = 0;
}
var rotation2;
if (n % 4 == 0) {
rotation2 = -this.rotationInRadians - Math.PI * (0.5 - 1 / n);
} else {
rotation2 = -this.rotationInRadians - Math.PI * (0.5 - 2 / n); //Zero rotation means "pointing upwards"
}
for (var i = 0; i < n; i++) {
var j = i;
currentPolygonVertices = [];
while (pointsDone[j] !== true) {
px = x + r * Math.cos(rotation2 + j * this.exteriorAngle);
py = y + r * Math.sin(rotation2 + j * this.exteriorAngle) + nudge;
currentPoint = new Point(px, py);
currentPolygonVertices.push(currentPoint);
pointsDone[j] = true;
j = (j + star) % n;
}
if (currentPolygonVertices.length > 0) {
this.vertices = this.vertices.concat(currentPolygonVertices);
}
}
if (outlinecolour === undefined) {
this.calculatePolygons(0);
}
}

RegularPolygon.prototype.calculatePolygons = function (lineWidth) {
var separatePolygonsPossiblyNeeded;
if (this.fillcolour !== undefined && this.fillcolour != "transparent" &&
this.outlinecolour !== undefined &&
this.n / this.star != 2
) {
separatePolygonsPossiblyNeeded = true;
} else {
separatePolygonsPossiblyNeeded = false;
}

var radius = this.r - lineWidth / 2;
var rotation;
if (this.n % 4 == 0) {
rotation = -this.rotationInRadians - Math.PI * (0.5 - 1 / this.n);
} else {
rotation = -this.rotationInRadians - Math.PI * (0.5 - 2 / this.n); //Zero rotation means "pointing upwards"
}
var nudge;
if (this.drawingOptions !== undefined && this.drawingOptions.valign == "bottom") {
nudge = lineWidth;
} else {
nudge = 0;
}

var pointsDone = new Array(this.n);
var px, py;
var polygons = [];
var currentPolygonVertices, currentPoint;
for (var i = 0; i < this.n; i++) {
var j = i;
currentPolygonVertices = [];
while (pointsDone[j] !== true) {
px = this.x + radius * Math.cos(rotation + j * this.exteriorAngle);
py = this.y + radius * Math.sin(rotation + j * this.exteriorAngle) + nudge;
currentPoint = new Point(px, py);
currentPolygonVertices.push(currentPoint);
pointsDone[j] = true;
j = (j + this.star) % this.n;
}
if (currentPolygonVertices.length > 0) {
polygons.push(new Polygon(currentPolygonVertices, this.fillcolour, this.outlinecolour, this.drawingOptions));
}
}
if (separatePolygonsPossiblyNeeded) {
if (polygons.length == 1) {
if (!this.interiorOutline) {
/* Case: single constituent polygon (e.g. five-pointed star) with an outline but
* not an outline drawn in inside the shape (i.e. a star or a pentagon rather
* than a pentagram).
* Solution: add extra polygons to over-paint those inside edges that we don't want.
* N.B. We can (and do) safely ignore these extra polygons when performing hit testing.
*/
var smallerRadius = this.r - lineWidth;
currentPolygonVertices = [];
i = 0;
do {
px = this.x + smallerRadius * Math.cos(rotation + i * this.exteriorAngle);
py = this.y + smallerRadius * Math.sin(rotation + i * this.exteriorAngle);
currentPoint = new Point(px, py);
currentPolygonVertices.push(currentPoint);
i = (i + this.star) % this.n;
} while (i != 0);
polygons.push(new Polygon(currentPolygonVertices, this.fillcolour, undefined, this.drawingOptions));
} else {
/* Case: the user wants to see the edges that intersect the interior of the
* polygon.
*/
}
this.filledPolygons = polygons;
this.outlinePolygons = [];
} else {
/* Case: multiple constituent polygons (specifically, more than 2).  Occurs when
* n / star is an integer greater than 2.
* Solution: Paint the fill and the outline as separate polygons.  The requirement
* to show or hide the interior edges determines whether the outlines are painted
* first or the fill is painted first.
*/
this.filledPolygons = [];
this.outlinePolygons = [];
for (var i = 0; i < polygons.length; i++) {
this.filledPolygons.push(new Polygon(polygons[i].vertices, this.fillcolour, undefined, this.drawingOptions));
}
for (var i = 0; i < polygons.length; i++) {
this.outlinePolygons.push(new Polygon(polygons[i].vertices, undefined, this.outlinecolour, this.drawingOptions));
}
}
} else {
/* Case: the outline doesn't have intersecting edges (or only degenerate ones, i.e. n / star = 2),
* or doesn't have an outline, or doesn't have a fill colour.
* N.B: n / star = 2 is the degenerate case when a polygon is reduced to being a set of unconnected lines.
* Solution: One set of polygons that paint either the fill or the outline (the shape doesn't have both).
*/
this.filledPolygons = polygons;
this.outlinePolygons = [];
}
}
}}$;

func RegularPolygon {
${{
var maxArgs = 10;
var numArgs = arguments.length;
var x = arguments[0];
var y = arguments[1];
var r = arguments[2];
var n = arguments[3];
var star = 1, rotation = 0, interiorOutline = true;
var fillcolour, outlinecolour, drawingOptions;
var argsProcessed = 4;
if (typeof(arguments[4]) == "number") {
star = arguments[4];
argsProcessed++;
}
if (numArgs - argsProcessed > maxArgs - 5) { argsProcessed = 5; }

if (typeof(arguments[argsProcessed]) == "boolean") {
interiorOutline = arguments[argsProcessed];
argsProcessed++;
}
if (numArgs - argsProcessed > maxArgs - 6) { argsProcessed = 6; }

if (typeof(arguments[argsProcessed]) == "number") {
rotation = arguments[argsProcessed];
argsProcessed++;
}
if (numArgs - argsProcessed > maxArgs - 7) { argsProcessed = 7; }

var lastArg = arguments[numArgs - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
drawingOptions = lastArg;
processUpTo = numArgs - 2;
} else {
processUpTo = numArgs - 1;
}
if (processUpTo >= argsProcessed) {
fillcolour = arguments[argsProcessed];
argsProcessed++;
if (processUpTo == argsProcessed) {
outlinecolour = arguments[argsProcessed];
}
}

if (outlinecolour === undefined) {
if (fillcolour === undefined) {
outlinecolour = "black";
}
}

if (drawingOptions !== undefined) {
if (!("join" in drawingOptions)) {
drawingOptions.join = "round";
}
}
return new RegularPolygon(x, y, r, n, star, rotation, interiorOutline, fillcolour, outlinecolour, drawingOptions);
}}$;
}
semicircleAngle ~> [RegularPolygon];

${{
RegularPolygon.prototype.draw = function (context) {
var lineWidth = context.lineWidth;
if (!this.interiorOutline) {
lineWidth = lineWidth * 2;
}
if (this.outlinecolour !== undefined) {
if (lineWidth !== this.cachedPolygonLineWidth) {
this.calculatePolygons(lineWidth);
this.cachedPolygonLineWidth = lineWidth;
}
}

if (this.interiorOutline) {
for (var i = 0; i < this.filledPolygons.length; i++) {
this.filledPolygons[i].draw(context);
}
for (var i = 0; i < this.outlinePolygons.length; i++) {
this.outlinePolygons[i].draw(context);
}
} else {
context.lineWidth = lineWidth;
for (var i = 0; i < this.outlinePolygons.length; i++) {
this.outlinePolygons[i].draw(context);
}
context.lineWidth = lineWidth / 2;
for (var i = 0; i < this.filledPolygons.length; i++) {
this.filledPolygons[i].draw(context);
}
}
}

RegularPolygon.prototype.isHit = function (context, scale, x, y) {
var hit;
var ratio = this.n / this.star;
var limit;
if (this.fillcolour !== undefined && this.fillcolour != "transparent" &&
this.outlinecolour !== undefined &&
ratio != 2 &&
(this.star == 1 || ratio != Math.floor(ratio)) &&
!this.interiorOutline
) {
limit = this.filledPolygons.length / 2;
} else {
limit = this.filledPolygons.length;
}
for (var i = 0; i < limit; i++) {
hit = this.filledPolygons[i].isHit(context, scale, x, y);
if (hit) {
return true;
}
}
return false;
};

RegularPolygon.prototype.toString = function () {
var s = "RegularPolygon(" + Eden.edenCodeForValues(this.x, this.y, this.r, this.n, this.star,
this.interiorOutline, this.rotation, this.fillcolour, this.outlinecolour);

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}
s = s + ")";
return s;
}

RegularPolygon.prototype.getEdenCode = RegularPolygon.prototype.toString;

RegularPolygon.prototype.imageMapArea = function () {
return this.filledPolygons[0].imageMapArea();
}

RegularPolygon.prototype.centre = function () {
return new Point(this.x, this.y);
}

}}$;


${{

function Rotation(angle, centre, origin, angle2, radius, items) {
this.angle = angle;
this.centre = centre;
this.origin = origin;
this.angle2 = angle2;
this.radius = radius;
this.items = items;

var radiansPerUnit = Math.PI / root.lookup("semicircleAngle").value();
if (angle2 === undefined) {
this.radians2 = 0;
} else {
this.radians2 = -angle2 * radiansPerUnit;
}
if (angle === undefined) {
this.radians = 0;
} else {
this.radians = -angle * radiansPerUnit - this.radians2;
}
}

Rotation.prototype = new EdenUI.plugins.Canvas2D.Transform();

Rotation.prototype.transform = function (context) {
var origin = this.origin;
var centre = this.centre;
var radius = this.radius;

context.translate(origin.x, origin.y);

if (radius !== undefined) {
context.rotate(this.radians2);
context.translate(radius, 0);
}
context.rotate(this.radians);

if (centre !== undefined) {
context.translate(-centre.x, -centre.y);
}
}

Rotation.prototype.toString = function() {
if (this.radius !== undefined && this.centre !== undefined) {
return "CombinedRotation(" + Eden.edenCodeForValues(this.angle, this.centre, this.origin, this.angle2, this.radius, this.items) + ")";
} else if (this.radius !== undefined) {
return "RotateAboutPoint(" + Eden.edenCodeForValues(this.angle2, this.origin, this.radius, this.items) + ")";
} else {
return "RotateAboutCentre(" + Eden.edenCodeForValues(this.angle, this.centre, this.origin, this.items) + ")";
}
}

Rotation.prototype.getEdenCode = Rotation.prototype.toString;

}}$;

func CombinedRotation {
${{
if (arguments[0] instanceof Folder) {
//Probably not an actual function call but semicircleAngle observable changed.
return undefined;
}

var angle, centre, origin, angle2, radius, items;
angle = arguments[0];
centre = arguments[1];
origin = arguments[2];

if (arguments.length == 6) {
angle2 = arguments[3];
radius = arguments[4];
items = arguments[5];
} else {
angle2 = angle;
radius = arguments[3];
items = arguments[4];
}

if (!(centre instanceof Point)) {
eden.error(new Error("CombinedRotation: The centre of rotation must be a Point, not a " + typeof(centre)), "error");
return undefined;
}
if (!(origin instanceof Point)) {
eden.error(new Error("CombinedRotation: The centre of the circular orbit must be a Point, not a " + typeof(origin)), "error");
return undefined;
}
return new Rotation(angle, centre, origin, angle2, radius, items);
}}$;
}

func RotateAboutCentre {
${{
if (arguments[0] instanceof Folder) {
//Probably not an actual function call but semicircleAngle observable changed.
return undefined;
}

var angle = arguments[0];
var centre = arguments[1];
var origin = arguments[2];
var items = arguments[3];

if (!(centre instanceof Point)) {
eden.error(new Error("RotateAboutCentre: The centre of rotation must be a Point, not a " + typeof(centre)), "error");
return undefined;
}
if (!(origin instanceof Point)) {
eden.error(new Error("RotateAboutCentre: The destination position must be a Point, not a " + typeof(origin)), "error");
return undefined;
}
return new Rotation(angle, centre, origin, 0, undefined, items);
}}$;
}

func RotateAboutPoint {
${{
if (arguments[0] instanceof Folder) {
//Probably not an actual function call but semicircleAngle observable changed.
return undefined;
}

var angle, origin, radius, centre, items;
angle = arguments[0];
origin = arguments[1];
radius = arguments[2];

if (arguments.length == 5) {
centre = arguments[3];
items = arguments[4];
if (!(centre instanceof Point)) {
eden.error(new Error("RotateAboutPoint: The centre point of the source picture must be a Point, not a " + typeof(centre)), "error");
return undefined;
}
} else {
items = arguments[3];
}

if (!(origin instanceof Point)) {
eden.error(new Error("RotateAboutPoint: The centre of the circle must be a Point, not a " + typeof(origin)), "error");
return undefined;
}
return new Rotation(0, centre, origin, angle, radius, items);
}}$;
}

semicircleAngle ~> [CombinedRotation, RotateAboutCentre, RotateAboutPoint];


${{
RoundedRectangle = function(x, y, width, height, radius, fillcolour, outlinecolour, drawingOptions) {
this.x1 = x;
this.y1 = y;
this.x2 = x + width;
this.y2 = y + height;
this.radius = radius;
this.fillcolour = fillcolour;
this.outlinecolour = outlinecolour;
this.drawingOptions = drawingOptions;
this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "RoundedRectangle");
this.obsName = root.currentObservableName();
}
}}$;

func RoundedRectangle { ${{
var x = arguments[0];
var y = arguments[1];
var width = arguments[2];
var height = arguments[3];
var radius = arguments[4];
var fillcolour, outlinecolour, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}
if (processUpTo >= 5) {
fillcolour = arguments[5];
if (processUpTo == 6) {
outlinecolour = arguments[6];
}
}
if (fillcolour === undefined && outlinecolour === undefined) {
outlinecolour = "black";
}
return new RoundedRectangle(x, y, width, height, radius, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

RoundedRectangle.prototype.draw = function (context) {

this.tracePath(context);

if (this.fillcolour !== undefined) {
edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
context.fill();
}
if (this.outlinecolour !== undefined) {
context.strokeStyle = this.outlinecolour;
context.stroke();
}
};

RoundedRectangle.prototype.tracePath = function (context) {
var halfLineWidth;
if (this.outlinecolour !== undefined) {
halfLineWidth = context.lineWidth / 2;
} else {
halfLineWidth = 0;
}
var x1 = this.x1 + halfLineWidth;
var x2 = this.x2 - halfLineWidth;
var y1 = this.y1 + halfLineWidth;
var y2 = this.y2 - halfLineWidth;

context.beginPath();
context.moveTo(x1 + this.radius, y1);
context.lineTo(x2 - this.radius, y1);
context.arcTo(x2, y1, x2, y1 + this.radius, this.radius);
context.lineTo(x2, y2 - this.radius);
context.arcTo(x2, y2, x2 - this.radius, y2, this.radius);
context.lineTo(x1 + this.radius, y2);
context.arcTo(x1, y2, x1, y2 - this.radius, this.radius);
context.lineTo(x1, y1 + this.radius);
context.arcTo(x1, y1, x1 + this.radius, y1, this.radius);
context.closePath();
};

RoundedRectangle.prototype.isHit = function (context, scale, x, y) {
this.tracePath(context);
return context.isPointInPath(x,y);
}

RoundedRectangle.prototype.toString = function() {
var s = "RoundedRectangle(" + Eden.edenCodeForValues(this.x1, this.y1) + ", ";

if (this.x2 === undefined || this.x1 === undefined) {
s = s + "@, ";
} else {
s = s + String(this.x2 - this.x1) + ", ";
}
if (this.y2 === undefined || this.y1 === undefined) {
s = s + "@, ";
} else {
s = s + String(this.y2 - this.y1) + ", ";
}
s = s + Eden.edenCodeForValues(this.radius, this.fillcolour, this.outlinecolour);

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
};

RoundedRectangle.prototype.getEdenCode = RoundedRectangle.prototype.toString;

}}$;


${{

function Scaling(scaleX, scaleY, centreX, centreY, translateX, translateY, items) {
this.scaleX = scaleX;
this.scaleY = scaleY;
this.centreX = centreX;
this.centreY = centreY;
this.translateX = translateX;
this.translateY = translateY;
this.items = items;
}

Scaling.prototype = new EdenUI.plugins.Canvas2D.Transform;

Scaling.prototype.transform = function (context) {
var translateX = this.translateX;
if (translateX) {
context.translate(translateX, this.translateY);
}

context.scale(this.scaleX, this.scaleY);

var centreX = this.centreX;
if (centreX) {
context.translate(-centreX, -this.centreY);
}
}

Scaling.prototype.toString = function () {
return "Scale(" + Eden.edenCodeForValues(this.scaleX, this.scaleY, centreX, centreY, this.translateX, this.translateY, this.items) + ")";
}

Scaling.prototype.getEdenCode = Scaling.prototype.toString;

}}$;

func Scale {
${{
var scaleX, scaleY, centreX, centreY, translateX, translateY, items;

var argNum = arguments.length - 1;
var arg;

items = arguments[argNum];
argNum--;
if (argNum > 0) {
arg = arguments[argNum];
if (arg instanceof Point) {
translateX = arg.x;
translateY = arg.y;
argNum--;
} else if (argNum >= 2) {
translateY = arg;
argNum--;
translateX = arguments[argNum];
argNum--;
}
if (argNum > 0) {
arg = arguments[argNum];
if (arg instanceof Point) {
centreX = arg.x;
centreY = arg.y;
argNum--;
} else if (argNum >= 2) {
centreY = arg;
argNum--;
centreX = arguments[argNum];
argNum--;
}
}
if (argNum == 1) {
scaleY = arguments[argNum];
} else if (argNum > 0) {
eden.error(new Error("Scale: invalid parameters."), "error");
return undefined;
}
}

scaleX = arguments[0];
if (scaleY === undefined) {
scaleY = scaleX;
}

return new Scaling(scaleX, scaleY, centreX, centreY, translateX, translateY, items);
}}$;
}


${{
Sector = function(x, y, r, sAngle, eAngle, unitsInCircle, fillcolour, outlinecolour,drawingOptions) {
this.x = x;
this.y = y;
this.r = r;
this.sAngle = sAngle;
this.eAngle = eAngle;
this.unitsInCircle = unitsInCircle;
var radiansPerUnit;
if (unitsInCircle === undefined) {
radiansPerUnit = Math.PI / root.lookup("semicircleAngle").value();
} else {
radiansPerUnit = (2 * Math.PI) / unitsInCircle;
}
this.sRadians = sAngle * radiansPerUnit;
this.eRadians = eAngle * radiansPerUnit;

this.fillcolour = fillcolour;
this.outlinecolour = outlinecolour;
this.drawingOptions = drawingOptions;
this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Sector");
this.obsName = root.currentObservableName();
}
}}$;

func Sector { ${{
var x = arguments[0];
var y = arguments[1];
var r = arguments[2];
var sAngle = arguments[3];
var eAngle = arguments[4];
var unitsInCircle, fillcolour, outlinecolour, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}

var argsProcessed = 5;
if (typeof(arguments[argsProcessed]) == "number") {
unitsInCircle = arguments[argsProcessed];
argsProcessed++;
}
if (argsProcessed <= processUpTo) {
fillcolour = arguments[argsProcessed];
argsProcessed++;
}
if (argsProcessed <= processUpTo) {
outlinecolour = arguments[argsProcessed];
}
if (fillcolour === undefined && outlinecolour === undefined) {
outlinecolour = "black";
}
return new Sector(x, y, r, sAngle, eAngle, unitsInCircle, fillcolour, outlinecolour, drawingOptions);
}}$; };
semicircleAngle ~> [Sector];

${{

Sector.prototype.draw = function (context) {

this.tracePath(context);

if (this.fillcolour !== undefined) {
edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
context.fill();
}
if (this.outlinecolour !== undefined) {
context.strokeStyle = this.outlinecolour;
context.stroke();
}
};

Sector.prototype.tracePath = function (context) {
var anticlockwise;
if (this.drawingOptions !== undefined && "direction" in this.drawingOptions) {
switch (this.drawingOptions.direction) {
case "anticlockwise":
case "acw":
case "ccw":
anticlockwise = true;
break;
case "auto":
anticlockwise = this.sAngle < this.eAngle;
break;
case "clockwise":
case "cw":
anticlockwise = false;
break;
default:
//Invalid value specified.
anticlockwise = true;
}
} else {
//Default to "auto"
anticlockwise = this.sAngle < this.eAngle;
}

var radius;
if (this.outlinecolour === undefined) {
radius = this.r;
} else if (this.drawingOptions !== undefined && this.drawingOptions.lineWidth % 2 == 1) {
var scale = this.drawingOptions.lineWidth / context.lineWidth;
context.translate(0.5 / scale, 0.5 / scale);
radius = this.r - 0.5 * context.lineWidth + 0.5 / scale;
} else {
radius = this.r - 0.5 * context.lineWidth;
}

context.beginPath();
context.arc(this.x, this.y, radius, -this.sRadians, -this.eRadians, anticlockwise);
context.lineTo(this.x, this.y);
context.closePath();
};

Sector.prototype.isHit = function (context, scale, x, y) {
this.tracePath(context);
return context.isPointInPath(x,y);
}

Sector.prototype.toString = function() {
var s = "Sector(" + Eden.edenCodeForValues(this.x, this.y, this.r, this.sAngle, this.eAngle,
this.unitsInCircle, this.fillcolour, this.outlinecolour);

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
}

Sector.prototype.getEdenCode = Sector.prototype.toString;

}}$;


func Shadow {
${{
var colour, blur, xOffset, yOffset, scale;

var processUpTo;
var numArgs = arguments.length;
var lastArg = arguments[numArgs - 1];
if (lastArg === true || lastArg === false || numArgs == 5) {
scale = lastArg;
processUpTo = numArgs - 1;
} else {
processUpTo = numArgs;
}

var argsProcessed;
if (typeof(arguments[0]) == "string" || (arguments[0] === undefined && processUpTo > 3)) {
colour = arguments[0];
argsProcessed = 1;
} else {
argsProcessed = 0;
}
if (colour == undefined) {
colour = "black";
}

xOffset = arguments[argsProcessed];
argsProcessed++;
yOffset = arguments[argsProcessed];
argsProcessed++;
blur = arguments[argsProcessed];
return new Shadow(colour, xOffset, yOffset, blur, scale);
}}$;
}

${{
function Shadow(colour, xOffset, yOffset, blur, scale) {
this.colour = colour;
this.blur = blur;
this.xOffset = xOffset;
this.yOffset = yOffset;
this.scale = scale;
}

Shadow.prototype.toString = function() {
return "Shadow(" + Eden.edenCodeForValues(this.colour, this.xOffset, this.yOffset, this.blur, this.scale) + ")";
}

Shadow.prototype.getEdenCode = Shadow.prototype.toString;

}}$;


${{
Textbox = function (name, x, y, width, height, placeholder, maxlength, enabled) {
this.name = name;
this.obsName = root.currentObservableName();
this.x = x;
this.y = y;
this.width = width;
this.height = height;
this.placeholder = placeholder;
this.maxlength = maxlength;
this.enabled = enabled;
}

Textbox.prototype.hash = function () {
return this.name+"$$"+
this.x+"$$"+
this.y+"$$"+
this.width+"$$"+
this.height+"$$"+
this.placeholder+"$$"+
this.maxlength+"$$"+
this.enabled;
};
}}$;

func Textbox { ${{
var argsProcesssed;

var name;
if (typeof(arguments[0]) == "string") {
name = arguments[0];
argsProcessed = 1;
} else {
name = root.currentObservableName();
argsProcessed = 0;
if (name === undefined) {
eden.error(new Error("Textbox: Every text box must have a name."), "error");
return undefined;
}
}

var x = arguments[argsProcessed];
argsProcessed++;
var y = arguments[argsProcessed];
argsProcessed++;
var width = arguments[argsProcessed];
argsProcessed++;

var height, placeholder, maxlength, enabled;
var arg = arguments[argsProcessed];
var argType = typeof(arg);
if (arg === undefined || argType == "number") {
height = arg;
argsProcessed++;
arg = arguments[argsProcessed];
argType = typeof(arg);
}
if (arg === undefined || argType == "string") {
placeholder = arg;
argsProcessed++;
arg = arguments[argsProcessed];
argType = typeof(arg);
}
if (arg === undefined || argType == "number") {
maxlength = arg;
argsProcessed++;
arg = arguments[argsProcessed];
}
enabled = arg;
return new Textbox(name, x, y, width, height, placeholder, maxlength, enabled);
}}$; }

${{
Textbox.prototype.draw = function(context) {

if(this.elements === undefined) {
var me = this;
var name = this.name;

var disabled = this.enabled === false? 'disabled="disabled"' : '';
var placeholder;
var maxlength = this.maxlength !== undefined? ' maxlength="' + this.maxlength + '"' : '';
var jQuery;
if (this.height === undefined) {
placeholder = ' placeholder="' +
(this.placeholder === undefined? name : this.placeholder) + '"';
jQuery = $('<input type="text" ' + disabled + placeholder + maxlength + ' style="position: absolute" />');
} else {
// Placeholder text for textarea tag is buggy in IE11, so don't use it by default.
placeholder = this.placeholder !== undefined && this.placeholder != ""?
' placeholder="' + this.placeholder + '"' :
'';
jQuery = $('<textarea ' + disabled + placeholder + maxlength + ' style="position: absolute"></textarea>');
}

var element = jQuery.get(0);
var valueSymbol = root.lookup(name + "_value");
var value = valueSymbol.value();
if (value === undefined) {
valueSymbol.assign("", root.scope, root.lookup("Textbox"));
} else {
element.value = value;
}
valueSymbol.addJSObserver("updateTextbox", function (obs, value) {
me.elements[0].value = value;
});

jQuery
.on("input", function(event) {
root.lookup(name + "_value").assign(event.target.value, root.scope, Symbol.hciAgent, true);
})
.on("mousedown", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(undefined, root.scope, Symbol.hciAgent, mouseFollow);
})
.on("mouseup", function () {
edenUI.plugins.Canvas2D.endClick();
})
.on("mouseenter", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
});

this.elements = [element];
}
};

Textbox.prototype.scale = function (scale, zoom, origin) {
var style = this.elements[0].style;
style.left = Math.round(this.x * scale + origin.x) + "px";
style.top = Math.round(this.y * scale + origin.y) + "px";
style.width = Math.round(this.width * scale - 6) + "px";
if (this.height !== undefined) {
var lineHeight = edenUI.plugins.Canvas2D.defaultLineHeight;
var rows = Math.floor(Math.round(this.height * scale - 4) / (lineHeight * zoom));	//See css/eden.css
if (rows == 0) {
rows = 1;
}
style.height = (rows * lineHeight * zoom) + "px";
}
style.fontSize = (edenUI.plugins.Canvas2D.defaultFontSizePx * zoom) + "px";
};

Textbox.prototype.toString = function() {
if (this.name == this.obsName) {
return "Textbox(" + Eden.edenCodeForValues(this.x, this.y, this.width,
this.height, this.placeholder, this.enabled) + ")";
} else {
return "Textbox(" + Eden.edenCodeForValues(this.name, this.x, this.y, this.width,
this.height, this.placeholder, this.enabled) + ")";
}
};

Textbox.prototype.getEdenCode = Textbox.prototype.toString;

}}$;


${{

function Translation(centreX, centreY, x, y, items) {
this.centreX = centreX;
this.centreY = centreY;
this.x = x;
this.y = y;
this.items = items;
}

Translation.prototype = new EdenUI.plugins.Canvas2D.Transform;

Translation.prototype.transform = function (context) {
context.translate(this.x - this.centreX, this.y - this.centreY);
}

Translation.prototype.toString = function () {
return "Translate(" + Eden.edenCodeForValues(this.centreX, this.centreY, this.x, this.y, this.items) + ")";
}

Translation.prototype.getEdenCode = Translation.prototype.toString;

}}$;

func Translate {
${{
var centreX, centreY, x, y, items;
var argNum = arguments.length - 1;
if (argNum == 0) {
eden.error(new Error("Translate: This function requires at least 2 arguments."), "error");
return undefined;
}
items = arguments[argNum];
argNum--;
arg = arguments[argNum];
if (arg instanceof Point) {
x = arg.x;
y = arg.y;
argNum--;
} else if (argNum >= 1) {
y = arg;
argNum--;
x = arguments[argNum];
argNum--;
}
if (argNum >= 0) {
arg = arguments[argNum];
if (arg instanceof Point) {
centreX = arg.x;
centreY = arg.y;
argNum--;
} else if (argNum >= 1) {
centreY = arg;
argNum--;
centreX = arguments[argNum];
argNum--;
}
}
if (argNum >= 0) {
eden.error(new Error("Translate: invalid parameters."), "error");
return undefined;
}

if (typeof(x) !== "number") {
eden.error(new Error("Translate: The destination X coordinate must be a number, not a " + typeof(x)), "error");
return undefined;
}
if (typeof(y) !== "number") {
eden.error(new Error("Translate: The destination Y coordinate must be a number, not a " + typeof(y)), "error");
return undefined;
}
if (centreX === undefined) {
centreX = 0;
}
if (centreY === undefined) {
centreY = 0;
}
return new Translation(centreX, centreY, x, y, items);
}}$;
}




/*
vid_url = "...";
vid is Video();
picture is [vid];

exercisePoints = [60];
exercisesCompleted = [false];
exerciseNumber is positionInList(vid_time, exercisePoints);
vid_controls is exerciseNumber == 0 || exercisesCompleted[exerciseNumber];
vid_paused is vid_controls == false;
*/

func Video {
${{
var argsProcessed;

var name;
if (typeof(arguments[0]) == "string") {
name = arguments[0];
argsProcessed = 1;
} else {
name = root.currentObservableName();
argsProcessed = 0;
if (name === undefined) {
eden.error(new Error("Video: Every video must have a name."), "error");
return undefined;
}
}
var preload;
if (argsProcessed < arguments.length) {
preload = arguments[argsProcessed];
} else {
preload = false;
}
return new Audiovisual(name, "Video", preload);
}}$;
}

func Audio {
${{
var argsProcessed;

var name;
if (typeof(arguments[0]) == "string") {
name = arguments[0];
argsProcessed = 1;
} else {
name = root.currentObservableName();
argsProcessed = 0;
if (name === undefined) {
eden.error(new Error("Audio: Every audio player must have a name."), "error");
return undefined;
}
}
var preload;
if (argsProcessed < arguments.length) {
preload = arguments[argsProcessed];
} else {
preload = false;
}
return new Audiovisual(name, "Audio", preload);
}}$;
}

${{
function Audiovisual(name, type, preload) {
this.name = name;
this.obsName = root.currentObservableName();
this.type = type;
this.preload = preload;
this.atEnd = false;

Object.defineProperty(this, "duration", {
enumerable: true,
get: function () {
if (this.elements === undefined || !this.elements[0].duration) {
return 0;
} else {
return this.elements[0].duration;
}
}
});
}

Audiovisual.prototype.hash = function () {
return this.name;
}

function getMediaElement(audiovisual) {
return audiovisual.elements[0];
}

function loadMedia(audiovisual) {
var mediaElement = getMediaElement(audiovisual);
mediaElement.autoplay = !root.lookup(audiovisual.name + "_paused").value();
if (audiovisual.preload) {
mediaElement.preload = "auto";
} else {
mediaElement.preload = "metadata";
}
mediaElement.load();
}

Audiovisual.prototype.reload = function () {
var mediaElement = getMediaElement(this);
var position = mediaElement.currentTime;
loadMedia(this);
mediaElement.currentTime = position;
};

Audiovisual.prototype.unmute = function () {
getMediaElement(this).muted = false;
}

Audiovisual.prototype.draw = function (context) {
if (this.elements === undefined ) {
var me = this;
var name = this.name;
var agent = root.lookup(this.type);
root.beginAutocalcOff();

//Create HTML tag

var mediaElement = document.createElement(this.type.toLowerCase());


//Symbols not unique to videos

var chapterSym = root.lookup(name + "_chapter");
var chapterMarksSym = root.lookup(name + "_chapters");
var loopSym = root.lookup(name + "_looping");
var pausedSym = root.lookup(name + "_paused");
var positionSym = root.lookup(name + "_position");
var speedSym = root.lookup(name + "_speed");
var timeSym = root.lookup(name + "_time");
var urlSym = root.lookup(name + "_url");
var volumeSym = root.lookup(name + "_volume");


//Chapters

var chapterMarks, chapterNames, chapterIndex, nextChapterAt;
var goToChapter = function () {
var numChapters = chapterMarks.length;
if (chapterIndex == -1) {
if (numChapters > 0 && chapterMarks[0] == 0) {
chapterIndex = 0;
}
}
var chapterName;
if (chapterIndex == -1) {
chapterName = "start";
} else if (chapterIndex == numChapters) {
chapterName = "end";
me.atEnd = true;
} else {
chapterName = chapterNames[chapterIndex];
}
if (chapterName != chapterSym.value()) {
chapterSym.assign(chapterName, root.scope, agent);
}
if (chapterIndex < numChapters - 1) {
nextChapterAt = chapterMarks[chapterIndex + 1];
} else {
nextChapterAt = undefined;
}
};
var setChapters = function (symbol, chapters) {
chapterMarks = [];
chapterNames = [];
chapterIndex = -1;
nextChapterAt = undefined;

if (chapters instanceof Object) {
for (var chapterName in chapters) {
var beginsAt = chapters[chapterName];
var i = 0;
while (i < chapterMarks.length) {
if (beginsAt < chapterMarks[i]) {
break;
}
i++;
}
chapterMarks.splice(i, 0, beginsAt);
chapterNames.splice(i, 0, chapterName);
}

if (!me.atEnd) {
var currentPos = timeSym.value();
while (chapterIndex < chapterMarks.length - 1 &&
currentPos >= chapterMarks[chapterIndex + 1]) {
chapterIndex++;
}
goToChapter();
}
}
}; //end of function
if (chapterMarksSym.value() === undefined && chapterMarksSym.definition === undefined) {
chapterMarksSym.assign({}, root.scope, agent);
}
setChapters(chapterMarksSym, chapterMarksSym.value());
chapterMarksSym.addJSObserver("setChapters", setChapters);

chapterSym.addJSObserver("jumpToChapter", function (symbol, value) {
var currentTime = mediaElement.currentTime;
var numChapters = chapterMarks.length;
var newTime;
if (value == "start") {
chapterIndex = -1;
newTime = 0;
} else if (value == "end") {
chapterIndex = numChapters;
newTime = mediaElement.duration;
} else {
var found = false;
for (var i = 0; i < numChapters; i++) {
if (value == chapterNames[i]) {
chapterIndex = i;
newTime = chapterMarks[chapterIndex];
break;
}
}
}
if (newTime !== undefined) {
timeSym.assign(newTime, root.scope, agent);
mediaElement.currentTime = newTime;
goToChapter();
}
});

//Looping

var initialLooping = loopSym.value();
if (initialLooping === undefined && loopSym.definition === undefined) {
loopSym.assign(false, root.scope, agent);
} else if (initialLooping) {
mediaElement.loop = true;
}
loopSym.addJSObserver("setLooping", function (sym, value) {
mediaElement.loop = value;
});


//Playback controls

if (this.type == "Video") {

var controlsSym = root.lookup(name + "_controls");
var controls = controlsSym.value();
if (controls === undefined) {
if (controlsSym.definition === undefined) {
controlsSym.assign(true, root.scope, agent);
} else {
mediaElement.controls = true;
}
} else {
mediaElement.controls = controls;
}
controlsSym.addJSObserver("showHideControls", function (symbol, showControls) {
mediaElement.controls = showControls;
});
} else {
mediaElement.controls = true;
}


//Position on screen

mediaElement.style.position = "absolute";
this.cachedOrigin = new Point(0, 0);
this.cachedScaleFactor = 1;
var position = positionSym.value();
if (position === undefined) {
position = new Point(0, 0);
positionSym.assign(position, root.scope, agent);
}
positionSym.addJSObserver("reposition", function (sym, position) {
me.doTranslation(position);
});


//Size

this.cachedZoom = 1;
if (this.type == "Video") {
var sizeSym = root.lookup(name + "_size");
var scaleSym = root.lookup(name + "_scale");
var size = sizeSym.value();
sizeSym.addJSObserver("resize", function (symbol, size) {
var scale = scaleSym.value();
if (scale !== undefined) {
me.doScaling(size, scale);
}
});
scaleSym.addJSObserver("resize", function (symbol, scale) {
if (scale !== undefined) {
me.doScaling(sizeSym.value(), scale);
}
});
mediaElement.addEventListener("loadedmetadata", function (event) {
if (sizeSym.value() === undefined) {
root.beginAutocalcOff();
scaleSym.assign(1, root.scope, agent);
sizeSym.assign(new Point(mediaElement.videoWidth, root.scope, mediaElement.videoHeight), agent);
root.endAutocalcOff();
}
});

} else {

}


//Paused or playing

var beginPaused = pausedSym.value();
if (beginPaused === undefined && pausedSym.definition === undefined) {
pausedSym.assign(true, root.scope, agent);
} else if (beginPaused == false) {
mediaElement.autoplay = true;
}
pausedSym.addJSObserver("pausePlay", function (symbol, pause) {
if (pause) {
mediaElement.pause();
} else {
me.atEnd = false;
mediaElement.play();
}
});
mediaElement.addEventListener("pause", function (event) {
if (pausedSym.definition === undefined) {
pausedSym.assign(true, root.scope, agent);
}
});
mediaElement.addEventListener("playing", function (event) {
if (pausedSym.definition === undefined) {
pausedSym.assign(false, root.scope, agent);
}
if (speedSym.value() == 0) {
mediaElement.defaultPlaybackRate = 1;
mediaElement.playbackRate = 1;
}
});


//Seeking and time moving forward

var time = timeSym.value();
if (time !== undefined) {
mediaElement.currentTime = parseFloat(time);
} else if (timeSym.definition === undefined) {
timeSym.assign(0, root.scope, agent);
}

function findChapter() {
var oldChapterIndex  = chapterIndex;
var numChapters = chapterMarks.length;
if (me.atEnd) {
//Seeked to the end (and not looping)
chapterIndex = numChapters;
} else {
var currentTime = mediaElement.currentTime;
if (nextChapterAt !== undefined && currentTime >= nextChapterAt) {
//Seeking forward
while (chapterIndex < numChapters - 1 && currentTime >= chapterMarks[chapterIndex + 1]) {
chapterIndex++;
}
} else {
//Seeking backward
if (chapterIndex == numChapters) {
chapterIndex--;
}
while (chapterIndex >= 0 && chapterMarks[chapterIndex] > currentTime) {
chapterIndex--;
}
}
}

if (chapterIndex != oldChapterIndex) {
goToChapter();
}
}

timeSym.addJSObserver("seek", function (symbol, seconds) {
if (symbol.last_modified_by !== me.type) {
mediaElement.currentTime = seconds;
}
});
mediaElement.addEventListener("timeupdate", function (event) {
if (mediaElement.paused) {
return;
}
var currentTime = mediaElement.currentTime;
var newTimeIndex = Math.floor(currentTime);
if (newTimeIndex != me.timeIndex) {
timeSym.assign(newTimeIndex, root.scope, agent);
me.timeIndex = newTimeIndex;
}
if (nextChapterAt !== undefined && currentTime >= nextChapterAt) {
chapterIndex++;
chapterSym.assign(chapterNames[chapterIndex], root.scope, agent);
if (chapterIndex < chapterMarks.length - 1) {
nextChapterAt = chapterMarks[chapterIndex]
} else {
nextChapterAt = undefined;
}
}
});
mediaElement.addEventListener("ended", function (event) {
timeSym.assign(mediaElement.duration, root.scope, agent);
chapterIndex = chapterMarks.length;
goToChapter();
});
mediaElement.addEventListener("seeking", function (event) {
var currentTime = mediaElement.currentTime;
if (timeSym.value() !== currentTime) {
timeSym.assign(currentTime, root.scope, agent);
}
me.atEnd = currentTime == mediaElement.duration;
findChapter();
});
mediaElement.addEventListener("seeked", function (event) {
var isPaused = pausedSym.value();
me.timeIndex = Math.floor(mediaElement.currentTime);
if (!isPaused) {
mediaElement.play();
}
});


//Playback speed

var speedResetOnLoad;
var speed = speedSym.value();
if (speed === undefined) {
speedSym.assign(1, root.scope, agent);
} else if (speed > 0) {
mediaElement.defaultPlaybackRate = speed;
}
speedSym.addJSObserver("changePlaybackSpeed", function (symbol, speed) {
if (mediaElement.playbackRate != speed) {
if (speed > 0) {
mediaElement.defaultPlaybackRate = speed;
} else {
mediaElement.defaultPlaybackRate = 1;
}
mediaElement.playbackRate = speed;
}
});
mediaElement.addEventListener("ratechange", function (event) {
root.beginAutocalcOff();
var speed = mediaElement.playbackRate;
if (speedSym.definition === undefined) {
speedSym.assign(speed, root.scope, agent);
}
if (speed == 0) {
mediaElement.pause();
} else if (!pausedSym.value()) {
mediaElement.play();
}
root.endAutocalcOff();
});


//Volume

var volume = volumeSym.value();
if (volume === undefined) {
volumeSym.assign(1, root.scope, agent);
} else if (volume == 0) {
mediaElement.muted = true;
} else {
mediaElement.volume = volume;
}
this.volumeChanging = false;
volumeSym.addJSObserver("adjustVolume", function (symbol, volume) {
if (!me.volumeChanging) {
me.volumeChanging = true;
if (symbol.definition === undefined) {
if (volume == 0) {
mediaElement.muted = true;
} else {
mediaElement.muted = false;
mediaElement.volume = volume;
}
} else {
mediaElement.volume = volume;
}
me.volumeChanging = false;
}

});
mediaElement.addEventListener("volumechange", function (event) {
if (!me.volumeChanging) {
me.volumeChanging = true;
var oldVolume = volumeSym.value();
var newVolume = mediaElement.volume;
if (mediaElement.muted) {
if (volumeSym.definition === undefined) {
volumeSym.assign(0, root.scope, agent);
}
} else if (oldVolume != newVolume) {
if (volumeSym.definition === undefined) {
volumeSym.assign(newVolume, root.scope, agent);
} else {
mediaElement.volume = oldVolume;
}
}
me.volumeChanging = false;
}
});

//Loading a video file

var url = urlSym.value();
if (url !== undefined) {
if (this.preload) {
mediaElement.preload  = "auto";
} else {
mediaElement.preload = "metadata";
}
mediaElement.src = url;
}
urlSym.addJSObserver("newVideo", function (symbol, url) {
if (url != mediaElement.src) {
timeSym.assign(0, root.scope, agent);
me.timeIndex = 0;
chapterIndex = -1;
goToChapter();
mediaElement.src = url;
loadMedia(me);
}
});


//Mouse Zones

if (this.type == "Video") {
mediaElement.onmousedown = function (event) {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(me.name, root.scope, Symbol.hciAgent, mouseFollow);
};
mediaElement.onmouseup = function (event) {
edenUI.plugins.Canvas2D.endClick();
};
edenUI.plugins.Canvas2D.initZoneFromName(this.name, this.type)
}
mediaElement.onmouseenter = function (event) {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(me.name, root.scope, Symbol.hciAgent, mouseFollow);
};


//Finalize creation

this.elements = [mediaElement];
root.endAutocalcOff();
}
}

Audiovisual.prototype.scale = function (scale, zoom , origin) {
this.cachedScaleFactor = scale;
this.cachedOrigin = origin;

var name = this.name;
var position = root.lookup(name + "_position").value();
this.doTranslation(position);

if (this.type == "Video") {
this.cachedZoom = zoom;
var scaleSym = root.lookup(name + "_scale");
var videoScale = scaleSym.value();

if (videoScale === undefined) {
videoScale = scale / zoom;
scaleSym.assign(videoScale, root.scope, root.lookup(this.type));
} else {
var size = root.lookup(name + "_size").value();
this.doScaling(size, videoScale);
}
}
}

Audiovisual.prototype.doScaling = function (size, scale) {
if (size instanceof Point) {
var element = this.elements[0];
var scaleFactor = this.cachedZoom * scale;
element.width = size.x * scaleFactor;
element.height = size.y * scaleFactor;
}
}

Audiovisual.prototype.doTranslation = function (position) {
if (position instanceof Point) {
var style = this.elements[0].style;
var origin = this.cachedOrigin;
var scaleFactor = this.cachedScaleFactor;
style.left = (origin.x + position.x * scaleFactor) + "px";
style.top = (origin.y + position.y * scaleFactor) + "px";
}
}

Audiovisual.prototype.toString = function () {
if (this.name == this.obsName) {
return this.type + "(" + Eden.edenCodeForValues(this.preload) + ")";
} else {
return this.type + "(" + Eden.edenCodeForValues(this.name, this.preload) + ")";
}
}

Audiovisual.prototype.getEdenCode = Audiovisual.prototype.toString;

//Create an observable for background sounds.
var backgroundAudioSym = root.lookup("background_audio");
var backgroundAudioPausedSym = root.lookup("background_audio_paused");
if (backgroundAudioPausedSym.value() === undefined && backgroundAudioPausedSym.definition === undefined) {
backgroundAudioPausedSym.assign(false, root.scope);
}
var backgroundAudio = new Audiovisual("background_audio", "Audio", true);
backgroundAudioSym.assign(backgroundAudio, root.scope);
backgroundAudio.draw();
backgroundAudioSym.addJSObserver("initialize", function (sym, value) {
if (value instanceof Audiovisual) {
value.draw();
}
});

}}$;

