
mouseButton = "";
mouseButtons = "";
mouseCapture = false;
mouseCaptured = false;
mouseContextMenuEnabled = false;
mouseDoubleClicks = 0;
mouseDown = @;
mouseDownWindow = @;
mouseDownZone = @;
mouseFollow = false;
mousePosition = @;
mousePressed = false;
mouseUp = @;
mouseWheel = 0;
mouseWheelEnabled = false;
mouseWheelSpeed = 0;
mouseWindow = @;
mouseX is mousePosition == @? @ : mousePosition.x;
mouseY is mousePosition == @? @ : mousePosition.y;
mouseZone = @;
px is 1 / _view_picture_scale;
touchPanX = 0;
touchPanXSpeed = 0;
touchPinch = 0;
touchPinchEnabled = false;


${{
root.lookup("mouseCapture").addJSObserver("releaseCapture", function (obs, lock) {
if (!lock) {
document.exitPointerLock();
}
});
}}$;

proc attemptMouseCapture {
${{
var canvasName = root.lookup("mouseWindow").value();
if (canvasName !== undefined) {
canvases[canvasName].requestPointerLock();
}
}}$;
}

proc createCanvas {
auto obsName, viewTitle, viewName, initPicture;
if ($# == 1) {
obsName = $[1];
} else if ($# == 2) {
obsName = $[1];
viewTitle = $[2];
} else if ($# == 3) {
viewName = $[1];
obsName = $[2];
viewTitle = $[3];
if (!isString(viewName)) {
error("createCanvas: The first argument must be a string, not a " // type(viewName));
return;
}
} else {
error("createCanvas: This procedure requires at least 1 argument and at most 2 arguments.");
return;
}

if (isPointer(obsName)) {
obsName = nameof(obsName);
} else if (!isString(obsName)) {
error("createCanvas: The observable name must be expressed as a string or a pointer, not a " // type(obsName));
return;
}
if (viewName == @) {
viewName = obsName;
}
if (viewTitle == @) {
viewTitle = uppercase(substr(viewName, 1, 1)) // substr(viewName, 2);
} else if (!isString(viewTitle)) {
error("createCanvas: The window title must be a string, not a " // type(viewTitle));
return;
}

if (`obsName` == @) {
`obsName` = [];
}

initPicture = ${{ function (viewName, obsName) {
edenUI.plugins.Canvas2D.setPictureObs(viewName, obsName);
edenUI.plugins.Canvas2D.drawPicture(viewName, obsName);
} }}$;

createView(viewName, "Canvas2D", obsName);
initPicture(viewName, obsName);
`"_view_" // viewName // "_title"` = viewTitle;
}

func canvasURL {
${{
var canvasName;
if (arguments.length > 1) {
eden.error(new Error("canvasURL: This function requires at most one argument."), "error");
return "";
} else if (arguments.length == 0) {
canvasName = "picture";
} else {
canvasName = arguments[0];
if (canvasName === undefined) {
return "";
} else if (typeof(canvasName) == "string") {
if (!(canvasName in canvases)) {
return "";
}
} else {
eden.error(new Error("canvasURL: The first argument must be a string, not a " + typeof(canvasName)), "error");
return "";
}
}

return canvases[canvasName].toDataURL();
}}$;
}

func shapeOnTopAt {
${{
var target = arguments[0];
var x, y, testAll;
if (arguments.length < 2 || arguments.length > 4) {
eden.error(new Error("shapeOnTopAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
return undefined;
}
if (arguments[1] instanceof Point) {
x = arguments[1].x;
y = arguments[1].y;
testAll = arguments[2];
} else {
x = arguments[1];
y = arguments[2];
testAll = arguments[3];
}

if (target === undefined || x === undefined || y === undefined) {
return undefined;
} else if (!(target instanceof Symbol) && typeof(target) != "string") {
eden.error(new Error("shapeOnTopAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");
return undefined;
} else if (typeof(x) != "number") {
eden.error(new Error("shapeOnTopAt: The x-coordinate must be a number, not a " + typeof(x)), "error");
return undefined;
} else if (typeof(y) != "number") {
eden.error(new Error("shapeOnTopAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
return undefined;
}
return edenUI.plugins.Canvas2D.findDrawableHit2(target, x, y, false, testAll);
}}$;
}

func shapeOnBottomAt {
${{
var target = arguments[0];
var x, y, testAll;
if (arguments.length < 2 || arguments.length > 4) {
eden.error(new Error("shapeOnBottomAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
return undefined;
}
if (arguments[1] instanceof Point) {
x = arguments[1].x;
y = arguments[1].y;
testAll = arguments[2];
} else {
x = arguments[1];
y = arguments[2];
testAll = arguments[3];
}

if (target === undefined || x === undefined || y === undefined) {
return undefined;
} else if (!(target instanceof Symbol) && typeof(target) != "string") {
eden.error(new Error("shapeOnBottomAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");
return undefined;
} else if (typeof(x) != "number") {
eden.error(new Error("shapeOnBottomAt: The x-coordinate must be a number, not a " + typeof(x)), "error");
return undefined;
} else if (typeof(y) != "number") {
eden.error(new Error("shapeOnBottomAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
return undefined;
}
return edenUI.plugins.Canvas2D.findDrawableHit2(target, x, y, true, testAll);
}}$;
}

func zoneOnTopAt {
auto drawable;
drawable = apply(shapeOnTopAt, $);
if (drawable == @) {
return @;
} else {
return drawable.name;
}
}

func zoneOnBottomAt {
auto drawable;
drawable = apply(shapeOnBottomAt, $);
if (drawable == @) {
return @;
} else {
return drawable.name;
}
}

func observableForShape {
${{
var drawable = arguments[0];
if (drawable === undefined) {
return undefined;
} else if ("obsName" in drawable) {
return drawable.obsName;
} else {
return drawable.name;
}
}}$;
}

func observableOnTopAt {
auto drawable;
drawable = apply(shapeOnTopAt, $);
return observableForShape(drawable);
}

func observableOnBottomAt {
auto drawable;
drawable = apply(shapeOnBottomAt, $);
return observableForShape(drawable);
}

func shapesAt {
${{
var target = arguments[0];
var x, y, testAll;
if (arguments.length < 2 || arguments.length > 4) {
eden.error(new Error("shapesAt: This function requires at least 2 arguments and at most 4 arguments."), "error");
return undefined;
}
if (arguments[1] instanceof Point) {
x = arguments[1].x;
y = arguments[1].y;
testAll = arguments[2];
} else {
x = arguments[1];
y = arguments[2];
testAll = arguments[3];
}

if (target === undefined || x === undefined || y === undefined) {
return undefined;
} else if (!(target instanceof Symbol) && typeof(target) != "string") {
eden.error(new Error("shapesAt: The first argument must be either a string or a pointer, not a " + typeof(target)), "error");
return undefined;
} else if (typeof(x) != "number") {
eden.error(new Error("shapesAt: The x-coordinate must be a number, not a " + typeof(x)), "error");
return undefined;
} else if (typeof(y) != "number") {
eden.error(new Error("shapesAt: The y-coordinate must be a number, not a " + typeof(y)), "error");
return undefined;
}
return edenUI.plugins.Canvas2D.findAllDrawablesHit(target, x, y, testAll);
}}$;
}

func zonesAt {
auto drawables, zones, i;
drawables = apply(shapesAt, $);
zones = [];
for (i = 1; i <= drawables#; i++) {
append zones, drawables[i].name;
}
return zones;
}

func observablesAt {
auto drawables, obsList, obsName, i;
drawables = apply(shapesAt, $);
obsList = [];
for (i = 1; i <= drawables#; i++) {
obsName = observableForShape(drawables[i]);
if (obsName != @) {
append obsList, obsName;
}
}
return obsList;
}



${{
Arc = function(x, y, r, sAngle, eAngle, colour, drawingOptions) {
this.x = x;
this.y = y;
this.r = r;
this.sAngle = sAngle;
this.eAngle = eAngle;
var radiansPerUnit = root.lookup("radiansPerUnit").value();
var sRadians = sAngle * radiansPerUnit;
var eRadians = eAngle * radiansPerUnit;
var twoPI = 2 * Math.PI;
sRadians = sRadians % twoPI;
if (sRadians < 0) {
sRadians = sRadians + twoPI;
}
eRadians = eRadians % twoPI;
if (eRadians < 0) {
eRadians = eRadians + twoPI;
}
this.sRadians = sRadians;
this.eRadians = eRadians;

this.colour = colour
this.drawingOptions = drawingOptions;
}
}}$;

func Arc { ${{
var x = arguments[0];
var y = arguments[1];
var r = arguments[2];
var sAngle = arguments[3];
var eAngle = arguments[4];
var colour, drawingOptions;
if (arguments.length == 6 && typeof(arguments[5]) == "object" && !(arguments[5] instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
colour = "black";
drawingOptions = arguments[5];
} else {
colour = arguments[5];
drawingOptions = arguments[6];
if (colour === undefined) { colour = "black"; }
}
return new Arc(x, y, r, sAngle, eAngle, colour, drawingOptions);
}}$; };
radiansPerUnit ~> [Arc];

${{

Arc.prototype.draw = function(context) {
var anticlockwise;
if (this.drawingOptions !== undefined && "direction" in this.drawingOptions) {
var directionName = this.drawingOptions.direction;
var turnedThroughAC = this.eRadians - this.sRadians;
if (this.eRadians < this.sRadians) {
turnedThroughAC = turnedThroughAC + twoPI;
}
switch (directionName) {
case "anticlockwise":
case "acw":
case "ccw":
anticlockwise = true;
break;
case "auto":
anticlockwise = this.sAngle < this.eAngle;
break;
case "clockwise":
case "cw":
anticlockwise = false;
break;
case "major":
anticlockwise = turnedThroughAC > Math.PI;
break;
case "minor":
anticlockwise = turnedThroughAC <= Math.PI;
break;
default:
//Invalid value specified.
anticlockwise = true;
}
} else {
//Default to "auto"
anticlockwise = this.sAngle < this.eAngle;
}
context.beginPath();
context.arc(this.x, this.y, this.r - context.lineWidth / 2, -this.sRadians, -this.eRadians, anticlockwise);
context.strokeStyle = this.colour;
context.stroke();
};

Arc.prototype.toString = function() {
var s = "Arc(" + Eden.edenCodeForValues(this.x, this.y, this.r, this.sAngle, this.eAngle, this.colour);

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
}

Arc.prototype.getEdenCode = Arc.prototype.toString;

}}$;


func Button {
${{
var name = root.currentObservableName();
if (name === undefined) {
eden.error(new Error("Button: Every button must be defined by making a dependency."), "error");
return undefined;
}
var label = arguments[0];
var x = arguments[1];
var y = arguments[2];
var enabled = arguments[3];
var fillcolour = arguments[4];
var textcolour = arguments[5];
if (enabled === undefined) enabled = true;
return new Button(name, label, x, y, enabled, fillcolour, textcolour);
}}$;
}

${{
var Button = function (name, label, x, y, enabled, fillcolour, textcolour) {
this.name = name;
this.label = label;
this.x = x;
this.y = y;
this.enabled = enabled;
this.fillcolour = fillcolour;
this.textcolour = textcolour;
};

Button.prototype.hash = function () {
return this.name+"$$"+
this.label+"$$"+
this.x+"$$"+
this.y+"$$"+
this.enabled+"$$"+
this.fillcolour+"$$"+
this.textcolour;
};

Button.prototype.draw = function (context) {

if (this.elements === undefined) {
var name = this.name;

var disabled = this.enabled === false? "disabled=\"disabled\"" : "";
var inputHtml = '<input  type="button"' +
'value="' + this.label + '"' + disabled +
'style="position: absolute; ';
if (this.fillcolour !== undefined) {
inputHtml = inputHtml + 'background-color: ' + this.fillcolour + '; ';
}
if (this.textcolour !== undefined) {
inputHtml = inputHtml + 'color: ' + this.textcolour + '; ';
}
inputHtml = inputHtml + '"/>';

var inputJQ = $(inputHtml);
var clickSym = root.lookup(name + "_click");
if (clickSym.value() === undefined) {
var agent = root.lookup("Button");
clickSym.assign(false, root.scope, agent);
root.lookup(name + "_clicked").assign(false, root.scope, agent);
}

inputJQ
.click(function () {
root.lookup(name + "_clicked").assign(true, root.scope, Symbol.hciAgent, true);
root.lookup(name + "_clicked").assign(false, root.scope, Symbol.hciAgent, true);
})
.on("mousedown", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
})
.on("mouseup", function () {
edenUI.plugins.Canvas2D.endClick();
})
.on("mouseenter", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
});

var button = inputJQ.get(0);
this.elements = [button];

} else {

//Case when the user has performed direct assignment to one or more JavaScript properties.
var button = this.elements[0];
button.value = this.label;

if (this.enabled) {
button.disabled = false;
} else {
button.disabled = true;
}

var style = button.style;
var fillcolour = this.fillcolour;
if (style.backgroundColor != fillcolour) {
if (fillcolour === undefined) {
style.backgroundColor = "ButtonFace";
} else {
style.backgroundColor = fillcolour;
}
}
var textcolour = this.textcolour;
if (style.color != textcolour) {
if (textcolour === undefined) {
style.color = "ButtonText";
} else {
style.color = textcolour;
}
}
}
};

Button.prototype.scale = function (scale, zoom, origin) {
var style = this.elements[0].style;
style.left = Math.round(this.x * scale + origin.x) + "px";
style.top = Math.round(this.y * scale + origin.y) + "px";
style.fontSize = zoom + "em";
};

Button.prototype.toString = function () {
return "Button(" + Eden.edenCodeForValues(this.label, this.x, this.y, this.enabled) + ")";
};

Button.prototype.getEdenCode = Button.prototype.toString;

}}$;


${{
Checkbox = function (name, x, y, tristate, enabled) {
this.name = name;
this.x = x;
this.y = y;
this.tristate = tristate;
this.enabled = enabled;
}

Checkbox.prototype.hash = function () {
return this.name+"$$"+
this.x+"$$"+
this.y+"$$"+
this.tristate+"$$"+
this.enabled;
};
}}$;

func Checkbox { ${{
var name = root.currentObservableName();
if (name === undefined) {
eden.error(new Error("Checkbox: Every checkbox must be defined by making a dependency."), "error");
return undefined;
}
var x = arguments[0];
var y = arguments[1];
var tristate = arguments[2];
if (tristate === undefined) tristate = false;
var enabled = arguments[3];
if (enabled === undefined) enabled = true;
return new Checkbox(name, x, y, tristate, enabled);
}}$; }

${{

Checkbox.prototype.draw = function(context) {

if (this.elements === undefined) {
var me = this;
var name = this.name;

var jqElement = $("<input type=\"checkbox\" style=\"position: absolute\" />");
var element = jqElement.get(0);
element.disabled = (this.enabled === false);

var valueSym = root.lookup(name + "_checked");
var value = valueSym.value();
if (value === undefined) {
if (this.tristate) {
element.indeterminate = true;
} else {
valueSym.assign(false, root.scope, root.lookup("Checkbox"));
}
} else {
element.checked = value;
}
valueSym.addJSObserver("updateCheckbox", function (obs, value) {
var element = me.elements[0];
if (value === undefined) {
element.indeterminate = true;
element.checked = false;
} else {
element.indeterminate = false;
element.checked = (value == true);
}
});

jqElement.change(function (event) {
var element = event.target;
var value;
if (element.indeterminate) {
element.indeterminate = false;
element.checked = true;
value = true;
} else if (me.tristate && valueSym.value() === false) {
element.indeterminate = true;
element.checked = false;
value = undefined;
} else {
value = element.checked;
}
valueSym.assign(value, root.scope, Symbol.hciAgent, true);
})
.on("mousedown", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(undefined, root.scope, Symbol.hciAgent, mouseFollow);
})
.on("mouseup", function () {
edenUI.plugins.Canvas2D.endClick();
})
.on("mouseenter", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
});

this.elements = [element];
}
};

Checkbox.prototype.scale = function (scale, zoom, origin) {
var style = this.elements[0].style;
style.left = Math.round(this.x * scale + origin.x) + "px";
style.top = Math.round(this.y * scale + origin.y) + "px";
var checkboxSize = Math.round(13 * zoom) + "px";
style.width = checkboxSize;
style.height = checkboxSize;
};

Checkbox.prototype.toString = function() {
return "Checkbox(" + Eden.edenCodeForValues(this.x, this.y, this.tristate, this.enabled) + ")";
};

Checkbox.prototype.getEdenCode = Checkbox.prototype.toString;

}}$;


${{
Circle = function(x, y, radius, fillcolour, outlinecolour, drawingOptions) {
this.x = x;
this.y = y;
this.radius = radius;
if (fillcolour === undefined && outlinecolour === undefined) {
this.fillcolour = undefined;
this.outlinecolour = "black";
} else {
this.fillcolour = fillcolour;
this.outlinecolour = outlinecolour;
}
this.drawingOptions = drawingOptions;
this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Circle");
this.obsName = root.currentObservableName();
}
}}$;

func Circle { ${{
var x = arguments[0];
var y = arguments[1];
var radius = arguments[2];
var fillcolour, outlinecolour, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}
if (processUpTo >= 3) {
fillcolour = arguments[3];
if (processUpTo == 4) {
outlinecolour = arguments[4];
}
}
return new Circle(x, y, radius, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

Circle.prototype.draw = function(context) {
this.tracePath(context);
if (this.fillcolour !== undefined) {
edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
context.fill();
}
if (this.outlinecolour !== undefined) {
context.strokeStyle = this.outlinecolour;
context.stroke();
}
};

Circle.prototype.tracePath = function (context) {
var lineWidth;
if (this.outlinecolour !== undefined) {
lineWidth = context.lineWidth;
} else {
lineWidth = 0;
}
context.beginPath();
context.arc(this.x, this.y, this.radius - lineWidth / 2, 0, 2 * Math.PI, false);
context.closePath();
}

Circle.prototype.isHit = function (context, scale, x, y) {
this.tracePath(context);
return context.isPointInPath(x,y);
}

Circle.prototype.toString = function() {
var s = "Circle(" + Eden.edenCodeForValues(this.x, this.y, this.radius, this.fillcolour, this.outlinecolour);

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
};

Circle.prototype.getEdenCode = Circle.prototype.toString;

Circle.prototype.imageMapArea = function () {
return "shape=\"circle\" coords=\"" + this.x + "," + this.y + "," + this.radius + "\"";
}

Circle.prototype.centre = function () {
return new Point(this.x, this.y);
}

}}$;


${{
Combobox = function (name, options, x, y, enabled) {
this.name = name;
this.options = options;
this.x = x;
this.y = y;
this.enabled = enabled;
}

Combobox.prototype.hash = function () {
return this.name+"$$"+
this.options.join("$$")+
this.x+"$$"+
this.y+"$$"+
this.enabled;
};

}}$;

func Combobox { ${{
var name = root.currentObservableName();
if (name === undefined) {
eden.error(new Error("Combobox: Every combobox must be defined by making a dependency."), "error");
return undefined;
}
var options = arguments[0];
var x = arguments[1];
var y = arguments[2];
var enabled = arguments[3];
if (enabled === undefined) enabled = true;
return new Combobox(name, options, x, y, enabled);
}}$; }


${{

function makeOptionsHTML(values) {
var html = "";
for (var i = 0; i < values.length; i++) {
html = html + "\n<option value=\"" + values[i] + "\">" + values[i] + "</option>";
}
return html;
}

Combobox.prototype.draw = function(context) {
var dropDownList;

if (this.elements === undefined) {
var me = this;
var name = this.name;

var disabled = this.enabled === false? "disabled=\"disabled\"" : "";
var dropDownListJQ = $("<select " + disabled + " style=\"position: absolute\"></select>");
dropDownListJQ.html(makeOptionsHTML(this.options));

dropDownList = dropDownListJQ.get(0);
var valueSym = root.lookup(name + '_value');
var initialValue = valueSym.value();
if (initialValue === undefined) {
valueSym.assign(me.options[0], root.scope, root.lookup("Combobox"), true);
} else {
dropDownList.value = initialValue;
}
valueSym.addJSObserver("updateCombobox", function (symbol, value) {
dropDownList.value = value;
});

dropDownListJQ.change(function(event) {
valueSym.assign(event.target.value, root.scope, Symbol.hciAgent, true);
})
.on("mousedown", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(undefined, root.scope, Symbol.hciAgent, mouseFollow);
})
.on("mouseup", function () {
edenUI.plugins.Canvas2D.endClick();
})
.on("mouseenter", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
});

this.elements = [dropDownList];

} else {

//Case when the user has performed direct assignment to one or more JavaScript properties.
dropDownList = this.elements[0];
$(dropDownList).html(makeOptionsHTML(this.options));

dropDownList.value = valueSym.value();

if (this.enabled == true) {
dropDownList.disabled = false;
} else {
dropDownList.disabled = true;
}

}
};

Combobox.prototype.scale = function (scale, zoom, origin) {
var style = this.elements[0].style;
style.left = Math.round(this.x * scale + origin.x) + "px";
style.top = Math.round(this.y * scale + origin.y) + "px";
style.fontSize = zoom + "em";
};

Combobox.prototype.toString = function() {
return "Combobox(" + Eden.edenCodeForValues(this.options, this.x, this.y, this.enabled) + ")";
};

Combobox.prototype.getEdenCode = Combobox.prototype.toString;

}}$;

${{
Curve = function (x1, y1, x2, y2, r, elasticity, theta1, theta2, mid, overshoot, dirSwitch, colours, drawingOptions) {
this.x1 = x1;
this.y1 = y1;
this.x2 = x2;
this.y2 = y2;
this.r = r;
this.elasticity = elasticity;
this.theta1 = theta1;
this.theta2 = theta2;
this.mid = mid;
this.overshoot = overshoot;
this.dirSwitch = dirSwitch;
this.colours = colours;
this.drawingOptions = drawingOptions;

elasticity = elasticity * 0.94;
var xDistance = x2 - x1;
var yDistance = y2 - y1;
this.theta3 = Math.atan2(yDistance, xDistance);
this.fullLength = Math.sqrt(xDistance * xDistance + yDistance * yDistance);
this.length1 = mid * this.fullLength;
var length2 = this.fullLength - this.length1;


var radiansPerUnit = root.lookup("radiansPerUnit").value();
this.delta1 = elasticity * this.length1;
this.delta2 = elasticity * length2;
var fullTurn = 2 * Math.PI;

if (theta1 === undefined) {
this.deltaX1 = 0;
this.deltaY1 = 0;
} else {
var theta1Normalized = (theta1 * radiansPerUnit) % fullTurn;
if (theta1Normalized < 0) {
theta1Normalized = theta1Normalized + fullTurn;
}
var tanTheta1 = Math.abs(Math.tan(theta1Normalized));

if (theta1Normalized > fullTurn/4 && theta1Normalized <= fullTurn * 3/4) {
this.deltaX1 = -overshoot;
} else {
this.deltaX1 = Math.abs(this.length1 - this.delta1);
}

this.deltaY1 = Math.abs(this.deltaX1) * tanTheta1;
if (theta1Normalized > fullTurn/2) {
this.deltaY1 = -this.deltaY1;
} else if (this.deltaY1 > r) {
this.deltaY1 = r;
this.deltaX1 = r / tanTheta1;
}
}

if (theta2 === undefined) {
this.deltaX2 = 0;
this.deltaY2 = 0;
} else {
var theta2Normalized = (theta2 * radiansPerUnit) % fullTurn;
if (theta2Normalized < 0) {
theta2Normalized = theta2Normalized + fullTurn;
}
var tanTheta2 = Math.abs(Math.tan(theta2Normalized));

if (theta2Normalized > fullTurn/4 && theta2Normalized <= fullTurn * 3/4) {
this.deltaX2 = -overshoot;
} else {
this.deltaX2 = Math.abs(length2 - this.delta2);
}

this.deltaY2 = Math.abs(this.deltaX2) * tanTheta2;
if (theta2Normalized > fullTurn/2) {
this.deltaY2 = -this.deltaY2;
} else if (this.deltaY2 > r) {
this.deltaY2 = r;
this.deltaX2 = r / tanTheta2;
}
}

if (dirSwitch) {
this.radius = -r;
this.deltaY1 = -this.deltaY1;
this.deltaY2 = -this.deltaY2;
} else {
this.radius = r;
}
}

}}$;

func Curve {
${{
var x1 = arguments[0];
var y1 = arguments[1];
var x2 = arguments[2];
var y2 = arguments[3];
var r = arguments[4];
var elasticity = arguments[5];

var direction, theta1, theta2, mid = 0.5, overshoot = 150, direction, colours, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
lastArg = arguments[processUpTo];
} else {
processUpTo = arguments.length - 1;
}
if (typeof(lastArg) == "string") {
colours = [lastArg];
processUpTo--;
} else if (Array.isArray(lastArg)) {
colours = lastArg;
processUpTo--;
} else {
colours = ["black"];
}
lastArg = arguments[processUpTo];
if (typeof(lastArg) == "boolean") {
direction = lastArg;
processUpTo--;
}
if (processUpTo > 5) {
theta1 = arguments[6];
if (processUpTo > 6) {
theta2 = arguments[7];
if (processUpTo > 7) {
mid = arguments[8];
if (processUpTo > 8) {
overshoot = arguments[9];
}
}
} else {
theta2 = theta1;
}
}
return new Curve(x1, y1, x2, y2, r, elasticity, theta1, theta2, mid, overshoot, direction, colours, drawingOptions);
}}$;
}
radiansPerUnit ~> [Curve];

${{
Curve.prototype.draw = function (context) {
context.translate(this.x1, this.y1);
context.rotate(this.theta3);
context.beginPath();
context.moveTo(0, 0);
context.bezierCurveTo(this.deltaX1, this.deltaY1, this.length1 - this.delta1, this.radius, this.length1, this.radius);
context.bezierCurveTo(this.length1 + this.delta2, this.radius, this.fullLength - this.deltaX2, this.deltaY2, this.fullLength, 0);
context.strokeStyle = "black";
context.stroke();
};

Curve.prototype.toString = function () {
return "Curve(" + Eden.edenCodeForValues(this.x1, this.y1, this.x2, this.y2, this.r, this.elasticity, this.theta1, this.theta2, this.mid, this.overshoot, this.dirSwitch, this.colours, this.drawingOptions) + ")";
}

Curve.prototype.getEdenCode = Curve.prototype.toString;
}}$;

${{
Div = function (html, x, y, width, height, id, classNames, style) {
this.html = html;
this.x = x;
this.y = y;
this.width = width;
this.height = height;
this.name = id;
this.obsName = root.currentObservableName();
this.classNames = classNames;
this.style = style;
}

Div.prototype.hash = function () {
return this.x+"$$"+
this.y+"$$"+
this.width+"$$"+
this.height+"$$"+
this.html+"$$"+
this.name+"$$"+
this.classNames+"$$"+
this.style;
};
}}$;

func Div { ${{
var html = arguments[0];
var x = arguments[1];
var y = arguments[2];
var width, height;   //Number of pixels, string (e.g. "50%") or undefined (automatic)
var id, classNames;
var style = "";

var argsProcessed = 3;
var argType = typeof(arguments[3]);

if (argType == "number" || argType == "undefined" || (argType == "string" && /^\d/.test(arguments[3]))) {
width = arguments[3];
argsProcessed++;

argType = typeof(arguments[4]);
if (argType == "number" || argType == "undefined" || (argType == "string" && /^\d/.test(arguments[4]))) {
height = arguments[4];
argsProcessed++;
}
}

if (arguments.length > argsProcessed) {
if (arguments.length == argsProcessed + 3) {
id = arguments[argsProcessed];
classNames = arguments[argsProcessed + 1];
style = arguments[argsProcessed + 2];
} else {
if (Array.isArray(arguments[argsProcessed])) {
classNames = arguments[argsProcessed];
if (arguments.length == argsProcessed + 2) {
style = arguments[argsProcessed + 1];
}
} else if (arguments.length == argsProcessed + 2) {
id = arguments[argsProcessed];
if (Array.isArray(arguments[argsProcessed + 1])) {
classNames = arguments[argsProcessed + 1];
} else {
style = arguments[argsProcessed + 1];
}
} else if (typeof(arguments[argsProcessed]) != "string" || arguments[argsProcessed].indexOf(":") == -1) {
id = arguments[argsProcessed];
} else {
style = arguments[argsProcessed];
}
}
}
return new Div(html, x, y, width, height, id, classNames, style);
}}$; }

${{

Div.prototype.draw = function(context) {

if (this.elements === undefined) {
var me = this;
var divStyle = "position: absolute; " + this.style;

var divElement = document.createElement("div");
if (this.name !== undefined) {
divElement.id = this.name;
}
if (Array.isArray(this.classNames)) {
divElement.setAttribute("class", this.classNames.join(" "));
}
divElement.style.cssText = divStyle;
divElement.innerHTML = this.html;
var match = divElement.style.fontSize.match(/^(\d+)([a-z%]+)$/);
if (match !== null) {
this.fontSizeNumber = match[1];
this.fontSizeUnits = match[2];
}

//Create object properties that record the automatically generated width and/or height.
if (this.name !== undefined) {
divElement.onmousedown = function (event) {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(event.target.id, root.scope, Symbol.hciAgent, mouseFollow);
};
divElement.onmouseup = function (event) {
edenUI.plugins.Canvas2D.endClick();
};
divElement.onmouseenter = function (event) {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(event.target.id, root.scope, Symbol.hciAgent, mouseFollow);
};
edenUI.plugins.Canvas2D.initZoneFromName(name, "Div")

var widthSymName = this.name + "_width";
var heightSymName = this.name + "_height";
if (this.width === undefined || this.height === undefined || widthSymName in root.symbols || heightSymName in root.symbols) {
var objectElement = document.createElement("object");
objectElement.setAttribute("style", "display: block; position: absolute; top: 0px; left: 0px; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;");
objectElement.onload = function () {
var resizeAction = function () {
if (me.width === undefined || widthSymName in root.symbols) {
root.lookup(widthSymName).assign(me.elements[0].clientWidth, root.scope);
}
if (me.height === undefined || heightSymName in root.symbols) {
root.lookup(heightSymName).assign(me.elements[0].clientHeight, root.scope);
}
};
resizeAction();
this.contentDocument.defaultView.addEventListener("resize", resizeAction);
};
objectElement.type = "text/html";
objectElement.data = "about:blank";
divElement.appendChild(objectElement);
}
}

this.elements = [divElement];
}
};

Div.prototype.scale = function (scale, zoom , origin) {
var style = this.elements[0].style;
if (typeof(this.x) == "number") {
style.left = Math.round(this.x * scale + origin.x) + "px";
}
if (typeof(this.y) == "number") {
style.top = Math.round(this.y * scale + origin.y) + "px";
}
if (typeof(this.width) == "number") {
style.width = Math.round(this.width * scale) + "px";
}
if (typeof(this.height) == "number") {
style.height = Math.round(this.height * scale) + "px";
}
if (this.fontSizeNumber !== undefined) {
style.fontSize = String(this.fontSizeNumber * zoom) + this.fontSizeUnits;
} else {
if (zoom == 1) {
style.fontSize = ""; //Could be specified by CSS class rather than the style argument.
} else {
style.fontSize = zoom + "em";
}
}
};

Div.prototype.toString = function() {
return this.getEdenCode();
};

Div.prototype.getEdenCode = function () {
var s = "Div(" + Eden.edenCodeForValues(this.html, this.x, this.y, this.width, this.height);

if (this.name !== undefined) {
s = s + ", \"" + this.name + "\"";
}
if (this.classNames !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.classNames);
}
if (this.style != "") {
s = s + ", \"" + this.style + "\"";
}
s = s + ")";
return s;
};

}}$;


${{
Ellipse = function(x, y, xradius, yradius, fillcolour, outlinecolour, drawingOptions) {
this.x = x;
this.y = y;
this.xradius = xradius;
this.yradius = yradius;
this.fillcolour = fillcolour;
this.outlinecolour = outlinecolour;
this.drawingOptions = drawingOptions;
this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Ellipse");
this.obsName = root.currentObservableName();
}
}}$;

func Ellipse { ${{
var x = arguments[0];
var y = arguments[1];
var xradius = arguments[2];
var yradius = arguments[3];
var fillcolour, outlinecolour, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}
if (processUpTo >= 4) {
fillcolour = arguments[4];
if (processUpTo == 5) {
outlinecolour = arguments[5];
}
}

if (fillcolour === undefined && outlinecolour === undefined) {
outlinecolour = "black";
}
return new Ellipse(x, y, xradius, yradius, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

Ellipse.prototype.draw = function(context) {
var scaleOutline;
if (this.outlinecolour === undefined || this.outlinecolour == "transparent") {
scaleOutline = false;
} else if (this.drawingOptions === undefined || !("scaleOutline" in this.drawingOptions)) {
scaleOutline = (this.fillcolour !== undefined && this.fillcolour != "transparent");
} else {
scaleOutline = this.drawingOptions.scaleOutline;
}
if (!scaleOutline) {
context.save();
}

this.tracePath(context, scaleOutline);

if (this.fillcolour !== undefined) {
edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
context.fill();
}

if (!scaleOutline) {
context.restore();
}
if (this.outlinecolour !== undefined) {
context.strokeStyle = this.outlinecolour;
context.stroke();
}
};

Ellipse.prototype.tracePath = function (context, scaleOutline) {
var scaleFactor = this.yradius / this.xradius;
var lineWidth;
if (this.outlinecolour !== undefined && this.outlinecolour != "transparent") {
if (scaleOutline) {
lineWidth = context.lineWidth;
} else {
lineWidth = context.lineWidth / scaleFactor;
}
} else {
lineWidth = 0;
}

context.scale(1, scaleFactor);
context.beginPath();
context.arc(this.x, this.y / scaleFactor, this.xradius - lineWidth / 2, 0, 2 * Math.PI, false);
context.closePath();
}

Ellipse.prototype.isHit = function (context, scale, x, y) {
this.tracePath(context, false);
return context.isPointInPath(x,y);
}

Ellipse.prototype.toString = function() {
var s = "Ellipse(" + Eden.edenCodeForValues(this.x, this.y, this.xradius, this.yradius, this.fillcolour, this.outlinecolour);

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
};

Ellipse.prototype.getEdenCode = Ellipse.prototype.toString;

}}$;



${{
FillPattern = function (url) {
this.image = new Image();
this.canvasesToRepaint = {};
this.loaded = false;

var me = this;

this.image.onload = function(){
me.loaded = true;
for (var canvas in me.canvasesToRepaint) {
var pictureObs = root.lookup(canvas);
pictureObs.jsObservers.refreshView(pictureObs, pictureObs.value());
}
}
this.image.src = url;
};
}}$;

func FillPattern {
${{
return new FillPattern(arguments[0]);
}}$;
}

${{
FillPattern.prototype = new EdenUI.plugins.Canvas2D.FillStyle();

FillPattern.prototype.getColour = function (context) {
return context.createPattern(this.image, 'repeat');
}

FillPattern.prototype.toString = function() {
return "FillPattern(\"" + this.image.src + "\")";
}

FillPattern.prototype.getEdenCode = FillPattern.prototype.toString;

}}$;

/*
func greyMap {
auto data, i, j, v;
data = [];
for (j = 0; j <= 255; j++) {
for (i = 0; i <= 255; i++) {
v = sqrt((i - 128) * (i - 128) + (j - 128) * (j - 128));
if (v > 115) {
append data, @;
} else {
append data, ((i - 128) * (i - 128) + (j - 128) * (j - 128)) % 256;
}
}
}
return data;
}
pixelData is greyMap();
pixels is GreyPixelList(&pixelData, mousePosition.x - 128, mousePosition.y - 128, 256);
picture is [pixels];
*/
func GreyPixelList {
${{
var name;
var argsProcessed;
if (typeof(arguments[0]) == "string") {
name = arguments[0];
argsProcessed = 1;
} else {
argsProcessed = 0;
}
var ptrToData = arguments[argsProcessed];
argsProcessed++;
var x = arguments[argsProcessed];
argsProcessed++;
var y = arguments[argsProcessed];
argsProcessed++;
var width = arguments[argsProcessed];
argsProcessed++;
var redMultiply = arguments[argsProcessed];
if (redMultiply === undefined) redMultiply = 1;
argsProcessed++;
var greenMultiply = arguments[argsProcessed];
if (greenMultiply === undefined) greenMultiply = 1;
argsProcessed++;
var blueMultiply = arguments[argsProcessed];
if (blueMultiply === undefined) blueMultiply = 1;
argsProcessed++;
var redAdd = arguments[argsProcessed];
if (redAdd === undefined) redAdd = 0;
argsProcessed++;
var greenAdd = arguments[argsProcessed];
if (greenAdd === undefined) greenAdd = 0;
argsProcessed++;
var blueAdd = arguments[argsProcessed];
if (blueAdd === undefined) blueAdd = 0;
argsProcessed++;
return new GreyPixelList(name, ptrToData, x, y, width, redMultiply, greenMultiply, blueMultiply, redAdd, greenAdd, blueAdd);
}}$;
}

${{
function GreyPixelList(name, ptrToData, x, y, width, redMultiply, greenMultiply, blueMultiply, redAdd, greenAdd, blueAdd) {
this.name = edenUI.plugins.Canvas2D.initZoneFromName(name, "GreyPixelList");
this.obsName = root.currentObservableName();
this.data = ptrToData.value();
this.x = x;
this.y = y;
this.width = width;
this.height = this.data.length / width;
this.redMultiply = redMultiply;
this.greenMultiply = greenMultiply;
this.blueMultiply = blueMultiply;
this.redAdd = redAdd;
this.greenAdd = greenAdd;
this.blueAdd = blueAdd;
}

GreyPixelList.prototype.draw = function(context) {
var imageData = context.createImageData(this.width, this.height);
var imageArr = imageData.data;
var dataArr = this.data;
var dataArrayLen = dataArr.length;
var imageArrayLen = dataArrayLen * 4;
var offset;

offset = 0;
for (var i = 0; i < dataArrayLen; i++) {
imageArr[offset] = this.redMultiply * dataArr[i] + this.redAdd;
offset = offset + 4;
}

offset = 1;
for (var i = 0; i < dataArrayLen; i++) {
imageArr[offset] = this.greenMultiply * dataArr[i] + this.greenAdd;
offset = offset + 4;
}

offset = 2;
for (var i = 0; i < dataArrayLen; i++) {
imageArr[offset] = this.blueMultiply * dataArr[i] + this.blueAdd;
offset = offset + 4;
}

offset = 3;
for (var i = 0; i < dataArrayLen; i++) {
if (dataArr[i] !== undefined) {
imageArr[offset] = 255;
}
offset = offset + 4;
}

context.putImageData(imageData, this.x, this.y);
}

GreyPixelList.prototype.isHit = function (context, scale, x, y) {
return x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height &&
this.data[(y - this.y) * this.width + x - this.x] !== undefined;
}


GreyPixelList.prototype.toString = function() {
return "GreyPixelList(" +
Eden.edenCodeForValue(this.name) + ", " +
this.data.length + " pixel values, " +
Eden.edenCodeForValues(this.x, this.y, this.width) + "," +
this.redMultiply + ", " + this.redAdd + ", " +
this.greenMultiply + ", " + this.greenAdd + ", " +
this.blueMultiply + ", " + this.blueAdd + ")";
}

GreyPixelList.prototype.getEdenCode = function() {
return "GreyPixelList(" +
Eden.edenCodeForValues(this.name, this.data, this.x, this.y, this.width) + "," +
this.redMultiply + ", " + this.redAdd + ", " +
this.greenMultiply + ", " + this.greenAdd + ", " +
this.blueMultiply + ", " + this.blueAdd + ")";
}

}}$;



${{
CanvasImage = function (name, dx, dy, dWidth, dHeight, sx1, sy1, sx2, sy2, smoothed, file) {
this.name = edenUI.plugins.Canvas2D.initZoneFromName(name, "Image");
this.obsName = root.currentObservableName();

var temp;
if (sx2 !== undefined) {
if (sx1 > sx2) {
temp = sx1;
sx1 = sx2;
sx2 = temp;
}
this.sWidth = sx2 - sx1;
}
if (sy2 !== undefined) {
if (sy1 > sy2) {
temp = sy1;
sy1 = sy2;
sy2 = temp;
}
this.sHeight = sy2 - sy1;
}

this.originalDWidth = dWidth;
this.originalDHeight = dHeight;
this.originalSX2 = sx2;
this.originalSY2 = sy2;

this.dx = dx;
this.dy = dy;
this.dWidth = dWidth;
this.dHeight = dHeight;
this.sx = sx1;
this.sy = sy1;
this.smoothed = smoothed;

this.image = new Image();
this.canvasesToRepaint = {};
this.loaded = false;

var me = this;

this.image.onload = function() {
if (me.sWidth === undefined) {
me.sWidth = me.image.width - me.sx;
}
if (me.sHeight === undefined) {
me.sHeight = me.image.height - me.sy;
}
if (me.dWidth === undefined && me.dHeight === undefined) {
me.dWidth = me.sWidth;
me.dHeight = me.sHeight;
} else if (me.dWidth === undefined) {
me.dWidth = me.sWidth * me.dHeight / me.sHeight;
} else if (me.dHeight === undefined) {
me.dHeight = me.sHeight * me.dWidth / me.sWidth;
}

me.loaded = true;
for (var pictureObs in me.canvasesToRepaint) {
edenUI.plugins.Canvas2D.drawPictures(pictureObs);
}
}
this.image.src = file;
};
}}$;

func Image {
${{
var numArgs = arguments.length;
var argsProcessed;
var name;
if (typeof(arguments[0]) == "string") {
name = arguments[0];
argsProcessed = 1;
} else {
argsProcessed = 0;
}

var dx = arguments[argsProcessed];
argsProcessed++;
var dy = arguments[argsProcessed];
argsProcessed++;

var dWidth, dHeight, sx1 = 0, sy1 = 0, sx2, sy2, smoothed = true, file;

if (numArgs - 1 > argsProcessed) {
dWidth = arguments[argsProcessed];
argsProcessed++;
}
if (numArgs - 1 > argsProcessed) {
dHeight = arguments[argsProcessed];
argsProcessed++;
}
if (numArgs - 1 > argsProcessed) {
sx1 = arguments[argsProcessed];
argsProcessed++;
}
if (numArgs - 1 > argsProcessed) {
sy1 = arguments[argsProcessed];
argsProcessed++;
}
if (numArgs - 1 > argsProcessed) {
sx2 = arguments[argsProcessed];
argsProcessed++;
}
if (numArgs - 1 > argsProcessed) {
sy2 = arguments[argsProcessed];
argsProcessed++;
}
if (numArgs - 1 > argsProcessed) {
smoothed = arguments[argsProcessed];
argsProcessed++;
}
file = arguments[numArgs - 1];
return new CanvasImage(name, dx, dy, dWidth, dHeight, sx1, sy1, sx2, sy2, smoothed, file);
}}$;
}

${{
CanvasImage.prototype.draw = function(context, scale, pictureObs) {
if (this.loaded) {
var smoothed = this.smoothed;
context.mozImageSmoothingEnabled = smoothed;
context.msImageSmoothingEnabled = smoothed;
context.imageSmoothingEnabled = smoothed;
context.drawImage(this.image, this.sx, this.sy, this.sWidth, this.sHeight, this.dx, this.dy, this.dWidth, this.dHeight);
} else {
this.canvasesToRepaint[pictureObs] = true;
}
};

CanvasImage.prototype.isHit = function (context, scale, x, y) {
return x >= this.dx && x < this.dx + this.dWidth && y >= this.dy && y < this.dy + this.dHeight;
}

CanvasImage.prototype.toString = function() {
return "Image(" +	Eden.edenCodeForValues(this.name, this.dx, this.dy, this.originalDWidth,
this.originalDHeight, this.sx, this.sy, this.originalSX2, this.originalSY2, this.smoothed, this.image.src) + ")";
};

CanvasImage.prototype.getEdenCode = CanvasImage.prototype.toString;

}}$;



${{
HTMLImage = function (name, x, y, width, height, scaleFactor, url, imageMap) {
this.name = name;
this.obsName = root.currentObservableName();
this.x = x;
this.y = y;
this.width = width;
this.height = height;
this.scaledWidth = width;
this.scaledHeight = height;
this.scaleFactor = scaleFactor;
this.url = url;
this.imageMap = imageMap;
}

HTMLImage.prototype.hash = function () {
return this.name+"$$"+
this.x+"$$"+
this.y+"$$"+
this.width+"$$"+
this.height+"$$"+
this.scaleFactor+"$$"+
this.url+"$$"+
this.imageMap;
};
}}$;

func HTMLImage { ${{
var numArgs = arguments.length;
var argsProcessedFirst;

var name;
if (typeof(arguments[0]) == "string") {
name = arguments[0];
argsProcessedFirst = 1;
} else {
argsProcessedFirst = 0;
}

var x = arguments[argsProcessedFirst];
argsProcessedFirst++;
var y = arguments[argsProcessedFirst];
argsProcessedFirst++;

var width, height, url, imageMap;
var scaleFactor = 1;
var argsLeft = numArgs - argsProcessedFirst;

if (numArgs == 8 || Array.isArray(arguments[numArgs - 1])) {
imageMap = arguments[numArgs - 1];
url = arguments[numArgs - 2];
argsLeft = argsLeft - 2;
} else {
url = arguments[numArgs - 1];
argsLeft--;
}

if (argsLeft >= 1) {
width = arguments[argsProcessedFirst];
if (argsLeft >=2) {
height = arguments[argsProcessedFirst + 1];
if (argsLeft == 3) {
scaleFactor = arguments[argsProcessedFirst + 2];
}
}
}
return new HTMLImage(name, x, y, width, height, scaleFactor, url, imageMap);
}}$; }

${{
HTMLImage.prototype.draw = function(context) {
if (this.elements === undefined) {
var id = "canvas_" + this.name;
var name = this.name;
var me = this;

var html = '<img style="position: absolute"';
if (this.imageMap !== undefined) {
html = html + ' usemap="#' + id + '-map" draggable="false" class="noselect"';
}
html = html + '/>';
var imageJQ = $(html);

if (this.scaledWidth === undefined || this.scaledHeight === undefined) {
imageJQ.on("load", function (event) {
var image = event.target;
var parentID = image.parentElement.id;
var canvasName = parentID.slice(0, -21) // trim -dialog-canvascontent
var canvasScale = root.lookup("_view_" + canvasName + "_scale").value() * root.lookup("_view_" + canvasName + "_zoom").value();

if (me.scaledWidth === undefined && me.scaledHeight === undefined) {
me.scaledWidth = image.naturalWidth;
me.scaledHeight = image.naturalHeight;
} else if (me.scaledWidth === undefined) {
me.scaledWidth = image.naturalWidth * me.scaledHeight / image.naturalHeight;
}
if (me.scaledHeight === undefined) {
me.scaledHeight = image.naturalHeight * me.scaledWidth / image.naturalWidth;
}
image.width = Math.round(me.scaledWidth * canvasScale / me.scaleFactor);
image.height = Math.round(me.scaledHeight * canvasScale / me.scaleFactor);
});
}
imageJQ[0].src = this.url;
this.elements = [imageJQ.get(0)];

imageJQ.on("mousemove", function (event) {
var image = event.target;
var parentID = image.parentElement.id;
var canvasName = parentID.slice(0, -21) // trim -dialog-canvascontent
var canvasScale = root.lookup("_view_" + canvasName + "_scale").value() * root.lookup("_view_" + canvasName + "_zoom").value();
var mouseFollow = root.lookup("mouseFollow").value();
var imagePos = $(this).offset();
var x = (event.pageX - Math.round(imagePos.left)) / canvasScale;
var y = (event.pageY - Math.round(imagePos.top)) / canvasScale;
root.lookup("mousePosition").assign(new Point(x, y), root.scope, Symbol.hciAgent, mouseFollow);
});

if (name !== undefined) {
edenUI.plugins.Canvas2D.initZoneFromName(name, "HTMLImage");
imageJQ.on("mousedown", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
})
.on("mouseup", function () {
edenUI.plugins.Canvas2D.endClick();
})
.on("mouseenter", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
});
}

if (this.imageMap !== undefined) {
var mapJQ = $("<map name=\"" + id + "-map\" id=\"" + id + "-map\"></map>");

var setAreaEvents = function (area, regionName) {
area.on("mouseenter", function (event) {
var followMouse = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(regionName, root.scope, Symbol.hciAgent, followMouse);
})
.on("mousedown", function (event) {
var followMouse = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(regionName, root.scope, Symbol.hciAgent, followMouse);

}).on("mouseup", function (event) {
edenUI.plugins.Canvas2D.endClick();
});
};

for (var i = this.imageMap.length - 1; i >= 0; i--) {
var shape = this.imageMap[i];
var regionName;
if (shape.drawingOptions !== undefined) {
regionName = shape.drawingOptions.name;
} else {
regionName = undefined;
}
var areaJQ = $('<area ' + shape.imageMapArea() + '/>');
if (regionName !== undefined) {
setAreaEvents(areaJQ, regionName);
} else if (name !== undefined) {
setAreaEvents(areaJQ, name);
}
mapJQ.append(areaJQ);

if (eden.isValidIdentifier(regionName)) {
var clickSym = root.lookup(regionName + "_click");
if (clickSym.value() === undefined) {
clickSym.assign(false, root.scope, root.lookup("HTMLImage"));
}
}
}
this.elements.push(mapJQ.get(0));
}
}
};

HTMLImage.prototype.scale = function (scale, zoom, origin) {
var imageElem = this.elements[0];
var style = imageElem.style;
style.left = Math.round(this.x * scale + origin.x) + "px";
style.top = Math.round(this.y * scale + origin.y) + "px";
imageElem.width = Math.round(this.scaledWidth * scale / this.scaleFactor);
imageElem.height = Math.round(this.scaledHeight * scale / this.scaleFactor);
};

HTMLImage.prototype.toString = function() {
return "HTMLImage(" + Eden.edenCodeForValues(this.name, this.x, this.y, this.width, this.height, this.url, this.imageMap) + ")";
};

HTMLImage.prototype.getEdenCode = HTMLImage.prototype.toString;

}}$;

func imageWithZones {
auto name, width, height, url, imageMap, testing, items, argsProcessed;
auto i, shape, zoneName, centre;
items = [];
if (isString($[2])) {
name = $[1];
url = $[2];
argsProcessed = 2;
} else if (isList($[2])) {
url = $[1];
argsProcessed = 1;
} else if (isString($[1])) {
name = $[1];
width = $[2];
height = $[3];
url = $[4];
argsProcessed = 4;
} else {
width = $[1];
height = $[2];
url = $[3];
argsProcessed = 3;
}
imageMap = $[argsProcessed + 1];
testing = $[argsProcessed + 2];

if (testing) {
append items, Image(name, 0, 0, width, height, url);
for (i = 1; i <= imageMap#; i++) {
shape = imageMap[i];
append items, shape;
zoneName = shape.drawingOptions == @? @ : shape.drawingOptions.name;
if (zoneName != @) {
centre = shape.centre();
append items, Div(zoneName, centre.x - 5.5 * zoneName#, centre.y - 15, @, @, "color: white; background-color: black; font-size: 20px; font-family: monospace");
}
}
} else {
append items, HTMLImage(name, 0, 0, width, height, url, imageMap);
}
return items;
}


${{
Line = function(x1, y1, x2, y2, colours, drawingOptions) {
this.x1 = x1;
this.y1 = y1;
this.x2 = x2;
this.y2 = y2;
var align, valign, shift;
if (drawingOptions !== undefined) {
align = drawingOptions.align;
valign = drawingOptions.valign;
}
if (this.x1 == this.x2) {
if (align == "left") {
shift = -1;
} else if (align == "right") {
shift = 1;
} else {
shift = 0;
}
this.xShift1 = shift;
this.xShift2 = shift;
this.yShift1 = 0;
this.yShift2 = 0;
} else if (this.y1 == this.y2) {
if (valign == "top") {
shift = -1;
} else if (valign == "bottom") {
shift = 1;
} else {
shift = 0;
}
this.xShift1 = 0;
this.xShift2 = 0;
this.yShift1 = shift;
this.yShift2 = shift;
} else {
this.xShift1 = this.x2 > this.x1? 1 : -1;
this.xShift2 = -this.xShift1;
this.yShift1 = this.y2 > this.y1? 1 : -1;
this.yShift2 = -this.yShift1;
}
this.colours = colours;
this.drawingOptions = drawingOptions;
}
}}$;

func Line { ${{
var x1 = arguments[0];
var y1 = arguments[1];
var x2 = arguments[2];
var y2 = arguments[3];
var colours, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}
if (processUpTo == 4) {
colours = arguments[4];
}

if (colours === undefined) {
colours = ["black"];
} else if (!Array.isArray(colours)) {
colours = [colours];
} else if (colours.length == 0) {
colours = ["black"];
}
return new Line(x1, y1, x2, y2, colours, drawingOptions);
}}$; };

${{

Line.prototype.draw = function(context) {
context.beginPath();
if (this.colours.length == 1) {
context.strokeStyle = this.colours[0];
} else {
var gradient = context.createLinearGradient(this.x1, this.y1, this.x2, this.y2);
for (var i = 0; i < this.colours.length; i++) {
gradient.addColorStop(i / (this.colours.length - 1), this.colours[i]);
}
context.strokeStyle = gradient;
}
var xShift1, xShift2, yShift1, yShift2;
if (this.drawingOptions !== undefined) {
var scale = this.drawingOptions.lineWidth / context.lineWidth;
var width = (context.lineWidth / 2 + 0.5 / scale) / Math.SQRT2;
xShift1 = this.xShift1 * width;
xShift2 = this.xShift2 * width;
yShift1 = this.yShift1 * width;
yShift2 = this.yShift2 * width;
if ((this.xShift1 == 0 || this.yShift1 == 0) && this.drawingOptions.lineWidth % 2 == 1) {
context.translate(0.5 / scale, 0.5 / scale);
}
} else {
xShift1 = 0;
xShift2 = 0;
yShift1 = 0;
yShift2 = 0;
}
context.moveTo(this.x1 + xShift1, this.y1 + yShift1);
context.lineTo(this.x2 + xShift2, this.y2 + yShift2);
context.stroke();
};

Line.prototype.toString = function() {
var s = "Line(" + Eden.edenCodeForValues(this.x1, this.y1, this.x2, this.y2) + ", ";

if (this.colours.length > 1) {
s = s + Eden.edenCodeForValue(this.colours);
} else {
s = s + Eden.edenCodeForValue(this.colours[0]);
}

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
};

Line.prototype.getEdenCode = Line.prototype.toString;

}}$;


/*
x = 50;
y = 50;
width = 400;
height = 250;
gradient is LinearGradient(x, y, x + width, y + height, "cyan", "blue");
rect is Rectangle(x, y, width, height, gradient);
picture is [rect];
*/

func LinearGradient {
${{
var x1 = arguments[0];
var y1 = arguments[1];
var x2 = arguments[2];
var y2 = arguments[3];
var colourStops;
if (Array.isArray(arguments[4])) {
colourStops = arguments[4];
} else {
if (Array.isArray(arguments[6])) {
colourStops = arguments[6];
} else {
colourStops = [];
}

var start_colour = arguments[4];
if (typeof(start_colour) != "string") {
start_colour = "black";
}

var end_colour = arguments[5];
if (typeof(end_colour) != "string") {
end_colour = "white";
}

colourStops.push([0, start_colour]);
colourStops.push([1, end_colour]);
}
return new LinearGradient(x1, y1, x2, y2, colourStops);
}}$;
}

${{
function LinearGradient(x1, y1, x2, y2, colourStops) {
this.x1 = x1;
this.y1 = y1;
this.x2 = x2;
this.y2 = y2;
this.colourStops = colourStops;
}

LinearGradient.prototype = new EdenUI.plugins.Canvas2D.FillStyle();

LinearGradient.prototype.getColour = function (context) {
var gradient = context.createLinearGradient(this.x1, this.y1, this.x2, this.y2);
var colourStop;
for (var i = 0; i < this.colourStops.length; i++) {
colourStop = this.colourStops[i];
gradient.addColorStop(colourStop[0], colourStop[1]);
}
return gradient;
};

LinearGradient.prototype.toString = function() {
return "LinearGradient(" + Eden.edenCodeForValues(this.x1, this.y1, this.x2, this.y2, this.colourStops) + ")";

};

LinearGradient.prototype.getEdenCode = LinearGradient.prototype.toString;

}}$;


${{
LineSequence = function(vertices, colours, drawingOptions) {
this.vertices = vertices;
this.colours = colours;
this.drawingOptions = drawingOptions;

this.minX = this.vertices[0].x;
this.minY = this.vertices[0].y;
this.maxX = this.minX, this.maxY = this.minY;
for (var i = 1; i < this.vertices.length; i++) {
var vertex = this.vertices[i];
if (vertex.x < this.minX) {
this.minX = vertex.x;
} else if (vertex.x > this.maxX) {
this.maxX = vertex.x;
}
if (vertex.y < this.minY) {
this.minY = vertex.y;
} else if (vertex.y > this.maxY) {
this.maxY = vertex.y;
}
}
}
}}$;

func LineSequence { ${{
var vertices = arguments[0];
var colours, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}
if (processUpTo == 1) {
colours = arguments[1];
}

if (colours === undefined) {
colours = ["black"];
} else if (!Array.isArray(colours)) {
colours = [colours];
} else if (colours.length == 0) {
colours = ["black"];
}

return new LineSequence(vertices, colours, drawingOptions);
}}$; };

${{
LineSequence.prototype.draw = function(context) {
if (this.drawingOptions !== undefined && this.drawingOptions.lineWidth % 2 == 1) {
var scale = this.drawingOptions.lineWidth / context.lineWidth;
context.translate(0.5 / scale, 0.5 / scale);
}

context.beginPath();
var maxVertex = this.vertices.length - 1;
if (this.colours.length == 1) {
context.strokeStyle = this.colours[0];
} else {
var gradient = context.createLinearGradient(this.minX, this.minY, this.maxX, this.maxY);
for (var i = 0; i < this.colours.length; i++) {
gradient.addColorStop(i / (this.colours.length - 1), this.colours[i]);
}
context.strokeStyle = gradient;
}

context.moveTo(this.vertices[0].x, this.vertices[0].y);
for (var i = 1; i <= maxVertex; i++) {
context.lineTo(this.vertices[i].x, this.vertices[i].y);
}

context.stroke();
};

LineSequence.prototype.toString = function() {
var s = "LineSequence(" + Eden.edenCodeForValue(this.vertices) + ",";

if (this.colours.length > 1) {
s = s + Eden.edenCodeForValue(this.colours);
} else {
s = s + Eden.edenCodeForValue(this.colours[0]);
}

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
};

LineSequence.prototype.getEdenCode = LineSequence.prototype.toString;

}}$;


${{
Polygon = function(vertices, fillcolour, outlinecolour, drawingOptions) {
this.vertices = vertices;
this.fillcolour = fillcolour;
this.outlinecolour = outlinecolour;
this.drawingOptions = drawingOptions;
this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Polygon");
this.obsName = root.currentObservableName();
}
}}$;

func Polygon { ${{
var vertices = arguments[0];
if (vertices[0].x != vertices[vertices.length - 1].x || vertices[0].y != vertices[vertices.length - 1].y) {
vertices.push(vertices[0]);
}

var fillcolour, outlinecolour, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !Array.isArray(lastArg) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle) && !Array.isArray(lastArg)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}
if (processUpTo >= 1) {
fillcolour = arguments[1];
if (processUpTo == 2) {
outlinecolour = arguments[2];
}
}

if (outlinecolour === undefined) {
if (fillcolour === undefined) {
outlinecolour = "black";
}
}

return new Polygon(vertices, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

Polygon.prototype.draw = function (context) {
if (this.drawingOptions !== undefined && this.drawingOptions.lineWidth % 2 == 1) {
var scale = this.drawingOptions.lineWidth / context.lineWidth;
context.translate(0.5 / scale, 0.5 / scale);
}

this.tracePath(context);

if (this.fillcolour !== undefined) {
edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
context.fill();
}

if (this.outlinecolour !== undefined) {
context.strokeStyle = this.outlinecolour;
context.stroke();
}
};

Polygon.prototype.tracePath = function (context) {
context.beginPath();
context.moveTo(this.vertices[0].x, this.vertices[0].y);
for (var i = 1; i < this.vertices.length; i++) {
context.lineTo(this.vertices[i].x, this.vertices[i].y);
}
context.closePath();
}

Polygon.prototype.isHit = function (context, scale, x, y) {
this.tracePath(context);
return context.isPointInPath(x,y);
}

Polygon.prototype.toString = function() {
var s = "Polygon(" + Eden.edenCodeForValues(this.vertices, this.fillcolour, this.outlinecolour);

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
};

Polygon.prototype.getEdenCode = Polygon.prototype.toString;

Polygon.prototype.imageMapArea = function () {
var s = "shape=\"poly\" coords=\"";
for (var i = 0; i < this.vertices.length; i++) {
var vertex = this.vertices[i];
s = s + vertex.x + "," + vertex.y + ",";
}
s = s.slice(0, -1);
s = s + "\"";
return s;
}

Polygon.prototype.centre = function () {
var centreX = 0, centreY = 0;
for (var i = 0; i < this.vertices.length; i++) {
centreX = centreX + this.vertices[i].x;
centreY = centreY + this.vertices[i].y;
}
centreX = centreX / this.vertices.length;
centreY = centreY / this.vertices.length;
return new Point(centreX, centreY);
}

}}$;


${{
Rectangle = function(x, y, width, height, fillcolour, outlinecolour, drawingOptions) {
this.x = x;
this.y = y;
this.width = width;
this.height = height;
this.fillcolour = fillcolour;
this.outlinecolour = outlinecolour;
this.drawingOptions = drawingOptions;
this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Rectangle");
this.obsName = root.currentObservableName();
}
}}$;

func Rectangle { ${{
var x = arguments[0];
var y = arguments[1];
var width = arguments[2];
var height = arguments[3];
var fillcolour, outlinecolour, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}
if (processUpTo >= 4) {
fillcolour = arguments[4];
if (processUpTo == 5) {
outlinecolour = arguments[5];
}
}
if (fillcolour === undefined && outlinecolour === undefined) {
outlinecolour = "black";
}

if (drawingOptions !== undefined) {
if (!("join" in drawingOptions) && drawingOptions.lineWidth < 10) {
//Bug in Chrome v44, shape isn't drawn when miter join is used with larger line widths.
drawingOptions.join = "miter"
}
}
return new Rectangle(x, y, width, height, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

Rectangle.prototype.draw = function (context) {
var lineWidth;
if (this.outlinecolour !== undefined) {
lineWidth = context.lineWidth;
} else {
lineWidth = 0;
}
if (this.fillcolour !== undefined) {
edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
context.fillRect(this.x + lineWidth, this.y + lineWidth, this.width - 2 * lineWidth, this.height - 2 * lineWidth);
}
if (this.outlinecolour !== undefined) {
context.strokeStyle = this.outlinecolour;
context.strokeRect(this.x + lineWidth / 2, this.y + lineWidth / 2, this.width - lineWidth, this.height - lineWidth);
}
};

Rectangle.prototype.isHit = function (context, scale, x, y) {
return x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height;
}

Rectangle.prototype.toString = function() {
var s = "Rectangle(" + Eden.edenCodeForValues(this.x, this.y, this.width, this.height, this.fillcolour, this.outlinecolour);

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
};

Rectangle.prototype.getEdenCode = Rectangle.prototype.toString;

Rectangle.prototype.imageMapArea = function () {
return "shape=\"rect\" coords=\"" + this.x + "," + this.y + "," + (this.x + this.width) + "," +
(this.y + this.height) + "\"";
}

Rectangle.prototype.centre = function () {
return new Point(this.x + this.width / 2, this.y + this.height / 2);
}

}}$;


${{
Slider = function(name, min, max, step, x, y, length, orientation, enabled) {
this.name = name;
this.min = min;
this.max = max;
this.step = step;
this.x = x;
this.y = y;
this.length = length;
this.orientation = orientation;
this.enabled = enabled;
}

Slider.prototype.hash = function () {
return this.name+"$$"+
this.min+"$$"+
this.max+"$$"+
this.step+"$$"+
this.x+"$$"+
this.y+"$$"+
this.length+"$$"+
this.orientation+"$$"+
this.enabled;
};
}}$;

func Slider { ${{
var name = root.currentObservableName();
if (name === undefined) {
eden.error(new Error("Slider: Every slider must be defined by making a dependency."), "error");
return undefined;
}
var min = arguments[0];
var max = arguments[1];
var step = arguments[2];
var x = arguments[3];
var y = arguments[4];
var length = arguments[5];
var orientation = arguments[6];
if (orientation === undefined) orientation = "horizontal";
var enabled = arguments[7];
if (enabled === undefined) enabled = true;
return new Slider(name, min, max, step, x, y, length, orientation, enabled);
}}$; }

${{

Slider.prototype.draw = function (context) {

if (this.elements === undefined) {
var name = this.name;
var me = this;
var agent = root.lookup("Slider");

var orientationCSS;
if (this.orientation == "down"){
orientationCSS = "transform: rotate(90deg);"
} else if (this.orientation == "up" || this.orientation == "vertical") {
orientationCSS = "transform: rotate(-90deg);"
} else {
orientationCSS = "";
}
var disabled = this.enabled === false? "disabled=\"disabled\"" : "";
var inputHTML = '<input ' + disabled +
'style="position:absolute; ' + orientationCSS + '" ' +
'type="range" ' +
'min="' + this.min + '" ' +
'max="' + this.max + '" ';
if (this.step !== undefined) {
inputHTML = inputHTML + 'step="' + this.step + '"';
}
inputHTML = inputHTML + '/>';
var jqElement = $(inputHTML);

var valueSym = root.lookup(name + "_value");
var previewSym = root.lookup(name + "_preview");

function setValue(obs, value, force) {
var previewSym = root.lookup(name + "_preview");
var element = me.elements[0];
var previewValue = previewSym.value();
if (previewValue !== value || force) {
var roundedValue;
if (value >= me.min && value <= me.max) {
element.value = value;
roundedValue = parseFloat(element.value);
if (roundedValue != value) {
//Value didn't match the step size.
obs.assign(roundedValue, root.scope, agent);
}
} else {
if (value < me.min) {
element.value = me.min;
} else {
element.value = me.max;
}
if (me.step !== undefined) {
roundedValue = Math.round(((value - me.min) / me.step).toPrecision(16)) * me.step + me.min;
if (roundedValue != value) {
obs.assign(roundedValue, root.scope, agent);
}
} else {
roundedValue = value;
}
}
if (previewValue != roundedValue) {
previewSym.assign(roundedValue, root.scope, Symbol.hciAgent);
}
}
}

valueSym.addJSObserver("updateUI", setValue);
previewSym.addJSObserver("updateUI", function (obs, preview) {
var previewSym = root.lookup(name + "_preview");
var valueSym = root.lookup(name + "_value");
var element = me.elements[0];
if (previewSym.last_modified_by !== Symbol.hciAgent.name) {
var roundedValue;
if (preview >= me.min && preview <= me.max) {
element.value = preview;
roundedValue = parseFloat(element.value);
if (roundedValue != preview) {
//Value didn't match the step size.
obs.assign(roundedValue, root.scope, agent);
}
} else {
if (preview < me.min) {
element.value = me.min;
} else {
element.value = me.max;
}
if (me.step !== undefined) {
roundedValue = Math.round(((preview - me.min) / me.step).toPrecision(16)) * me.step + me.min;
if (roundedValue != value) {
obs.assign(roundedValue, root.scope, agent);
}
} else {
roundedValue = preview;
}
}
valueSym.assign(roundedValue, root.scope, agent);
}
});

jqElement
.on("input", function(){
root.lookup(name + "_preview").assign(parseFloat(this.value), root.scope, Symbol.hciAgent, true);
})
.on("mousedown", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(undefined, root.scope, Symbol.hciAgent, mouseFollow);
})
.on("mouseup", function () {
root.lookup(name + "_value").assign(parseFloat(this.value), Symbol.hciAgent, true);
edenUI.plugins.Canvas2D.endClick();
})
.on("keyup", function () {
root.lookup(name + "_value").assign(parseFloat(this.value), Symbol.hciAgent, true);
})
.on("mouseenter", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
});

this.elements = [jqElement.get(0)];

//Initialization
var value = valueSym.value();
var previewValue = previewSym.value();
if (value === undefined) {
if (previewValue !== undefined) {
valueSym.assign(previewValue, agent);
setValue(valueSym, previewValue, true);
} else {
valueSym.assign(this.min, agent);
}
} else {
setValue(valueSym, value, true);
}
}
};

Slider.prototype.scale = function (scale, zoom, origin) {
var element = this.elements[0];
var style = element.style;
if (this.orientation == "up" || this.orientation == "down" || this.orientation == "vertical") {
style.left = Math.round((this.x - this.length / 2) * scale + origin.x) + "px";
style.top = Math.round((this.y + this.length / 2) * scale + origin.y) + "px";
} else {
style.left = Math.round(this.x * scale + origin.x) + "px";
style.top = Math.round(this.y * scale + origin.y) + "px";
}
var width = Math.round(this.length * scale);
style.width = width + "px";
if (this.step === undefined) {
element.step = String((element.max - element.min) / (width  - 1)).slice(0, 18);
}
};

Slider.prototype.toString = function() {
return "Slider(" + Eden.edenCodeForValues(this.min, this.max, this.step, this.x, this.y,
this.length, this.orientation, this.enabled) + ")";
};

Slider.prototype.getEdenCode = Slider.prototype.toString;

}}$;


${{
Text = function(text, x, y, size, sizeUnits, fillcolour, outlinecolour, options) {
this.text = text;
this.x = x;
this.y = y;
this.size = size;
this.sizeUnits = sizeUnits;
this.fillcolour = fillcolour;
this.outlinecolour = outlinecolour;

//See also (below): this.css, this.font, this.optionString
var css;

if (options instanceof Object) {
if (!("valign" in options)) {
options.valign = "top";
}
this.drawingOptions = options;

if (options.italic) {
css = "italic ";
} else {
css = "";
}
if (options.smallCaps) {
css = css + "small-caps ";
}
if (options.bold) {
css = css + "bold ";
}
if (options.fontFace === undefined) {
this.font = "sans-serif";
} else {
this.font = options.fontFace;
}

} else if (typeof(options) == "string") {
this.optionString = options;
var valignRE = /\b(top|hanging|middle|baseline|alphabetic|ideographic|bottom)\b/;
var searchResults = valignRE.exec(options);
if (searchResults === null) {
this.drawingOptions = {valign: "top"};
} else {
this.drawingOptions = {valign: searchResults[0]};
options = options.replace(valignRE, "");
}
var halignRE = /\b(left|right|center|centre|start|end)\b/;
searchResults = halignRE.exec(options);
if (searchResults !== null) {
this.drawingOptions.align = searchResults[0];
options = options.replace(halignRE, "");
}
css = options + " sans-serif";
this.sizeUnits = undefined;
} else {
css = "";
this.font = "sans-serif";
this.drawingOptions = {valign: "top"};
}
if (this.drawingOptions.align == "centre") {
this.drawingOptions.align = "center";
}
if (this.drawingOptions.valign == "baseline") {
this.drawingOptions.valign = "alphabetic";
}
this.css = css;
this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(options, "Text");
this.obsName = root.currentObservableName();
}
}}$;

func Text {
${{
var text = arguments[0];
var x = arguments[1];
var y = arguments[2];
var size, sizeUnits, fillcolour, outlinecolour, options;
var numArgs = arguments.length;
var argType = typeof(arguments[numArgs - 1]);
if (argType == "string" && arguments[numArgs - 1].indexOf(" ") !== -1) {
options = arguments[numArgs - 1];
if (numArgs >= 5) {
fillcolour = arguments[3];
if (numArgs >= 6) {
outlinecolour = arguments[5];
}
}
} else if (argType == "object" && !(arguments[numArgs - 1] instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
options = arguments[numArgs - 1];
if (numArgs >= 5) {
size = arguments[3];
if (numArgs >= 6) {
fillcolour = arguments[4];
if (numArgs >= 7) {
outlinecolour = arguments[5];
}
}
}
} else {
size = arguments[3];
fillcolour = arguments[4];
outlinecolour = arguments[5];
options = arguments[6];
}

if (size === undefined) {
size = 13.3;
sizeUnits = "px";
} else if (typeof(size) == "number") {
sizeUnits = "px";
} else {
var match = /^(\d*(\.\d*)?)([a-z%]*)$/.exec(size);
size = parseFloat(match[1]);
sizeUnits = match[3];
}
if (outlinecolour === undefined && fillcolour === undefined) {
fillcolour = "black";
}
return new Text(text, x, y, size, sizeUnits, fillcolour, outlinecolour, options);
}}$;
}

${{

Text.prototype.draw = function (context, scale) {

if (this.sizeUnits === undefined) {
context.font = this.css;
} else {
context.font = this.css + (this.size / scale) + this.sizeUnits + " " + this.font;
}
context.textBaseline = this.drawingOptions.valign;
if ("align" in this.drawingOptions) {
context.textAlign = this.drawingOptions.align;
}
var x = this.x + context.lineWidth / 2 + 1 / scale;
var y = this.y + 1 / scale;

if (this.fillcolour !== undefined) {
edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
context.fillText(this.text, x, y);
}
if (this.outlinecolour !== undefined) {
context.strokeStyle = this.outlinecolour;
context.strokeText(this.text, x, y);
}
};

Text.prototype.isHit = function (context, scale, px, py) {
var x = this.x + 1 / scale;
var y = this.y + 1 / scale;
var width, height;

if (this.width === undefined) {
var fontCSS;
if (this.sizeUnits === undefined) {
fontCSS = this.css;
} else {
fontCSS = this.css + this.size + this.sizeUnits + " " + this.font;
}
var div = document.createElement("div");
div.innerHTML = this.text;
div.style.position = 'absolute';
div.style.top  = '-9999px';
div.style.font = fontCSS;
document.body.appendChild(div);
this.width = div.offsetWidth;
this.height = div.offsetHeight;
document.body.removeChild(div);
}

var lineWidth = context.lineWidth;
width = this.width / scale + lineWidth;
height = this.height / scale + lineWidth / 2;

return px >= x && px < x + width && py >= y && py < y + height;
}

Text.prototype.toString = function() {
var s = "Text(" + Eden.edenCodeForValues(this.text, this.x, this.y) + ", ";

if (this.optionString !== undefined) {
s = s + Eden.edenCodeForValues(this.fillcolour, this.outlinecolour) + ", " +
"\"" + this.optionString + "\")";
} else {
s = s + '"' + this.size + this.sizeUnits + '", ' +
Eden.edenCodeForValues(this.fillcolour, this.outlinecolour, this.drawingOptions) + ")";
}
return s;
};

Text.prototype.getEdenCode = Text.prototype.toString;

Text.parseArgs = function () {
var text = arguments[0];

var size, sizeUnits, options, optionsObj, scale;
if (typeof(arguments[1]) == "object") {
options = arguments[1];
} else {
var size = arguments[1];
if (typeof(arguments[2]) == "number") {
scale = arguments[2];
} else {
options = arguments[2];
scale = arguments[3];
if (size !== undefined && typeof(options) == "string") {
eden.error(new Error("textWidth/textHeight: The size argument must be @ when the options parameter is given as a string.  The font size should be included in the options string.  See https://drafts.csswg.org/css2/fonts.html#font-shorthand"), "error");
return undefined;
}
}
}

if (size === undefined) {
size = 13.3;
sizeUnits = "px";
} else if (typeof(size) == "number") {
sizeUnits = "px";
} else if (scale !== undefined) {
var match = /^(\d*(\.\d*)?)([a-z%]*)$/.exec(size);
if (match === null) {
eden.error(new Error("textWidth/textHeight: Giving the options parameter as a string is not supported when the scale parameter is used."), "error");
return undefined;
} else {
size = parseFloat(match[1]) / scale;
sizeUnits = match[3];
}
} else {
sizeUnits = "";
}
if (scale === undefined) {
scale = 1;
}

var css;
if (options instanceof Object) {
optionsObj = options;
if (options.italic) {
css = "italic ";
} else {
css = "";
}
if (options.smallCaps) {
css = css + "small-caps ";
}
if (options.bold) {
css = css + "bold ";
}
css = css + size + sizeUnits + " ";
if (options.fontFace === undefined) {
css = css + "sans-serif";
} else {
css = css + options.fontFace;
}
} else if (typeof(options) == "string") {
options = options.replace(/\b(top|hanging|middle|baseline|alphabetic|ideographic|bottom|left|right|center|centre|start|end)\b\s*/g, "");
css = options + " sans-serif";
optionsObj = {};
} else {
css = size + sizeUnits + " sans-serif";
optionsObj = {};
}
return [css, optionsObj, scale];
};

}}$;

func textWidth {
${{
var text = arguments[0];
var options = Text.parseArgs.apply(undefined, arguments);
var css = options[0];
var optionsObj = options[1];
var scale = options[2];

//Find an existing canvas (any one).
var canvas;
for (var canvasName in canvases) {
canvas =  canvases[canvasName];
break;
}

var context = canvas.getContext("2d");
context.save();
edenUI.plugins.Canvas2D.configureContextDefaults(context, 1);
edenUI.plugins.Canvas2D.configureContext(context, 1, 1, optionsObj);
context.font = css;
context.textBaseline = "top";
var metrics = context.measureText(text);
var width = metrics.width + context.lineWidth + 2 / scale;
context.restore();
return width;
}}$;
}

func textHeight {
${{
var text = arguments[0];
var options = Text.parseArgs.apply(undefined, arguments);
var fontCSS = options[0];
var optionsObj = options[1];
var scale = options[2];

var lineWidth = optionsObj.lineWidth;
if (lineWidth === undefined) {
lineWidth = 2;
}

var div = document.createElement("div");
div.innerHTML = text;
div.style.position = 'absolute';
div.style.top  = '-9999px';
div.style.font = fontCSS;
document.body.appendChild(div);
var height = div.offsetHeight;
document.body.removeChild(div);
return height + lineWidth / 2 + 2 / scale;
}}$;
}


${{
Pixel = function(x, y, colour) {
this.x = x;
this.y = y;
this.colour = colour;
}
}}$;

func Pixel { ${{
var x = arguments[0];
var y = arguments[1];
var colour = arguments[2];
return new Pixel(x, y, colour);
}}$; };

${{
Pixel.prototype.toString = function() {
return "Pixel("+ Eden.edenCodeForValues(this.x, this.y, this.colour) + ")";
};

Pixel.prototype.getEdenCode = Pixel.prototype.toString;
}}$;

${{
Pixel.prototype.draw = function(context) {
context.fillStyle = this.colour;
context.fillRect( this.x, this.y, 1, 1);
};
}}$;

/*
func colourMap {
para b;
auto data, i, j;
data = [];
for (j = 0; j <= 255; j++) {
for (i = 0; i <= 255; i++) {
append data, i;
append data, j;
append data, b;
append data, 255;
}
}
return data;
}

blue = 50;
pixelData is colourMap(blue);
pixels is PixelList(&pixelData, 20, 20, 256);
picture is [pixels];
*/

func PixelList {
${{
var name;
var argsProcessed;
if (typeof(arguments[0]) == "string") {
name = arguments[0];
argsProcessed = 1;
} else {
argsProcessed = 0;
}
var ptrToData = arguments[argsProcessed];
argsProcessed++;
var x = arguments[argsProcessed];
argsProcessed++;
var y = arguments[argsProcessed];
argsProcessed++;
var width = arguments[argsProcessed];
argsProcessed++;
return new PixelList(name, ptrToData, x, y, width);
}}$;
}

${{
function PixelList(name, ptrToData, x, y, width) {
this.name = edenUI.plugins.Canvas2D.initZoneFromName(name, "PixelList");
this.obsName = root.currentObservableName();

this.data = ptrToData.value();
this.x = x;
this.y = y;
this.width = width;
this.height = this.data.length / (4 * width);
}

PixelList.prototype.draw = function (context) {
var imageData = context.createImageData(this.width, this.height);
var imageArr = imageData.data;
var dataArr = this.data;
var arrayLen = dataArr.length;
for (var i = 0; i < arrayLen; i++) {
imageArr[i] = dataArr[i];
}
context.putImageData(imageData, this.x, this.y);
}

PixelList.prototype.isHit = function (context, scale, x, y) {
return x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height;
}

PixelList.prototype.toString = function() {
return "PixelList(" + Eden.edenCodeForValue(this.name) + ", " +
String(this.data.length / 4) + " pixel values, " +
Eden.edenCodeForValues(this.x, this.y, this.width) + ")";
}

PixelList.prototype.getEdenCode = function() {
return "PixelList(" + Eden.edenCodeForValues(this.name, this.data, this.x, this.y, this.width) + ")";
}

}}$;



func RadialGradient {
${{
var x1, y1, r1, x2, y2, r2, colourStops;
x1 = arguments[0];
y1 = arguments[1];

switch (arguments.length) {
case 4:
r1 = 0;
x2 = x1;
y2 = y1;
r2 = arguments[2];
colourStops = arguments[3];
break;
}
return new RadialGradient(x1, y1, r1, x2, y2, r2, colourStops);
}}$;
}

${{
function RadialGradient(x1, y1, r1, x2, y2, r2, colourStops) {
this.x1 = x1;
this.y1 = y1;
this.r1 = r1;
this.x2 = x2;
this.y2 = y2;
this.r2 = r2;
this.colourStops = colourStops;
}

RadialGradient.prototype = new EdenUI.plugins.Canvas2D.FillStyle();

RadialGradient.prototype.getColour = function (context) {
var gradient = context.createRadialGradient(this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);
var colourStop;
for (var i = 0; i < this.colourStops.length; i++) {
colourStop = this.colourStops[i];
gradient.addColorStop(colourStop[0], colourStop[1]);
}
return gradient;
};

RadialGradient.prototype.toString = function() {
return "RadialGradient(" + Eden.edenCodeForValues(this.x1, this.y1, this.r1, this.x2, this.y2, this.r2, this.colourStops) + ")";

};

RadialGradient.prototype.getEdenCode = RadialGradient.prototype.toString;

}}$;

${{
RadioButtons = function (name, buttonValues, x, y, enabled, horizontal){
this.name = name;
this.buttonValues = buttonValues;
this.x = x;
this.y = y;
this.enabled = enabled;
this.horizontal = horizontal;
}

RadioButtons.prototype.hash = function () {
return this.name+"$$"+
this.buttonValues.join("$$")+
this.x+"$$"+
this.y+"$$"+
this.enabled+"$$"+
this.horizontal;
};
}}$;

func RadioButtons { ${{
var name = root.currentObservableName();
if (name === undefined) {
eden.error(new Error("RadioButtons: Every set of radio buttons must be defined by making a dependency."), "error");
return undefined;
}
var buttonValues = arguments[0];
var x = arguments[1];
var y = arguments[2];
var enabled = arguments[3];
var horizontal = arguments[4];
return new RadioButtons(name, buttonValues, x, y, enabled, horizontal);
}}$; }

${{

RadioButtons.prototype.makeHTML = function() {
var build = "";

for (var i = 0; i < this.buttonValues.length; i++) {
build = build + "<input type=\"radio\" name=\"" + this.name + "\" value=\"" + this.buttonValues[i] + "\">" + this.buttonValues[i] + "<br/>";
}


if (this.horizontal) {
return "<form style=\"position: absolute; display: inline-flex\">" +
build + "</form>";
} else {
return "<form style=\"position: absolute\">" +
build + "</form>";
}
};

RadioButtons.prototype.draw = function (context) {

if(this.elements === undefined) {
var name = this.name;

//Make the HTML
var formJQ = $(this.makeHTML());

var formElement = formJQ.get(0);
var updateValue = function (buttonGroup, value) {
for (var i = 0; i < buttonGroup.length; i++) {
if (buttonGroup[i].value == value) {
buttonGroup[i].checked = true;
break;
} else {
//Possibility of having no radio button selected.
buttonGroup[i].checked = false;
}
}

};
var valueSym = root.lookup(name + "_value");
var initialValue = valueSym.value();
if (initialValue !== undefined) {
updateValue(formElement.elements, initialValue);
}
valueSym.addJSObserver("updateUI", function (symbol, value) {
updateValue(formElement.elements, value);
});

formJQ.change(function(event) {
root.lookup(name + "_value").assign(event.target.value, root.scope, Symbol.hciAgent, true);
})
.on("mousedown", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(undefined, root.scope, Symbol.hciAgent, mouseFollow);
})
.on("mouseup", function () {
edenUI.plugins.Canvas2D.endClick();
})
.on("mouseenter", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
});

this.elements = [formElement];
}
};

RadioButtons.prototype.scale = function (scale, zoom, origin) {
var elem = this.elements[0];
var style = elem.style;
style.left = Math.round(this.x * scale + origin.x) + "px";
style.top = Math.round(this.y * scale + origin.y) + "px";
style.fontSize = zoom + "em";
var buttonSize = Math.round(13 * zoom) + "px";
$(elem).find("input").css({width: buttonSize, height: buttonSize});
};

RadioButtons.prototype.toString = function() {
return "RadioButtons(" + Eden.edenCodeForValues(this.buttonValues, this.x, this.y, this.enabled, this.horizontal) + ")";
};

RadioButtons.prototype.getEdenCode = RadioButtons.prototype.toString;

}}$;

${{
RegularPolygon = function (x, y, r, n, star, rotation, interiorOutline, fillcolour, outlinecolour, drawingOptions) {
this.x = x;
this.y = y;
this.r = r;
this.n = n;
this.star = star;
this.interiorOutline = interiorOutline;
this.rotation = rotation;
this.fillcolour = fillcolour;
this.outlinecolour = outlinecolour;
this.drawingOptions = drawingOptions;
this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "RegularPolygon");
this.obsName = root.currentObservableName();

this.exteriorAngle = (2 * Math.PI) / n;
this.vertices = [];
var pointsDone = new Array(n);
var px, py;
var currentPolygonVertices, currentPoint;
var nudge;
if (drawingOptions !== undefined && drawingOptions.valign == "bottom") {
if (drawingOptions.lineWidth !== undefined) {
nudge = drawingOptions.lineWidth;
} else {
nudge = 2;
}
} else {
nudge = 0;
}
var rotation2 = -rotation - Math.PI * (0.5 - 2 / n); //Zero rotation means "pointing upwards"
for (var i = 0; i < n; i++) {
var j = i;
currentPolygonVertices = [];
while (pointsDone[j] !== true) {
px = x + r * Math.cos(rotation2 + j * this.exteriorAngle);
py = y + r * Math.sin(rotation2 + j * this.exteriorAngle) + nudge;
currentPoint = new Point(px, py);
currentPolygonVertices.push(currentPoint);
pointsDone[j] = true;
j = (j + star) % n;
}
if (currentPolygonVertices.length > 0) {
this.vertices = this.vertices.concat(currentPolygonVertices);
}
}
}

RegularPolygon.prototype.calculatePolygons = function (lineWidth) {
var separatePolygonsPossiblyNeeded;
if (this.fillcolour !== undefined && this.fillcolour != "transparent" &&
this.outlinecolour !== undefined &&
this.n / this.star != 2
) {
separatePolygonsPossiblyNeeded = true;
} else {
separatePolygonsPossiblyNeeded = false;
}

var radius = this.r - lineWidth / 2;
var rotation = -this.rotation - Math.PI * (0.5 - 2 / this.n);
var nudge;
if (this.drawingOptions !== undefined && this.drawingOptions.valign == "bottom") {
nudge = lineWidth;
} else {
nudge = 0;
}

var pointsDone = new Array(this.n);
var px, py;
var polygons = [];
var currentPolygonVertices, currentPoint;
for (var i = 0; i < this.n; i++) {
var j = i;
currentPolygonVertices = [];
while (pointsDone[j] !== true) {
px = this.x + radius * Math.cos(rotation + j * this.exteriorAngle);
py = this.y + radius * Math.sin(rotation + j * this.exteriorAngle) + nudge;
currentPoint = new Point(px, py);
currentPolygonVertices.push(currentPoint);
pointsDone[j] = true;
j = (j + this.star) % this.n;
}
if (currentPolygonVertices.length > 0) {
polygons.push(new Polygon(currentPolygonVertices, this.fillcolour, this.outlinecolour, this.drawingOptions));
}
}
if (separatePolygonsPossiblyNeeded) {
if (polygons.length == 1) {
if (!this.interiorOutline) {
/* Case: single constituent polygon (e.g. five-pointed star) with an outline but
* not an outline drawn in inside the shape (i.e. a star or a pentagon rather
* than a pentagram).
* Solution: add extra polygons to over-paint those inside edges that we don't want.
* N.B. We can (and do) safely ignore these extra polygons when performing hit testing.
*/
var smallerRadius = this.r - lineWidth;
currentPolygonVertices = [];
i = 0;
do {
px = this.x + smallerRadius * Math.cos(rotation + i * this.exteriorAngle);
py = this.y + smallerRadius * Math.sin(rotation + i * this.exteriorAngle);
currentPoint = new Point(px, py);
currentPolygonVertices.push(currentPoint);
i = (i + this.star) % this.n;
} while (i != 0);
polygons.push(new Polygon(currentPolygonVertices, this.fillcolour, undefined, this.drawingOptions));
} else {
/* Case: the user wants to see the edges that intersect the interior of the
* polygon.
*/
}
this.filledPolygons = polygons;
this.outlinePolygons = [];
} else {
/* Case: multiple constituent polygons (specifically, more than 2).  Occurs when
* n / star is an integer greater than 2.
* Solution: Paint the fill and the outline as separate polygons.  The requirement
* to show or hide the interior edges determines whether the outlines are painted
* first or the fill is painted first.
*/
this.filledPolygons = [];
this.outlinePolygons = [];
for (var i = 0; i < polygons.length; i++) {
this.filledPolygons.push(new Polygon(polygons[i].vertices, this.fillcolour, undefined, this.drawingOptions));
}
for (var i = 0; i < polygons.length; i++) {
this.outlinePolygons.push(new Polygon(polygons[i].vertices, undefined, this.outlinecolour, this.drawingOptions));
}
}
} else {
/* Case: the outline doesn't have intersecting edges (or only degenerate ones, i.e. n / star = 2),
* or doesn't have an outline, or doesn't have a fill colour.
* N.B: n / star = 2 is the degenerate case when a polygon is reduced to being a set of unconnected lines.
* Solution: One set of polygons that paint either the fill or the outline (the shape doesn't have both).
*/
this.filledPolygons = polygons;
this.outlinePolygons = [];
}
}
}}$;

func RegularPolygon {
${{
var x = arguments[0];
var y = arguments[1];
var r = arguments[2];
var n = arguments[3];
var star = 1, rotation = 0, interiorOutline = true;
var fillcolour, outlinecolour, drawingOptions;
var argsProcessed = 4;
if (typeof(arguments[4]) == "number") {
star = arguments[4];
argsProcessed++;
}
if (typeof(arguments[argsProcessed]) == "boolean") {
interiorOutline = arguments[argsProcessed];
argsProcessed++;
}
if (typeof(arguments[argsProcessed]) == "number") {
rotation = arguments[argsProcessed] * root.lookup("radiansPerUnit").value();
argsProcessed++;
}

var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}
if (processUpTo >= argsProcessed) {
fillcolour = arguments[argsProcessed];
argsProcessed++;
if (processUpTo == argsProcessed) {
outlinecolour = arguments[argsProcessed];
}
}

if (outlinecolour === undefined) {
if (fillcolour === undefined) {
outlinecolour = "black";
}
}

if (drawingOptions !== undefined) {
if (!("join" in drawingOptions)) {
drawingOptions.join = "round";
}
}
return new RegularPolygon(x, y, r, n, star, rotation, interiorOutline, fillcolour, outlinecolour, drawingOptions);
}}$;
}
radiansPerUnit ~> [RegularPolygon];

${{
RegularPolygon.prototype.draw = function (context) {
var lineWidth = context.lineWidth;
if (!this.interiorOutline) {
lineWidth = lineWidth * 2;
}
if (this.outlinecolour !== undefined) {
if (lineWidth !== this.cachedPolygonLineWidth) {
this.calculatePolygons(lineWidth);
this.cachedPolygonLineWidth = lineWidth;
}
}

if (this.interiorOutline) {
for (var i = 0; i < this.filledPolygons.length; i++) {
this.filledPolygons[i].draw(context);
}
for (var i = 0; i < this.outlinePolygons.length; i++) {
this.outlinePolygons[i].draw(context);
}
} else {
context.lineWidth = lineWidth;
for (var i = 0; i < this.outlinePolygons.length; i++) {
this.outlinePolygons[i].draw(context);
}
context.lineWidth = lineWidth / 2;
for (var i = 0; i < this.filledPolygons.length; i++) {
this.filledPolygons[i].draw(context);
}
}
}

RegularPolygon.prototype.isHit = function (context, scale, x, y) {
var hit;
var ratio = this.n / this.star;
var limit;
if (this.fillcolour !== undefined && this.fillcolour != "transparent" &&
this.outlinecolour !== undefined &&
ratio != 2 &&
(this.star == 1 || ratio != Math.floor(ratio)) &&
!this.interiorOutline
) {
limit = this.filledPolygons.length / 2;
} else {
limit = this.filledPolygons.length;
}
for (var i = 0; i < limit; i++) {
hit = this.filledPolygons[i].isHit(context, scale, x, y);
if (hit) {
return true;
}
}
return false;
};

RegularPolygon.prototype.toString = function () {
var s = "RegularPolygon(" + Eden.edenCodeForValues(this.x, this.y, this.r, this.n, this.star,
this.interiorOutline, this.rotation, this.fillcolour, this.outlinecolour);

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}
s = s + ")";
return s;
}

RegularPolygon.prototype.getEdenCode = RegularPolygon.prototype.toString;

RegularPolygon.prototype.imageMapArea = function () {
return this.filledPolygons[0].imageMapArea();
}

RegularPolygon.prototype.centre = function () {
return new Point(this.x, this.y);
}

}}$;


${{
RoundedRectangle = function(x, y, width, height, radius, fillcolour, outlinecolour, drawingOptions) {
this.x1 = x;
this.y1 = y;
this.x2 = x + width;
this.y2 = y + height;
this.radius = radius;
this.fillcolour = fillcolour;
this.outlinecolour = outlinecolour;
this.drawingOptions = drawingOptions;
this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "RoundedRectangle");
this.obsName = root.currentObservableName();
}
}}$;

func RoundedRectangle { ${{
var x = arguments[0];
var y = arguments[1];
var width = arguments[2];
var height = arguments[3];
var radius = arguments[4];
var fillcolour, outlinecolour, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}
if (processUpTo >= 5) {
fillcolour = arguments[5];
if (processUpTo == 6) {
outlinecolour = arguments[6];
}
}
if (fillcolour === undefined && outlinecolour === undefined) {
outlinecolour = "black";
}
return new RoundedRectangle(x, y, width, height, radius, fillcolour, outlinecolour, drawingOptions);
}}$; };

${{

RoundedRectangle.prototype.draw = function (context) {

this.tracePath(context);

if (this.fillcolour !== undefined) {
edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
context.fill();
}
if (this.outlinecolour !== undefined) {
context.strokeStyle = this.outlinecolour;
context.stroke();
}
};

RoundedRectangle.prototype.tracePath = function (context) {
var halfLineWidth;
if (this.outlinecolour !== undefined) {
halfLineWidth = context.lineWidth / 2;
} else {
halfLineWidth = 0;
}
var x1 = this.x1 + halfLineWidth;
var x2 = this.x2 - halfLineWidth;
var y1 = this.y1 + halfLineWidth;
var y2 = this.y2 - halfLineWidth;

context.beginPath();
context.moveTo(x1 + this.radius, y1);
context.lineTo(x2 - this.radius, y1);
context.arcTo(x2, y1, x2, y1 + this.radius, this.radius);
context.lineTo(x2, y2 - this.radius);
context.arcTo(x2, y2, x2 - this.radius, y2, this.radius);
context.lineTo(x1 + this.radius, y2);
context.arcTo(x1, y2, x1, y2 - this.radius, this.radius);
context.lineTo(x1, y1 + this.radius);
context.arcTo(x1, y1, x1 + this.radius, y1, this.radius);
context.closePath();
};

RoundedRectangle.prototype.isHit = function (context, scale, x, y) {
this.tracePath(context);
return context.isPointInPath(x,y);
}

RoundedRectangle.prototype.toString = function() {
var s = "RoundedRectangle(" + Eden.edenCodeForValues(this.x1, this.y1) + ", ";

if (this.x2 === undefined || this.x1 === undefined) {
s = s + "@, ";
} else {
s = s + String(this.x2 - this.x1) + ", ";
}
if (this.y2 === undefined || this.y1 === undefined) {
s = s + "@, ";
} else {
s = s + String(this.y2 - this.y1) + ", ";
}
s = s + Eden.edenCodeForValues(this.radius, this.fillcolour, this.outlinecolour);

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
};

RoundedRectangle.prototype.getEdenCode = RoundedRectangle.prototype.toString;

}}$;


${{
Sector = function(x, y, r, sAngle, eAngle, fillcolour, outlinecolour,drawingOptions) {
this.x = x;
this.y = y;
this.r = r;
this.sAngle = sAngle;
this.eAngle = eAngle;
var radiansPerUnit = root.lookup("radiansPerUnit").value();
this.sRadians = sAngle * radiansPerUnit;
this.eRadians = eAngle * radiansPerUnit;

this.fillcolour = fillcolour;
this.outlinecolour = outlinecolour;
this.drawingOptions = drawingOptions;
this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Sector");
this.obsName = root.currentObservableName();
}
}}$;

func Sector { ${{
var x = arguments[0];
var y = arguments[1];
var r = arguments[2];
var sAngle = arguments[3];
var eAngle = arguments[4];
var fillcolour, outlinecolour, drawingOptions;
var lastArg = arguments[arguments.length - 1];
var processUpTo;
if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
drawingOptions = lastArg;
processUpTo = arguments.length - 2;
} else {
processUpTo = arguments.length - 1;
}
if (processUpTo >= 5) {
fillcolour = arguments[5];
if (processUpTo == 6) {
outlinecolour = arguments[6];
}
}
if (fillcolour === undefined && outlinecolour === undefined) {
fillcolour = "black";
}
return new Sector(x, y, r, sAngle, eAngle, fillcolour, outlinecolour, drawingOptions);
}}$; };
radiansPerUnit ~> [Sector];

${{

Sector.prototype.draw = function (context) {

this.tracePath(context);

if (this.fillcolour !== undefined) {
edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
context.fill();
}
if (this.outlinecolour !== undefined) {
context.strokeStyle = this.outlinecolour;
context.stroke();
}
};

Sector.prototype.tracePath = function (context) {
var anticlockwise;
if (this.drawingOptions !== undefined && "direction" in this.drawingOptions) {
switch (this.drawingOptions.direction) {
case "anticlockwise":
case "acw":
case "ccw":
anticlockwise = true;
break;
case "auto":
anticlockwise = this.sAngle < this.eAngle;
break;
case "clockwise":
case "cw":
anticlockwise = false;
break;
default:
//Invalid value specified.
anticlockwise = true;
}
} else {
//Default to "auto"
anticlockwise = this.sAngle < this.eAngle;
}

var radius;
if (this.outlinecolour === undefined) {
radius = this.r;
} else if (this.drawingOptions !== undefined && this.drawingOptions.lineWidth % 2 == 1) {
var scale = this.drawingOptions.lineWidth / context.lineWidth;
context.translate(0.5 / scale, 0.5 / scale);
radius = this.r - 0.5 * context.lineWidth + 0.5 / scale;
} else {
radius = this.r - 0.5 * context.lineWidth;
}

context.beginPath();
context.arc(this.x, this.y, radius, -this.sRadians, -this.eRadians, anticlockwise);
context.lineTo(this.x, this.y);
context.closePath();
};

Sector.prototype.isHit = function (context, scale, x, y) {
this.tracePath(context);
return context.isPointInPath(x,y);
}

Sector.prototype.toString = function() {
var s = "Sector(" + Eden.edenCodeForValues(this.x, this.y, this.r, this.sAngle, this.eAngle, this.fillcolour, this.outlinecolour);

if (this.drawingOptions !== undefined) {
s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
}

s = s + ")";
return s;
}

Sector.prototype.getEdenCode = Sector.prototype.toString;

}}$;


func Shadow {
${{
var colour, blur, xOffset, yOffset, scale;
var argsProcessed;
if (typeof(arguments[0]) == "string") {
colour = arguments[0];
argsProcessed = 1;
} else {
argsProcessed = 0;
}
if (colour == undefined) {
colour = "black";
}

xOffset = arguments[argsProcessed];
argsProcessed++;
yOffset = arguments[argsProcessed];
argsProcessed++;
blur = arguments[argsProcessed];
argsProcessed++;
scale = arguments[argsProcessed];
return new Shadow(colour, xOffset, yOffset, blur, scale);
}}$;
}

${{
function Shadow(colour, xOffset, yOffset, blur, scale) {
this.colour = colour;
this.blur = blur;
this.xOffset = xOffset;
this.yOffset = yOffset;
this.scale = scale;
}

Shadow.prototype.toString = function() {
return "Shadow(" + Eden.edenCodeForValues(this.colour, this.xOffset, this.yOffset, this.blur, this.scale) + ")";
}

Shadow.prototype.getEdenCode = Shadow.prototype.toString;

}}$;

${{
Textbox = function (name, x, y, width, height, placeholder, enabled) {
this.name = name;
this.x = x;
this.y = y;
this.width = width;
this.height = height;
this.placeholder = placeholder;
this.enabled = enabled;
}

Textbox.prototype.hash = function () {
return this.name+"$$"+
this.x+"$$"+
this.y+"$$"+
this.width+"$$"+
this.height+"$$"+
this.placeholder+"$$"+
this.enabled;
};
}}$;

func Textbox { ${{
var name = root.currentObservableName();
if (name === undefined) {
eden.error(new Error("Textbox: Every text box must be defined by making a dependency."), "error");
return undefined;
}
var x = arguments[0];
var y = arguments[1];
var width = arguments[2];
var height, placeholder, enabled;
var argsProcessed = 3;
var arg = arguments[argsProcessed];
var argType = typeof(arg);
if (arg === undefined || argType == "number") {
height = arg;
argsProcessed++;
arg = arguments[argsProcessed];
argType = typeof(arg);
}
if (arg === undefined || argType == "string") {
placeholder = arg;
argsProcessed++;
arg = arguments[argsProcessed];
}
enabled = arg;
return new Textbox(name, x, y, width, height, placeholder, enabled);
}}$; }

${{
Textbox.prototype.draw = function(context) {

if(this.elements === undefined) {
var me = this;
var name = this.name;

var disabled = this.enabled === false? 'disabled="disabled"' : '';
var placeholder = ' placeholder="' + (this.placeholder === undefined? name : this.placeholder) + '"';
var jQuery;
if (this.height === undefined) {
jQuery = $('<input ' + disabled + placeholder + ' style="position: absolute" />');
} else {
jQuery = $('<textarea ' + disabled + placeholder + ' style="position: absolute"></textarea>');
}

var element = jQuery.get(0);
var valueSymbol = root.lookup(name + "_value");
var value = valueSymbol.value();
if (value === undefined) {
valueSymbol.assign("", root.scope, root.lookup("Textbox"));
} else {
element.value = value;
}
valueSymbol.addJSObserver("updateTextbox", function (obs, value) {
me.elements[0].value = value;
});

jQuery
.on("input", function(event) {
root.lookup(name + "_value").assign(event.target.value, root.scope, Symbol.hciAgent, true);
})
.on("mousedown", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseDownZone").assign(undefined, root.scope, Symbol.hciAgent, mouseFollow);
})
.on("mouseup", function () {
edenUI.plugins.Canvas2D.endClick();
})
.on("mouseenter", function () {
var mouseFollow = root.lookup("mouseFollow").value();
root.lookup("mouseZone").assign(name, root.scope, Symbol.hciAgent, mouseFollow);
});

this.elements = [element];
}
};

Textbox.prototype.scale = function (scale, zoom, origin) {
var style = this.elements[0].style;
style.left = Math.round(this.x * scale + origin.x) + "px";
style.top = Math.round(this.y * scale + origin.y) + "px";
style.width = Math.round(this.width * scale - 6) + "px";
var lineHeight = edenUI.plugins.Canvas2D.defaultLineHeight;
var rows = Math.floor(Math.round(this.height * scale - 6) / (lineHeight * zoom));	//See css/eden.css
if (rows == 0) {
rows = 1;
}
style.height = (rows * lineHeight * zoom) + "px";
style.fontSize = (edenUI.plugins.Canvas2D.defaultFontSizePx * zoom) + "px";
};

Textbox.prototype.toString = function() {
return "Textbox(" + Eden.edenCodeForValues(this.x, this.y, this.width, this.height, this.placeholder, this.enabled) + ")";
};

Textbox.prototype.getEdenCode = Textbox.prototype.toString;

}}$;



/*
vid_url = "...";
vid = Video("vid");
picture is [vid];

exercisePoints = [60];
exercisesCompleted = [false];
exerciseNumber is indexOf(int(vid_time), exercisePoints);
vid_controls is exerciseNumber == 0 || exercisesCompleted[exerciseNumber];
vid_paused is vid_controls == false;
*/

func Video {
${{
var name = root.currentObservableName();
if (name === undefined) {
eden.error(new Error("Video: Every video must be defined by making a dependency."), "error");
return undefined;
}
var preload = arguments[0];
return new Video(name, preload);
}}$;
}

${{
function Video(name, preload) {
this.name = name;
this.preload = preload;

Object.defineProperty(this, "duration", {
enumerable: true,
get: function () {
if (this.elements === undefined) {
return 0;
} else {
return Math.floor(this.elements[0].duration * 10) / 10;
}
}
});

Object.defineProperty(this, "ended", {
enumerable: true,
get: function () {
if (this.elements === undefined) {
return false;
} else {
return this.elements[0].ended;
}
}
});

}

Video.prototype.hash = function () {
return this.name;
}
}}$;

${{
Video.prototype.draw = function (context) {
if (this.elements === undefined ) {
var me = this;
var name = this.name;
var agent = root.lookup("Video");


//Chapters

var chapterMarks, chapterNames, chapterIndex, nextChapterAt;
var setChapters = function (symbol, chapters) {
chapterMarks = [];
chapterNames = [];
chapterIndex = -1;
nextChapterAt = undefined;

if (chapters instanceof Object) {
for (var chapterName in chapters) {
if (chapters.hasOwnProperty(chapterName)) {
var beginsAt = chapters[chapterName];
var i = 0;
while (i < chapterMarks.length) {
if (beginsAt < chapterMarks[i]) {
break;
}
i++;
}
chapterMarks.splice(i, 0, beginsAt);
chapterNames.splice(i, 0, chapterName);
}
}

var currentPos = root.lookup(name + "_time").value();
while (chapterIndex < chapterMarks.length - 1 &&
currentPos >= chapterMarks[chapterIndex + 1]) {
chapterIndex++;
}

if (chapterIndex < chapterMarks.length - 1) {
nextChapterAt = chapterMarks[chapterIndex + 1];
}
}
var chapterSym = root.lookup(name + "_chapter");
if (chapterIndex == -1) {
chapterSym.assign(undefined, root.scope, agent);
} else {
chapterSym.assign(chapterNames[chapterIndex], root.scope, agent);
}
};
var chapterMarksSym = root.lookup(name + "_chapters");
setChapters(chapterMarksSym, chapterMarksSym.value());
chapterMarksSym.addJSObserver("setChapters", setChapters);


//Create HTML tag

var videoElement = document.createElement("video");


//Playback controls

var controlsSym = root.lookup(name + "_controls");
var controls = controlsSym.value();
if (controls === undefined) {
controls = true;
if (controlsSym.eden_definition === undefined || controlsSym.definition === undefined) {
controlsSym.assign(true, root.scope, this);
}
}
videoElement.controls = controls;
controlsSym.addJSObserver("showHideControls", function (symbol, showControls) {
videoElement.controls = showControls;
});


//Position on screen

videoElement.style.position = "absolute";
var positionSym = root.lookup(name + "_position");
var position = positionSym.value();
if (position === undefined) {
position = new Point(0, 0);
positionSym.assign(position, root.scope, agent);
}
var repositionAction = function (symbol, position) {
if (position instanceof Point) {
videoElement.style.left = position.x + "px";
videoElement.style.top = position.y + "px";
}
}
repositionAction(positionSym, position);
positionSym.addJSObserver("reposition", repositionAction);


//Size and preloading

var sizeSym = root.lookup(name + "_size");
var size = sizeSym.value();
var resizeAction = function (symbol, size) {
if (size instanceof Point) {
videoElement.width = size.x;
videoElement.height = size.y;
}
}
var preloadWhat;
if (this.preload) {
preloadWhat = "auto";
} else {
preloadWhat = "none";
}
if (size instanceof Point) {
resizeAction(sizeSym, size);
} else if (!this.preload) {
preloadWhat = "metadata";
}
videoElement.preload = preloadWhat;
sizeSym.addJSObserver("resize", resizeAction);
videoElement.addEventListener("loadedmetadata", function (event) {
var sizeSym = root.lookup(name + "_size");
if (sizeSym.value() === undefined) {
sizeSym.assign(new Point(videoElement.videoWidth, videoElement.videoHeight), root.scope, agent);
}
});


//Paused or playing

var pausedSym = root.lookup(name + "_paused");
var beginPaused = pausedSym.value();
if (beginPaused === undefined && (pausedSym.eden_definition === undefined || pausedSym.definition === undefined)) {
pausedSym.assign(true, root.scope, agent);
} else if (beginPaused == false) {
videoElement.autoplay = true;
}
pausedSym.addJSObserver("pausePlay", function (symbol, pause) {
if (pause) {
videoElement.pause();
} else {
videoElement.play();
}
});
videoElement.addEventListener("pause", function (event) {
var pausedSym = root.lookup(name + "_paused");
if (pausedSym.eden_definition === undefined || pausedSym.definition === undefined) {
pausedSym.assign(true, root.scope, agent);
}
});
videoElement.addEventListener("playing", function (event) {
var pausedSym = root.lookup(name + "_paused");
if (pausedSym.eden_definition === undefined || pausedSym.definition === undefined) {
pausedSym.assign(false, root.scope, agent);
}
if (root.lookup(name + "_speed").value() == 0) {
videoElement.defaultPlaybackRate = 1;
videoElement.playbackRate = 1;
}
});


//Seeking and time moving forward

var timeSym = root.lookup(name + "_time");
var time = timeSym.value();
if (time !== undefined) {
videoElement.currentTime = parseFloat(time);
}
timeSym.addJSObserver("seek", function (symbol, seconds) {
var currentTime = videoElement.currentTime;
var relativePosition = seconds - currentTime;
if (relativePosition < -1 || relativePosition > 1 ) {
videoElement.currentTime = seconds;
}
});
videoElement.addEventListener("timeupdate", function (event) {
var newTimeIndex = Math.floor(videoElement.currentTime * 10);
if (newTimeIndex != me.timeIndex) {
root.lookup(name + "_time").assign(newTimeIndex / 10, root.scope, agent);
me.timeIndex = newTimeIndex;

if (nextChapterAt !== undefined && videoElement.currentTime >= nextChapterAt) {
chapterIndex++;
root.lookup(name + "_chapter").assign(chapterNames[chapterIndex], root.scope, agent);
if (chapterIndex < chapterMarks.length - 1) {
nextChapterAt = chapterMarks[chapterIndex]
} else {
nextChapterAt = undefined;
}
}
}
});
videoElement.addEventListener("seeked", function (event) {
if (!root.lookup(name + "_paused").value()) {
videoElement.play();
}
});


//Playback speed

var speedResetOnLoad;
var speedSym = root.lookup(name + "_speed");
var speed = speedSym.value();
if (speed === undefined) {
speedSym.assign(1, root.scope, agent);
} else if (speed > 0) {
videoElement.defaultPlaybackRate = speed;
}
speedSym.addJSObserver("changePlaybackSpeed", function (symbol, speed) {
if (videoElement.playbackRate != speed) {
if (speed > 0) {
videoElement.defaultPlaybackRate = speed;
} else {
videoElement.defaultPlaybackRate = 1;
}
videoElement.playbackRate = speed;
}
});
videoElement.addEventListener("ratechange", function (event) {
var speedSym = root.lookup(name + "_speed");
var speed = videoElement.playbackRate;
if (speedSym.eden_definition === undefined || speedSym.definition === undefined) {
speedSym.assign(speed, root.scope, agent);
}
if (speed == 0) {
videoElement.pause();
} else if (!root.lookup(name + "_paused").value()) {
videoElement.play();
}
});


//Volume

var volumeSym = root.lookup(name + "_volume");
var volume = volumeSym.value();
if (volume === undefined) {
volumeSym.assign(1, root.scope, agent);
} else {
videoElement.volume = volume;
}
volumeSym.addJSObserver("adjustVolume", function (symbol, volume) {
videoElement.volume = volume;
});
videoElement.addEventListener("volumechange", function (event) {
root.lookup(name + "_volume").assign(videoElement.volume, root.scope, agent);
});


//Loading a video file

var urlSym = root.lookup(name + "_url");
var url = urlSym.value();
if (url !== undefined) {
videoElement.src = url;
}
urlSym.addJSObserver("newVideo", function (symbol, url) {
var autoplay = !root.lookup(name + "_paused").value();
root.lookup(name + "_time").assign(undefined, root.scope, agent);
me.timeIndex = undefined;
videoElement.autoplay = autoplay;
if (!autoplay) {
if (me.preload) {
videoElement.preload = "auto";
} else if (root.lookup(name + "_size").value() instanceof Point) {
videoElement.preload = "none";
} else {
videoElement.preload = "metadata";
}
}
videoElement.src = url;
videoElement.load();
});

this.elements = [videoElement];
}
}

Video.prototype.toString = function () {
return "Video(" + Eden.edenCodeForValues(this.preload) + ")";
}

Video.prototype.getEdenCode = Video.prototype.toString;

}}$;


