## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Slider = function(name, min, max, step, x, y, length, orientation, enabled) {
  this.name = name;
  this.min = min;
  this.max = max;
  this.step = step;
  this.x = x;
  this.y = y;
  this.length = length;
  this.orientation = orientation;
  this.enabled = enabled;
}

Slider.prototype.hash = function () {
	return this.name+"$$"+
				this.min+"$$"+
				this.max+"$$"+
				this.step+"$$"+
				this.x+"$$"+
				this.y+"$$"+
				this.length+"$$"+
				this.orientation+"$$"+
				this.enabled;
};
}}$;

func Slider { ${{
  var name = arguments[0];
  var min = arguments[1];
  var max = arguments[2];
  var step = arguments[3];
  var x = arguments[4];
  var y = arguments[5];
  var length = arguments[6];
  var orientation = arguments[7];
  var enabled = arguments[8];
  return new Slider(name, min, max, step, x, y, length, orientation, enabled);
}}$; }

${{
Slider.prototype.draw = function(context,content) {

	var me = "canvas_" + this.name;
	var me2 = this.name;
	var that = this;
	var sli = this.element;
	
	root.lookup(me2 + "_drawing").assign(true);
	var valueSymbol = root.lookup(this.name + "_value");
	var value = valueSymbol.value();

	if (sli === undefined) {
		var orientationCSS = "";
		var topCSS;
		if (this.orientation == "down"){
			orientationCSS = "transform: rotate(90deg);"
			topCSS = "top: " + (this.y + this.length / 2).toString() + "px;";
		} else if (this.orientation == "up" || this.orientation == "vertical") {
			orientationCSS = "transform: rotate(-90deg);"
			topCSS = "top: " + (this.y + this.length / 2).toString() + "px;";
		} else {
			topCSS = "top: " + this.y.toString() + "px;";		
		}


		if (value === undefined) {
			value = this.min;
			valueSymbol.assign(value, this);
		}
		root.lookup(this.name + "_preview").assign(value, this);

		var disabled = this.enabled === false? "disabled=\"disabled\"" : "";
		var inputhtml = (($('<input ' + disabled +
			'id="' + me + '" ' +
			'style="position:absolute; ' + topCSS + ' left:' + this.x.toString() + 'px; width:' + this.length.toString() + 'px; ' + orientationCSS + '" ' +
			'value="' + value.toString() + '" ' +
			'type="range" ' +
			'name="' + this.name + '" ' +
			'min="' + this.min.toString() + '" ' +
			'max="' + this.max.toString() + '" ' +
			'step="' + this.step.toString() + '" />')).on("change", function(){
				root.lookup(me2 + "_value").netAssign(parseInt(this.value));
			}).on("input", function(){
				root.lookup(me2 + "_preview").netAssign(parseInt(this.value));
			}));

		this.element = inputhtml.get(0);
		inputhtml.get(0).togarbage = false;
		root.lookup(me2 + "_drawable").assign(this);

		setTimeout(function () {
			//Assign obs value
			var actualValue = parseInt(that.element.value);
			if (actualValue != value) {
				//Old value not divisible by new step size.
				valueSymbol.netAssign(actualValue);
			}
		}, 0);
		eden.execute("proc " + me2 + "_update : " + me2 + "_value { if (" + me2 + "_drawing) return; if (" + me2 + "_preview != " + me2 + "_value) {" + me2 + "_preview = " + me2 + "_value; " + me2 + "_drawable.draw();}}");
		eden.execute("proc " + me2 + "_update2 : " + me2 + "_preview { if (" + me2 + "_drawing) return; if ($" + "{{ root.lookup('" + me2 + "_preview').last_modified_by == 'input' }}" + "$) {" + me2 + "_value = " + me2 + "_preview; " + me2 + "_drawable.draw();}}");
	} else {
		//Draw with the values stored in the observables
		if (value === undefined) {
			valueSymbol.assign(parseInt(this.element.value), this);
			root.lookup(this.name + "_preview").assign(parseInt(this.element.value), this);
		} else {
			this.element.value = value.toString();
		}
		this.element.togarbage = false;
	}
	root.lookup(me2 + "_drawing").assign(false);
};
}}$;

${{
Slider.prototype.toString = function() {
  return "Slider("+this.name+", "+this.min+", "+this.max+", "+this.step+", "+this.orientation+", "+this.x+", "+this.y+", "+this.length+")";
};
}}$;
