## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Text = function(text, x, y, size, sizeUnits, fillcolour, outlinecolour, options) {
	this.text = text;
	this.x = x;
	this.y = y;
	this.size = size;
	this.sizeUnits = sizeUnits;
	this.fillcolour = fillcolour;
	this.outlinecolour = outlinecolour;

	//See also (below): this.css, this.font, this.optionString
	var css;

	if (options instanceof Object) {
		if (!("valign" in options)) {
			options.valign = "top";
		}
		this.drawingOptions = options;

		if (options.italic) {
			css = "italic ";
		} else {
			css = "";
		}
		if (options.smallCaps) {
			css = css + "small-caps ";
		}
		if (options.bold) {
			css = css + "bold ";
		}
		if (options.fontFace === undefined) {
			this.font = "sans-serif";
		} else {
			this.font = options.fontFace;
		}

	} else if (typeof(options) == "string") {
		this.optionString = options;
		var valignRE = /\b(top|hanging|middle|baseline|alphabetic|ideographic|bottom)\b/;
		var searchResults = valignRE.exec(options);
		if (searchResults === null) {
			this.drawingOptions = {valign: "top"};
		} else {
			this.drawingOptions = {valign: searchResults[0]};
			options = options.replace(valignRE, "");
		}
		var halignRE = /\b(left|right|center|centre|start|end)\b/;
		searchResults = halignRE.exec(options);
		if (searchResults !== null) {
			this.drawingOptions.align = searchResults[0];
			options = options.replace(halignRE, "");
		}
		css = options + " sans-serif";
		this.sizeUnits = undefined;
	} else {
		css = "";
		this.font = "sans-serif";
		this.drawingOptions = {valign: "top"};
	}
	if (this.drawingOptions.align == "centre") {
		this.drawingOptions.align = "center";
	}
	if (this.drawingOptions.valign == "baseline") {
		this.drawingOptions.valign = "alphabetic";
	}
	this.css = css;
	this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(options, "Text");
	this.obsName = root.currentObservableName();
}
}}$;

func Text {
	${{
		var text = arguments[0];
		var x = arguments[1];
		var y = arguments[2];
		var size, sizeUnits, fillcolour, outlinecolour, options;
		var numArgs = arguments.length;
		var argType = typeof(arguments[numArgs - 1]);
		if (argType == "string" && arguments[numArgs - 1].indexOf(" ") !== -1) {
			options = arguments[numArgs - 1];
			if (numArgs >= 5) {
				fillcolour = arguments[3];
				if (numArgs >= 6) {
					outlinecolour = arguments[5];
				}
			}
		} else if (argType == "object" && !(arguments[numArgs - 1] instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
			options = arguments[numArgs - 1];
			if (numArgs >= 5) {
				size = arguments[3];
				if (numArgs >= 6) {
					fillcolour = arguments[4];
					if (numArgs >= 7) {
						outlinecolour = arguments[5];
					}
				}
			}
		} else {
			size = arguments[3];
			fillcolour = arguments[4];
			outlinecolour = arguments[5];
			options = arguments[6];
		}

		if (size === undefined) {
			size = 13.3;
			sizeUnits = "px";
		} else if (typeof(size) == "number") {
			sizeUnits = "px";
		} else {
			var match = /^(\d*(\.\d*)?)([a-z%]*)$/.exec(size);
			size = parseFloat(match[1]);
			sizeUnits = match[3];
		}
		if (outlinecolour === undefined && fillcolour === undefined) {
			fillcolour = "black";
		}
		return new Text(text, x, y, size, sizeUnits, fillcolour, outlinecolour, options);
	}}$;
}

${{

Text.prototype.draw = function (context, scale) {

	if (this.sizeUnits === undefined) {
		context.font = this.css;
	} else {
		context.font = this.css + (this.size / scale) + this.sizeUnits + " " + this.font;
	}
	context.textBaseline = this.drawingOptions.valign;
	if ("align" in this.drawingOptions) {
		context.textAlign = this.drawingOptions.align;
	}
	var x = this.x + context.lineWidth / 2 + 1 / scale;
	var y = this.y + 1 / scale;

	if (this.fillcolour !== undefined) {
		edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
		context.fillText(this.text, x, y);
	}
	if (this.outlinecolour !== undefined) {
		context.strokeStyle = this.outlinecolour;
		context.strokeText(this.text, x, y);	
	}
};

Text.prototype.isHit = function (context, scale, px, py) {
	var x = this.x + 1 / scale;
	var y = this.y + 1 / scale;
	var width, height;
	
	if (this.width === undefined) {
		var fontCSS;
		if (this.sizeUnits === undefined) {
			fontCSS = this.css;
		} else {
			fontCSS = this.css + this.size + this.sizeUnits + " " + this.font;
		}
		var div = document.createElement("div");
		div.innerHTML = this.text;
		div.style.position = 'absolute';
		div.style.top  = '-9999px';
		div.style.font = fontCSS;
		document.body.appendChild(div);
		this.width = div.offsetWidth;
		this.height = div.offsetHeight;
		document.body.removeChild(div);
	}

	var lineWidth = context.lineWidth;
	width = this.width / scale + lineWidth;
	height = this.height / scale + lineWidth / 2;

	return px >= x && px < x + width && py >= y && py < y + height;
}

Text.prototype.toString = function() {
	var s = "Text(" + Eden.edenCodeForValues(this.text, this.x, this.y) + ", ";

	if (this.optionString !== undefined) {
		s = s + Eden.edenCodeForValues(this.fillcolour, this.outlinecolour) + ", " +
			"\"" + this.optionString + "\")";
	} else {
		s = s + '"' + this.size + this.sizeUnits + '", ' +
			Eden.edenCodeForValues(this.fillcolour, this.outlinecolour, this.drawingOptions) + ")";
	}
	return s;
};

Text.prototype.getEdenCode = Text.prototype.toString;

Text.parseArgs = function () {
	var text = arguments[0];

	var size, sizeUnits, options, optionsObj, scale;
	if (typeof(arguments[1]) == "object") {
		options = arguments[1];
	} else {
		var size = arguments[1];
		if (typeof(arguments[2]) == "number") {
			scale = arguments[2];
		} else {
			options = arguments[2];
			scale = arguments[3];
			if (size !== undefined && typeof(options) == "string") {
				eden.error(new Error("textWidth/textHeight: The size argument must be @ when the options parameter is given as a string.  The font size should be included in the options string.  See https://drafts.csswg.org/css2/fonts.html#font-shorthand"), "error");
				return undefined;
			}
		}
	}

	if (size === undefined) {
		size = 13.3;
		sizeUnits = "px";
	} else if (typeof(size) == "number") {
		sizeUnits = "px";
	} else if (scale !== undefined) {
		var match = /^(\d*(\.\d*)?)([a-z%]*)$/.exec(size);
		if (match === null) {
			eden.error(new Error("textWidth/textHeight: Giving the options parameter as a string is not supported when the scale parameter is used."), "error");
			return undefined;
		} else {
			size = parseFloat(match[1]) / scale;
			sizeUnits = match[3];
		}
	} else {
		sizeUnits = "";
	}
	if (scale === undefined) {
		scale = 1;
	}

	var css;
	if (options instanceof Object) {
		optionsObj = options;
		if (options.italic) {
			css = "italic ";
		} else {
			css = "";
		}
		if (options.smallCaps) {
			css = css + "small-caps ";
		}
		if (options.bold) {
			css = css + "bold ";
		}
		css = css + size + sizeUnits + " ";
		if (options.fontFace === undefined) {
			css = css + "sans-serif";
		} else {
			css = css + options.fontFace;
		}
	} else if (typeof(options) == "string") {
		options = options.replace(/\b(top|hanging|middle|baseline|alphabetic|ideographic|bottom|left|right|center|centre|start|end)\b\s*/g, "");
		css = options + " sans-serif";
		optionsObj = {};
	} else {
		css = size + sizeUnits + " sans-serif";
		optionsObj = {};
	}
	return [css, optionsObj, scale];
};

}}$;

func textWidth {
	${{
		var text = arguments[0];
		var options = Text.parseArgs.apply(undefined, arguments);
		var css = options[0];
		var optionsObj = options[1];
		var scale = options[2];

		//Find an existing canvas (any one).
		var canvas;
		for (var canvasName in canvases) {
			canvas =  canvases[canvasName];
			break;
		}
		
		var context = canvas.getContext("2d");
		context.save();
		edenUI.plugins.Canvas2D.configureContextDefaults(context, 1);
		edenUI.plugins.Canvas2D.configureContext(context, 1, 1, optionsObj);
		context.font = css;
		context.textBaseline = "top";
		var metrics = context.measureText(text);
		var width = metrics.width + context.lineWidth + 2 / scale;
		context.restore();
		return width;
	}}$;
}

func textHeight {
	${{
		var text = arguments[0];
		var options = Text.parseArgs.apply(undefined, arguments);
		var fontCSS = options[0];
		var optionsObj = options[1];
		var scale = options[2];

		var lineWidth = optionsObj.lineWidth;
		if (lineWidth === undefined) {
			lineWidth = 2;
		}

		var div = document.createElement("div");
		div.innerHTML = text;
		div.style.position = 'absolute';
		div.style.top  = '-9999px';
		div.style.font = fontCSS;
		document.body.appendChild(div);
		var height = div.offsetHeight;
		document.body.removeChild(div);
		return height + lineWidth / 2 + 2 / scale;
	}}$;
}
