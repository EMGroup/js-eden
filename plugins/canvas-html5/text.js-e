## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Text = function(text, x, y, size, sizeUnits, fillcolour, outlinecolour, options) {
	this.text = text;
	this.x = x;
	this.y = y;
	this.size = size;
	this.sizeUnits = sizeUnits;
	this.fillcolour = fillcolour;
	this.outlinecolour = outlinecolour;
	//See also (below): this.css, this.font, this.optionString

	var css;
	if (options instanceof Object) {
		if (!("valign" in options)) {
			options.valign = "top";
		}
		this.drawingOptions = options;

		if (options.italic) {
			css = "italic ";
		} else {
			css = "";
		}
		if (options.smallCaps) {
			css = css + "small-caps ";
		}
		if (options.bold) {
			css = css + "bold ";
		}
		if (options.fontFace === undefined) {
			this.font = "sans-serif";
		} else {
			this.font = options.fontFace;
		}

	} else if (typeof(options) == "string") {
		this.optionString = options;
		var valignRE = /\b(top|hanging|middle|baseline|alphabetic|ideographic|bottom)\b/;
		var searchResults = valignRE.exec(options);
		if (searchResults === null) {
			this.drawingOptions = {valign: "top"};
		} else {
			this.drawingOptions = {valign: searchResults[0]};
			options = options.replace(valignRE, "");
		}
		var halignRE = /\b(left|right|center|centre|start|end)\b/;
		searchResults = halignRE.exec(options);
		if (searchResults !== null) {
			this.drawingOptions.align = searchResults[0];
			options = options.replace(halignRE, "");
		}
		css = options + " sans-serif";
		this.sizeUnits = undefined;
	} else {
		css = "";
		this.font = "sans-serif";
		this.drawingOptions = {valign: "top"};
	}
	if (this.drawingOptions.align == "centre") {
		this.drawingOptions.align = "center";
	}
	if (this.drawingOptions.valign == "baseline") {
		this.drawingOptions.valign = "alphabetic";
	}
	this.css = css;
}
}}$;

func Text {
	${{
		var text = arguments[0];
		var x = arguments[1];
		var y = arguments[2];
		var size, sizeUnits, fillcolour, outlinecolour, options;
		var numArgs = arguments.length;
		var argType = typeof(arguments[numArgs - 1]);
		if (argType == "string" && arguments[numArgs - 1].indexOf(" ") !== -1) {
			options = arguments[numArgs - 1];
			if (numArgs >= 5) {
				fillcolour = arguments[3];
				if (numArgs >= 6) {
					outlinecolour = arguments[5];
				}
			}
		} else if (argType == "object" && !(arguments[numArgs - 1] instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
			options = arguments[numArgs - 1];
			if (numArgs >= 5) {
				size = arguments[3];
				if (numArgs >= 6) {
					fillcolour = arguments[4];
					if (numArgs >= 7) {
						outlinecolour = arguments[5];
					}
				}
			}
		} else {
			size = arguments[3];
			fillcolour = arguments[4];
			outlinecolour = arguments[5];
			options = arguments[6];
		}

		if (size === undefined) {
			size = 13.3;
			sizeUnits = "px";
		} else if (typeof(size) == "number") {
			sizeUnits = "px";
		} else {
			var match = /^(\d*(\.\d*)?)([a-z%]*)$/.exec(size);
			size = parseFloat(match[1]);
			sizeUnits = match[3];
		}
		if (outlinecolour === undefined && fillcolour === undefined) {
			fillcolour = "black";
		}		
		return new Text(text, x, y, size, sizeUnits, fillcolour, outlinecolour, options);
	}}$;
}

${{

Text.prototype.draw = function (context, scale) {

	if (this.sizeUnits === undefined) {
		context.font = this.css;
	} else {
		context.font = this.css + (this.size / scale) + this.sizeUnits + " " + this.font;
	}
	context.textBaseline = this.drawingOptions.valign;
	if ("align" in this.drawingOptions) {
		context.textAlign = this.drawingOptions.align;
	}

	if (this.fillcolour !== undefined) {
		edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
		context.fillText(this.text, this.x, this.y);
	}
	if (this.outlinecolour !== undefined) {
		context.strokeStyle = this.outlinecolour;
		context.strokeText(this.text, this.x, this.y);	
	}
};

Text.prototype.toString = function() {
	var s = "Text(\"" + this.text + "\", " + this.x + ", " + this.y + ", ";

	if (this.optionString !== undefined) {
		s = s + Eden.edenCodeForValue(this.fillcolour) + ", " +
			Eden.edenCodeForValue(this.outlinecolour) + ", " +
			"\"" + this.optionString + "\")";
	} else {
		s = s + '"' +Eden.edenCodeForValue(this.size) + this.sizeUnits + '", ' +
			Eden.edenCodeForValue(this.fillcolour) + ", " +
			Eden.edenCodeForValue(this.outlinecolour) + ", " +
			Eden.edenCodeForValue(this.drawingOptions) + ")";
	}
	return s;
};

Text.prototype.getEdenCode = Text.prototype.toString;

}}$;

func textWidth {
	${{
		var text = arguments[0];

		var size, sizeUnits, options, optionsObj, scale;
		if (typeof(arguments[1]) == "object") {
			options = arguments[1];
		} else {
			var size = arguments[1];
			if (typeof(arguments[2]) == "number") {
				scale = arguments[2];
			} else {
				options = arguments[2];
				scale = arguments[3];
				if (size !== undefined && typeof(options) == "string") {
					eden.error(new Error("textWidth: The size argument must be @ when the options parameter is given as a string.  The font size should be included in the options string.  See https://drafts.csswg.org/css2/fonts.html#font-shorthand"), "error");
					return undefined;
				}
			}
		}

		if (size === undefined) {
			size = 13.3;
			sizeUnits = "px";
		} else if (typeof(size) == "number") {
			sizeUnits = "px";
		} else if (scale !== undefined) {
			var match = /^(\d*(\.\d*)?)([a-z%]*)$/.exec(size);
			if (match === null) {
				eden.error(new Error("textWidth: Giving the options parameter as a string is not supported when the scale parameter is used."), "error");
				return undefined;
			} else {
				size = parseFloat(match[1]) / scale;
				sizeUnits = match[3];
			}
		} else {
			sizeUnits = "";
		}

		var css;
		if (options instanceof Object) {
			optionsObj = options;
			if (options.italic) {
				css = "italic ";
			} else {
				css = "";
			}
			if (options.smallCaps) {
				css = css + "small-caps ";
			}
			if (options.bold) {
				css = css + "bold ";
			}
			css = css + size + sizeUnits + " ";
			if (options.fontFace === undefined) {
				css = css + "sans-serif";
			} else {
				css = css + options.fontFace;
			}
		} else if (typeof(options) == "string") {
			options = options.replace(/\b(top|hanging|middle|baseline|alphabetic|ideographic|bottom|left|right|center|centre|start|end)\b\s*/g, "");
			css = options + " sans-serif";
			optionsObj = {};
		} else {
			css = size + sizeUnits + " sans-serif";
			optionsObj = {};
		}
		
		//Find an existing canvas (any one).
		var canvas;
		for (var canvasName in canvases) {
			canvas =  canvases[canvasName];
		}
		
		var context = canvas.getContext("2d");
		context.save();
		edenUI.plugins.Canvas2D.configureContextDefaults(context, 1);
		edenUI.plugins.Canvas2D.configureContext(context, 1, optionsObj);
		context.font = css;
		context.textBaseline = "top";
		var metrics = context.measureText(text);
		var width = metrics.width;
		context.restore();
		return width;
	}}$;
}
