## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Arc = function(x, y, r, sAngle, eAngle, colour, drawingOptions) {
	this.x = x;
	this.y = y;
	this.r = r;
	this.sAngle = sAngle;
	this.eAngle = eAngle;
	var radiansPerUnit = root.lookup("radiansPerUnit").value();
	var sRadians = sAngle * radiansPerUnit;
	var eRadians = eAngle * radiansPerUnit;
	var twoPI = 2 * Math.PI;
	sRadians = sRadians % twoPI;
	if (sRadians < 0) {
		sRadians = sRadians + twoPI;
	}
	eRadians = eRadians % twoPI;
	if (eRadians < 0) {
		eRadians = eRadians + twoPI;
	}
	this.sRadians = sRadians;
	this.eRadians = eRadians;
	
	this.colour = colour
	this.drawingOptions = drawingOptions;
}
}}$;

func Arc { ${{
	var x = arguments[0];
	var y = arguments[1];
	var r = arguments[2];
	var sAngle = arguments[3];
	var eAngle = arguments[4];
	var colour, drawingOptions;
	if (arguments.length == 6 && typeof(arguments[5]) == "object" && !(arguments[5] instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		colour = "black";
		drawingOptions = arguments[5];
	} else {
		colour = arguments[5];
		drawingOptions = arguments[6];
		if (colour === undefined) { colour = "black"; }
	}
	return new Arc(x, y, r, sAngle, eAngle, colour, drawingOptions);
}}$; };
radiansPerUnit ~> [Arc];

${{

Arc.prototype.draw = function(context) {
	var anticlockwise;
	if (this.drawingOptions !== undefined && "direction" in this.drawingOptions) {
		var directionName = this.drawingOptions.direction;
		var turnedThroughAC = this.eRadians - this.sRadians;
		if (this.eRadians < this.sRadians) {
			turnedThroughAC = turnedThroughAC + twoPI;
		}
		switch (directionName) {
		case "anticlockwise":
		case "acw":
		case "ccw":
			anticlockwise = true;
			break;
		case "auto":
			anticlockwise = this.sAngle < this.eAngle;
			break;
		case "clockwise":
		case "cw":
			anticlockwise = false;
			break;
		case "major":
			anticlockwise = turnedThroughAC > Math.PI;
			break;
		case "minor":
			anticlockwise = turnedThroughAC <= Math.PI;
			break;
		default:
			anticlockwise = true;
		}
	} else {
		anticlockwise = this.sAngle < this.eAngle;
	}
	context.beginPath();
	context.arc(this.x, this.y, this.r - context.lineWidth / 2, -this.sRadians, -this.eRadians, anticlockwise);
	context.strokeStyle = this.colour;
	context.stroke();
};

Arc.prototype.toString = function() {
	var s= "Arc(" +
		this.x + "," +
		this.y + "," +
		this.r + "," +
		this.sAngle + "," +
		this.eAngle + "," +
		"\"" + this.colour + "\"";

	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
}

Arc.prototype.getEdenCode = Arc.prototype.toString;

}}$;
