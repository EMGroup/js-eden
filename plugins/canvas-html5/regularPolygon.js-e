${{
	RegularPolygon = function (x, y, r, n, star, rotation, interiorOutline, fillcolour, outlinecolours, drawingOptions) {
		this.x = x;
		this. y = y;
		this.r = r;
		this.n = n;
		this.star = star;
		this.interiorOutline = interiorOutline;
		this.rotation = rotation;
		this.fillcolour = fillcolour;
		this.outlinecolours = outlinecolours;
		this.drawingOptions = drawingOptions;
		if (this.outlinecolours === undefined) {
			this.calculatePolygons(0);
		}
	}

	RegularPolygon.prototype.calculatePolygons = function (lineWidth) {
		var separatePolygonsPossiblyNeeded;
		if (this.fillcolour !== undefined && this.fillcolour != "transparent" && this.outlinecolours !== undefined &&
			this.n / this.star != 2) {
			separatePolygonsPossiblyNeeded = true;
		} else {
			separatePolygonsPossiblyNeeded = false;		
		}
		this.vertices = [];
		
		var radius = this.r - lineWidth / 2;
		var rotation = -this.rotation - Math.PI * (0.5 - 2 / this.n);
		var nudge;
		if (this.drawingOptions !== undefined && this.drawingOptions.valign == "bottom") {
			nudge = lineWidth;
		} else {
			nudge = 0;
		}

		var exteriorAngle = (2 * Math.PI) / this.n;
		var pointsDone = new Array(this.n);
		var px, py;
		var polygons = [];
		var currentPolygonVertices, currentPoint;
		for (var i = 0; i < this.n; i++) {
			var j = i;
			currentPolygonVertices = [];
			while (pointsDone[j] !== true) {
				px = this.x + radius * Math.cos(rotation + j * exteriorAngle);
				py = this.y + radius * Math.sin(rotation + j * exteriorAngle) + nudge;
				currentPoint = new Point(px, py);
				currentPolygonVertices.push(currentPoint);
				pointsDone[j] = true;
				j = (j + this.star) % this.n;
			}
			if (currentPolygonVertices.length > 0) {
				this.vertices = this.vertices.concat(currentPolygonVertices);
				polygons.push(new Polygon(currentPolygonVertices, this.fillcolour, this.outlinecolours, this.drawingOptions));
			}
		}
		if (separatePolygonsPossiblyNeeded) {
			if (polygons.length == 1) {
				if (!this.interiorOutline) {
					var lineWidth;
					if (typeof(this.drawingOptions) == "object" && "lineWidth" in this.drawingOptions) {
						lineWidth = this.drawingOptions.lineWidth;
					} else {
						lineWidth = 2;
					}
					var smallerRadius = radius - Math.ceil(lineWidth / 2) - 2;
					currentPolygonVertices = [];
					i = 0;
					do {
						px = this.x + smallerRadius * Math.cos(rotation + i * exteriorAngle);
						py = this.y + smallerRadius * Math.sin(rotation + i * exteriorAngle) + nudge;
						currentPoint = new Point(px, py);
						currentPolygonVertices.push(currentPoint);
						i = (i + this.star) % this.n;
					} while (i != 0);
					polygons.push(new Polygon(currentPolygonVertices, this.fillcolour, undefined, this.drawingOptions));
				}
				this.filledPolygons = polygons;
				this.outlinePolygons = [];
			} else {
				this.filledPolygons = [];
				this.outlinePolygons = [];
				for (var i = 0; i < polygons.length; i++) {
					this.filledPolygons.push(new Polygon(polygons[i].vertices, this.fillcolour, undefined, this.drawingOptions));
					this.outlinePolygons.push(new Polygon(polygons[i].vertices, undefined, this.outlinecolours, this.drawingOptions));
				}
			}
		} else {
			this.filledPolygons = polygons;
			this.outlinePolygons = [];
		}	
	}
}}$;

func RegularPolygon {
	${{
		var x = arguments[0];
		var y = arguments[1];
		var r = arguments[2];
		var n = arguments[3];
		var star = 1, rotation = 0, interiorOutline = true;
		var argsProcessed = 4;
		if (typeof(arguments[4]) == "number") {
			star = arguments[4];
			argsProcessed++;
		}
		if (typeof(arguments[argsProcessed]) == "boolean") {
			interiorOutline = arguments[argsProcessed];
			argsProcessed++;
		}
		if (typeof(arguments[argsProcessed]) == "number") {
				rotation = arguments[argsProcessed] * root.lookup("radiansPerUnit").value();
				argsProcessed++;
		}
		
		if (typeof(arguments[arguments.length - 1]) == "object") {
			argsProcessed = arguments.length - 3;
		} else if (arguments.length > 6) {
			argsProcessed = arguments.length - 2;
		}

		var fillcolour = arguments[argsProcessed];
		var outlinecolours = arguments[argsProcessed + 1];

		if (outlinecolours === undefined) {
			if (fillcolour === undefined) {
				outlinecolours = ["black"];
			}
		} else if (!Array.isArray(outlinecolours)) {
			outlinecolours = [outlinecolours];
		} else if (outlinecolours.length == 0) {
			outlinecolours = ["black"];
		}

		var drawingOptions = arguments[argsProcessed + 2];
		if (typeof(drawingOptions) == "object" && !("join" in drawingOptions)) {
			drawingOptions.join = "round";
		}
		return new RegularPolygon(x, y, r, n, star, rotation, interiorOutline, fillcolour, outlinecolours, drawingOptions);
	}}$;
}
radiansPerUnit ~> [RegularPolygon];

${{
RegularPolygon.prototype.draw = function (context) {
	var lineWidth = context.lineWidth;
	if (!this.interiorOutline) {
		lineWidth = lineWidth * 2;
	}
	if (this.outlinecolours !== undefined) {
		if (lineWidth !== this.cachedPolygonLineWidth) {
			this.calculatePolygons(lineWidth);
			this.cachedPolygonLineWidth = lineWidth;
		}
	}

	if (this.interiorOutline) {
		for (var i = 0; i < this.filledPolygons.length; i++) {
			this.filledPolygons[i].draw(context);
		}
		for (var i = 0; i < this.outlinePolygons.length; i++) {
			this.outlinePolygons[i].draw(context);
		}
	} else {
		context.lineWidth = lineWidth;
		for (var i = 0; i < this.outlinePolygons.length; i++) {
			this.outlinePolygons[i].draw(context);
		}
		context.lineWidth = lineWidth / 2;
		for (var i = 0; i < this.filledPolygons.length; i++) {
			this.filledPolygons[i].draw(context);
		}
	}
}

RegularPolygon.prototype.toString = function () {
	var s = "RegularPolygon(" +
		this.x + ", " +
		this.y + ", " +
		this.r + ", " +
		this.n + ", " +
		this.star + ", " +
		this.interiorOutline + ", " +
		this.rotation + ", " +
		Eden.edenCodeForValue(this.fillcolour) + ", " +
		Eden.edenCodeForValue(this.outlinecolours);

	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	s = s + ")";
	return s;
}

RegularPolygon.prototype.getEdenCode;
	
}}$;
