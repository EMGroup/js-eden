## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

${{
Rectangle = function(pos, scale, rot, fillcolour, outlinecolour, drawingOptions) {
	this.x = pos.x;
	this.y = pos.y;
	this.z = pos.z;
	this.width = scale.x;
	this.height = scale.y;
	this.rotation = rot;
	this.colour = (fillcolour) ? fillcolour : "white";
	this.outlinecolour = outlinecolour;
	this.drawingOptions = drawingOptions;
	this.name = edenUI.plugins.Canvas2D.initZoneFromDrawingOpts(drawingOptions, "Rectangle");
	this.obsName = root.currentObservableName();
}

Rectangle.createBuffer = function(gl) {
	Rectangle.buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, Rectangle.buffer);
    vertices = [
         1.0,  1.0,  0.0,
        -1.0,  1.0,  0.0,
         1.0, -1.0,  0.0,
        -1.0, -1.0,  0.0
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    Rectangle.buffer.itemSize = 3;
    Rectangle.buffer.numItems = 4;

	Rectangle.colourbuffer = gl.createBuffer();
	Rectangle.colourbuffer.itemSize = 4;
	Rectangle.colourbuffer.numItems = 4;
}

}}$;

#! Creates a rectangle that can be coloured and displayed on a canvas. See [drawing options](@external CanvasExamples > drawingoptions) for more style options.
#
# ##Usage Example
#  `Rectangle(x,y,width,height);`
#  `Rectangle(x,y,w,h, "green", "black", Object("lineWidth", 5));`
#
# @param x X-coordinate for top left
# @param y Y-coordinate for top left
# @param width
# @param height
# @param [fill_colour
# @param [outline_colour]] Colour of the rectangle outline in HTML form
# @param [drawing_options] List of drawing options
# 
#  #canvas #rectangle #drawingoptions #square #box #shape #draw
func Rectangle {
${{
	var x = arguments[0];
	var y = arguments[1];
	var width = arguments[2];
	var height = arguments[3];
	var fillcolour, outlinecolour, drawingOptions;
	var lastArg = arguments[arguments.length - 1];
	var processUpTo;
	if (lastArg !== undefined && (lastArg instanceof Object) && !(lastArg instanceof EdenUI.plugins.Canvas2D.FillStyle)) {
		drawingOptions = lastArg;
		processUpTo = arguments.length - 2;
	} else {
		processUpTo = arguments.length - 1;
	}
	if (processUpTo >= 4) {
		fillcolour = arguments[4];
		if (processUpTo == 5) {
			outlinecolour = arguments[5];
		}
	}
	if (fillcolour === undefined && outlinecolour === undefined) {
		outlinecolour = "black";
	}
	return new Rectangle(new Point3D(x, y, -5.0), new Point2D(width, height), undefined, fillcolour, outlinecolour, drawingOptions);
}}$; };

Rectangle3D is ${{ (new Rectangle(
	scope.value("$1"),
	scope.value("$2"),
	scope.value("rotation"),
	scope.value("fill"),
	scope.value("outline"))) }}$ ::
		$1=$1,
		$2=$2,
		rotation=rotation,
		fill = fill if fill!=@ else "white",
		outline = "black";


${{

Rectangle.prototype.draw = function (context, scale, viewname, mvMatrix, shader, pMatrix) {
	/*var lineWidth;
	if (this.outlinecolour !== undefined) {
		lineWidth = context.lineWidth;
		if (this.drawingOptions !== undefined) {
			if (!("join" in this.drawingOptions) && lineWidth < 10) {
				//Bug in Chrome v44, shape isn't drawn when miter join is used with larger line widths.
				context.lineJoin = "miter"
			}
		}
	} else {
		lineWidth = 0;
	}
	var y = this.y;
	if (scale < 0) {
		y = y - this.height;
	}
	if (this.fillcolour !== undefined) {
		edenUI.plugins.Canvas2D.setFillStyle(context, this.fillcolour);
		context.fillRect(this.x + lineWidth, y + lineWidth, this.width - 2 * lineWidth, this.height - 2 * lineWidth);
	}
	if (this.outlinecolour !== undefined) {
		context.strokeStyle = this.outlinecolour;
		context.strokeRect(this.x + lineWidth / 2, y + lineWidth / 2, this.width - lineWidth, this.height - lineWidth);
	}*/

	var scale = vec3.create();
	vec3.set(scale, this.width, this.height, 1.0);
	mat4.scale(mvMatrix,mvMatrix,scale);

	var translation = vec3.create();
	vec3.set (translation, this.x, this.y, this.z);
	mat4.translate(mvMatrix,mvMatrix,translation);

	if (this.rotation) {
		var rot = vec3.create();
		if (this.rotation.x) {
			vec3.set(rot, 1, 0, 0);
			mat4.rotate(mvMatrix, mvMatrix, this.rotation.x * Math.PI / 180, rot);
		}
		if (this.rotation.y) {
			vec3.set(rot, 0, 1, 0);
			mat4.rotate(mvMatrix, mvMatrix, this.rotation.y * Math.PI / 180, rot);
		}
		if (this.rotation.z) {
			vec3.set(rot, 0, 0, 1);
			mat4.rotate(mvMatrix, mvMatrix, this.rotation.z * Math.PI / 180, rot);
		}
	}

	if (this.colour instanceof CanvasImage && this.colour.texture) {
		context.bindBuffer(context.ARRAY_BUFFER, Cube.textbuffer);
    	context.vertexAttribPointer(shader.textureCoordAttribute, Cube.textbuffer.itemSize, context.FLOAT, false, 0, 0);
		context.activeTexture(context.TEXTURE0);
   		context.bindTexture(context.TEXTURE_2D, this.colour.texture);
    	context.uniform1i(shader.samplerUniform, 0);
	} else {
		if (!this.texture) {
			var colorobj = jQuery.Color( (typeof this.colour == "string") ? this.colour : "orange" );
			var r = colorobj.red();
			var g = colorobj.green();
			var b = colorobj.blue();

			this.texture = context.createTexture();
			context.bindBuffer(context.ARRAY_BUFFER, Cube.textbuffer);
    		context.vertexAttribPointer(shader.textureCoordAttribute, Cube.textbuffer.itemSize, context.FLOAT, false, 0, 0);
			context.activeTexture(context.TEXTURE0);
			context.bindTexture(context.TEXTURE_2D, this.texture);
			context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, 1, 1, 0, context.RGBA, context.UNSIGNED_BYTE,
						  new Uint8Array([r, g, b, 255]));
			context.uniform1i(shader.samplerUniform, 0);
		} else {
			context.bindBuffer(context.ARRAY_BUFFER, Cube.textbuffer);
			context.vertexAttribPointer(shader.textureCoordAttribute, Cube.textbuffer.itemSize, context.FLOAT, false, 0, 0);
			context.activeTexture(context.TEXTURE0);
	   		context.bindTexture(context.TEXTURE_2D, this.colour.texture);
			context.uniform1i(shader.samplerUniform, 0);
		}
	}
	context.bindBuffer(context.ARRAY_BUFFER, Rectangle.buffer);
    context.vertexAttribPointer(shader.vertexPositionAttribute, Rectangle.buffer.itemSize, context.FLOAT, false, 0, 0);
	//context.uniformMatrix4fv(shader.pMatrixUniform, false, pMatrix);
	context.uniformMatrix4fv(shader.mvMatrixUniform, false, mvMatrix);
	context.drawArrays(context.TRIANGLE_STRIP, 0, Rectangle.buffer.numItems);
};

Rectangle.prototype.isHit = function (context, scale, x, y) {
	return x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height;
}

Rectangle.prototype.toString = function() {
	var s = "Rectangle(" + Eden.edenCodeForValues(this.x, this.y, this.width, this.height, this.fillcolour, this.outlinecolour);

	if (this.drawingOptions !== undefined) {
		s = s + ", " + Eden.edenCodeForValue(this.drawingOptions);
	}
	
	s = s + ")";
	return s;
};

Rectangle.prototype.getEdenCode = Rectangle.prototype.toString;

Rectangle.prototype.imageMapArea = function () {
	return "shape=\"rect\" coords=\"" + this.x + "," + this.y + "," + (this.x + this.width) + "," +
		(this.y + this.height) + "\"";
}

Rectangle.prototype.centre = function () {
	return new Point(this.x + this.width / 2, this.y + this.height / 2);
}

}}$;
