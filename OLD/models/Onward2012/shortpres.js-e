
## presentation comprises a sequence based on a generic slide called slideX
## control then passes to the text presenter interface

slideList is [];
## slides is [buttonPrev, buttonNext, buttonProj, slideNumber, slideList[currentSlide]];
slides is [buttonPrev, buttonNext, slideX];

## setting up the script to present the contents of the generic slide

keyword = "";
paragraphs is findwordparatext(keyword, allparasplusslides);			## this is default
paratext is paragraphs[ixpara];	ixpara = 1;								## this is default
allsentences is splitintosentences(paratext);
numsentences is allsentences#;											## this is default
seqsentences is list1tok(min(sentencessofar, numsentences));			## this is default

/*
ixselsentences is list1tok(allsentences#);								## this is default 
			## use to update "sentence n of N"
			## and maybe control behaviour "mod allsentences#"
selsentences is filter(allsentences, ixselsentences);						
parasofarread is concatpsentences(filter(selsentences,seqsentences));
*/

## the defns commmented out above were previously used to enable the selection of sentences
## from a paragraph via observable ixselsentences: now reorganising management of state so
## that have means to specify the block of text generated by selecting a subset of sentences
## - see mkTextblock(). Also gives flexibility to concatenate blocks, interspersing explicitly
## specified content

parasofarread is concatpsentences(filter(allsentences, seqsentences));

/*
## taking account of the selection of a subset of sentences:

nextsentencelab is "Reading sentence " // str(ixselsentences[sentencessofar]) // " of " // str(allsentences#) // " ...";
nextsentenceenabled is (sentencessofar < ixselsentences#);
*/

nextsentencelab is "Reading sentence " // str(sentencessofar) // " of " // str(allsentences#) // " ...";
nextsentenceenabled is (sentencessofar < allsentences#);

## default context allows a specific paragraph in the essay to be selected (by assigning a value to ixpara)
## and permits the first numsentences on the slide to be displayed

## can change what paragraph(s) is/are supplied, how many sentences are displayed, and which are selected
## so can provide your own custom paragraph

## for purposes of presentation, paragraphs is defined to be paraSlides

## initially

paraSlides = [titleheader]; ixpara = paraSlides#; ixsentence = 1;
## the generic description of slideX is:

 ## slideX is Slide("<p>" // parasofarread // "</p>");
 ## no need for the extra <p>
 
 slideX is Slide(parasofarread);
 
 ## paragraphs is paraSlides;
 
##########################################

## useful function for generating text from the essay content by selection
## might be of interest here to consider how a script might be used (as has been)
## to engineer a function - in keeping with idea of definitive specification of fn
 
################################

func mkTextblock {
	para kword, indexpara, arrsel;
	return concatsentences(filter(splitintosentences(getlscomp(findwordparatext(kword, allparasplusslides),indexpara)), arrsel));
}

##################################

contents is "<h3>Contents of the essay ...</h3>
<p>
<ol>
<li>Software and Experience</li>
<li>Fortran / TM experience - two kinds of experience of programming</li>
<li>Hermeneutic and formalist perspectives</li>
<li>Maths and computer science from an experiential perspective</li>
<li>Beyond a 'computational thinking' perspective on computing</li>
<li>Software development, learning and <i>construction</i></li>
<li>Empirical Modelling</li>
<li>Retrospect and Prospect</li>
</ol>
</p>
";

####################################

paraSlide1 is "Realising Software Development as a Lived Experience? Realising Software Development as a <i>Live</i> Experience? <i>- the present, of-this-moment, being lived, experience of the software developer</i>. " // note1 // " The Light Table - Chris Grainger. A Small Matter of Programming - Bonnie Nardi.";

#######################################

note10x = "Douglas Crockford. ''<i>We imagine that we spend most of our time power typing</i> ...  when in fact ... <i>We spend most of our time looking into the abyss, asking <b>My God - what have I done?</b>, trying to make sense of this puddle of confusion and turn it back into a working program</i>.''.";

## note the 'dot' after the single quote

paraSlide2 is "Realising Software Development as a Lived Experience ... Realising Software Development as a <b>Loved</b> Experience? " // note10x // " ... Realising Software Development as a <b>Livid</b> Experience?";

paraSlide3 is "<i>" // mkTextblock("", 3, [1,2,7,8,9])	// "</i>"; ## Fortran programming

paraSlide4 is "<i>" // allparas[4] // "</i>";	## accidental / essential

paraSlide5 is "<i>" // mkTextblock("", 5, [2,3,4,6,7,8]) // "</i>";	## Turing machine programmming

paraSlide6 is "Two extreme perspectives on programming. Two <b>too</b> extreme perspectives on programming? Surely the Fortran experience was full of ephemera. And yet ... <i>I have become more circumspect about what is ephemeral in computing, and ever more convinced that what is not ephemeral is more than a formal mathematical treatment can endorse. </i> I have also come to believe that ... <i>The notion that the principles of software development are first and foremost concerned with computational thinking and the study of process-like behaviours is an illusion.<i>";

paraSlide9 is mkTextblock("", 18, [1,2,3,4,5,6]); ## West on hermeneutics

paraSlide11 is "With respect to what West characterises as formalist and hermeneutic/constructivist perspectives, this essay makes ... - a counter-proposal to the idea of computational thinking as the sole foundation of computing... - aimed at sustaining <b>both</b> perspectives ... - not as antithetical alternatives, but as complementary. In this reconceptualisation of computing, the notion of <i>experience</i> has a critical role.";

paraSlide12 is "The critical need to reconcile <b>experience</b> with logic is recognised only reluctantly by formalists ... " // note7 //
" Invoking experience is seen as compromising mathematical ideals.";

paraSlide13 is "<b>Hermeneutic and formalist perspectives in software development</b>. Relational algebra / SQL -  truth: absolute and hermeneutic. XP and TDD - functional specifications vs 'object thinking'. More than modelling a mind <i>following rules</i> ...";

paraSlide14 is "<b>Matters of <i>classification of experience</i></b> ... Aspects of live experience can be construed as computational in character. We can construct situations in which we observe patterns with the universal and objective characteristics of logic. But <i>the act</i> of construing a pattern as <i>logical</i> is personal and subjective. <b>- reconciling formalist and hermeneutic perspectives</b>. (cf.\u00A0<i>" // mkTextblock("", 18, [3,4]) // "</i>)";

paraSlide15 is "<b>Empirical Modelling</b> ... " // allparas[48];

paraSlide16 is "EM as exploration in 'the space of sense'. Questions we can ask in making sense of our environment.  ...\u00A0what can be reliably observed - <b>observables</b>\ - ? ...\u00A0how are changes to observables perceived to be connected - <b>dependencies</b>\ - ? ...\u00A0what are the possible sources of change - <b>agents, agencies</b>\ - ? Neighbouring in the space of sense ... ...\u00A0'lived' and 'loved' on a keyboard.  - illustrating the alogical associations that can be critical in software failure.";

paraSlide17 is "<b>QUESTIONS?</b>";

#####################################

## paraSlides = [titleheader, contents, paraSlide1, paraSlide2, paraSlide3, paraSlide4, paraSlide5, paraSlide6, paraSlide9, paraSlide11, paraSlide12, paraSlide13, paraSlide14, paraSlide15, paraSlide16, paraSlide17;
paraSlides = [titleheader, contents, paraSlide1, paraSlide2, paraSlide3, paraSlide4, paraSlide5, paraSlide6, paraSlide9, paraSlide11, paraSlide12, paraSlide13, paraSlide14, paraSlide15, paraSlide16];

#########################################

emptystring = "";

paraSlideKeyword is "
<p>
To display all the paragraphs that refer (e.g.) to West or Naur, we specify them in the <b>keyword</b> observable:
<jseden>ixsentence=1;
thisixpara = (keyword==emptystring) ? ixpara : thisixpara;
## bookmark slide
ixpara=1; keyword=\"West\";</jseden>
<jseden>ixsentence=1;
thisixpara = (keyword==emptystring) ? ixpara : thisixpara;
ixpara=1; keyword=\"Naur\";</jseden>
</p>
<p>
To restore the focus to the bookmarked slide ...
<pre><jseden>ixsentence=1; ixpara=thisixpara;
keyword=emptystring;
</jseden></pre>
</p>
";

#########################################

paraSlideTopics is "
<p>
To display extracts on SQL, XP and modelling mind respectively:
<jseden>ixsentence=1; ixpara=(ixpara==189)?19:189;</jseden>
<jseden>ixsentence=1; ixpara=(ixpara==189)?35:189;</jseden>
<jseden>ixsentence=1; ixpara=(ixpara==189)?31:189;</jseden>
</p>
";

######################################

paraSlidePractEM is "<b>EM in practice</b>  <p>To access this presentation, invoke the JS-EDEN interpreter at the url:</p>
<p>
<a href = \"http://www.dcs.warwick.ac.uk/jseden.dcs.warwick.ac.uk\" target=\"_blank\">http://www.dcs.warwick.ac.uk/jseden.dcs.warwick.ac.uk</a>.</p>
<p>and execute the following command in the EDEN Interpreter Window:</p>
<p><code>include(\"models/Onward2012/run.js-e\")</code>.
<p>
The environment can seamlessly switch between presentation and commentary-interface-development environment for an artefact
</p
<p>
<jseden>
ixpara = 1;
include(\"models/cs405/JUGSinJS-E/jugspres.e\");</jseden>
</p>
<p>
To return to the presentation requires just the five redefinitions listed in the procedure:
<jseden>
restoreSlidePres();
</jseden>";

proc restoreSlidePres {
	slideList is [dummy1, dummy2, dummy3];
	currentSlide = 1;
	
	slides is [buttonPrev, buttonNext, (currentSlide == 1) ? slideX : ((currentSlide == 2) ? Slide(paraSlideAux[currAuxSlide]) : slideStream3)];
	picture is [textdisp, nextsentence, nextparagraph, backbutt, header, title, buttonProj];
	buttonPrev is SlideButton("buttonPrev","<<", jspeleft-155, ${{ $('#jspe').height()+15 }}$, buttonPrevEnabled);
	buttonNext is SlideButton("buttonNext","Stream " // str(currentSlide) // " >>", jspeleft-120,  ${{ $('#jspe').height()+15 }}$, buttonNextEnabled);
}

paraSlideRestorePres is "<p>
To return to the presentation requires just the five redefinitions listed in the procedure:
<jseden>
restoreSlidePres();
</jseden>
";

######################################

paraSlideSoftExp is "<h3>SOFTWARE AND EXPERIENCE</h3>
<p>
<ol>
<b>
<li>Software and Experience</li>
<li>Fortran / TM experience - two kinds of experience of programming</li>
</b>
<li>Hermeneutic and formalist perspectives</li>
<li>Maths and computer science from an experiential perspective</li>
<li>Beyond a 'computational thinking' perspective on computing</li>
<li>Software development, learning and <i>construction</i></li>
<li>Empirical Modelling</li>
<li>Retrospect and Prospect</li>
</ol>
</p>";
paraSlideFormalHermeneutic is "<h3>FORMALIST AND HERMENEUTIC PERSPECTIVES</h3>
<p>
<ol>
<li>Software and Experience</li>
<li>Fortran / TM experience - two kinds of experience of programming</li>
<b>
<li>Hermeneutic and formalist perspectives</li>
<li>Maths and computer science from an experiential perspective</li>
<li>Beyond a 'computational thinking' perspective on computing</li>
</b>
<li>Software development, learning and <i>construction</i></li>
<li>Empirical Modelling</li>
<li>Retrospect and Prospect</li>
</ol>
</p>";
paraSlideModSpaceSense is "<h3>MODELLING IN THE SPACE OF SENSE</h3>
<p>
<ol>
<li>Software and Experience</li>
<li>Fortran / TM experience - two kinds of experience of programming</li>
<li>Hermeneutic and formalist perspectives</li>
<li>Maths and computer science from an experiential perspective</li>
<li>Beyond a 'computational thinking' perspective on computing</li>
<b>
<li>Software development, learning and <i>construction</i></li>
<li>Empirical Modelling</li>
<li>Retrospect and Prospect</li>
</b>
</ol>
</p>";
paraSlideCayley is "<p><img src='http://www2.warwick.ac.uk/fac/sci/dcs/research/em/Cayley.gif'></p>.";
paraSlideLogicExp is "<p><img src='http://www2.warwick.ac.uk/fac/sci/dcs/research/em/LogicExp.gif'>";
paraMindFollRules is "<p><img src='http://www2.warwick.ac.uk/fac/sci/dcs/research/em/mindfollrules.gif'>";
paraSlideTouristNative is "<p><img src='http://www2.warwick.ac.uk/fac/sci/dcs/research/em/touristnative.gif'>";
paraSlideFormHerm is "<p><img src='http://www2.warwick.ac.uk/fac/sci/dcs/research/em/formheum2.gif'>";
paraSlideEMconstrual is "<p><img src='http://www2.warwick.ac.uk/fac/sci/dcs/research/em/basicconstrual.gif'>";
paraSlideDefaultAux is "<i>AUXILIARY SLIDE</i>";
## paraSlideEMconstrual is "<p><img src='http://www2.warwick.ac.uk/fac/sci/dcs/research/em/basicconstrual.gif' height=225 width=270>

paraSlideWestFormalismMC is "<b>" // mkTextblock("", 14, [3]) // "</b>"; ## West on formalism and the m/c
paraSlideTMpalin is "<p><img src='http://www2.warwick.ac.uk/fac/sci/dcs/research/em/tmpalin.gif'>";

paraSlideAck is "<b>Acknowledgements</b> <ul><li>Tim Monks</li><li>Nick Pope</li><li>Antony Harfield</li><li>Matthew Cranham</li><li>Russell Boyatt</li><li>Steve Russ</li><li>Megan Beynon</li><li>David West</li><li>Two anonymous reviewers</li></ul>";

## paraSlideAux = [paraSlideDefaultAux, paraSlideSoftExp, paraSlideFormalHermeneutic, paraSlideKeyword, paraSlideCayley, paraSlideFormHerm, paraSlideLogicExp, paraMindFollRules, paraSlideTouristNative, paraSlideModSpaceSense, paraSlideEMconstrual];

paraSlideAux = [paraSlideDefaultAux, paraSlideSoftExp, paraSlideFormalHermeneutic, paraSlideCayley, paraSlideFormHerm, paraSlideLogicExp, paraMindFollRules, paraSlideTouristNative, paraSlideModSpaceSense, paraSlideEMconstrual, paraSlideWestFormalismMC, paraSlideTMpalin, paraSlideAck];

func setauxSlide {
	para indexpara, indexsentence;
	result = 1;
	if ((keyword=="Naur")&& (indexpara==1)) result = 11;
	if ((indexpara==31) &&(indexsentence>3)) result = (indexsentence<6) ? 7 : 8;
	if ((indexpara>178) && (indexpara<186)) result = 2;
	if ((indexpara==184) && (indexsentence>1)) result = 12;
	if (indexpara==188) result = 4;
	else
	if (indexpara==190) result = (indexsentence<5) ? 6 : 5;
	else
	if ((indexpara>185) && (indexpara<191)) result = 3;
	else 
	if (indexpara==191) result = (indexsentence>1) ? 10 : 9;
	if (indexpara==192) result = 13;
	return result;
}

currAuxSlide is setauxSlide(ixpara, ixsentence);

/* 

SOFTWARE AND EXPERIENCE

178:title, 179:contents, 180:Lived-Live, 181:Lived-loved-livid, 
182:Fortran, 183:Essence-Accident, 184:TuringMachine, 185:TwoTooExtreme

FORMALIST AND HERMENEUTIC PERSPECTIVES

186:West-Hermeneutics, 187:Stance-on-Perspectives, 188:Bell-on-Cayley


MODELLING IN THE SPACE OF SENSE



*/

## 48: EM intro

slideList is [dummy1, dummy2, dummy3]; ## needed in order to make currentSlide = 1/2/3 controllable by the Previous / Next buttons - otherwise redundant
## slideStream3 is (ixpara==189) ? Slide(paraSlideTopics) : ((ixpara==192) ? Slide(paraSlidePractEM): ((ixpara==193) ? Slide(paraSlideRestorePres) : Slide(paraSlideKeyword)));
slideStream3 is (ixpara==189) ? Slide(paraSlideTopics) : ((ixpara==192) ? Slide(paraSlidePractEM): Slide(paraSlideKeyword));
slides is [buttonPrev, buttonNext, (currentSlide == 1) ? slideX : ((currentSlide == 2) ? Slide(paraSlideAux[currAuxSlide]) : slideStream3)];

showObservables("paragraphs|notes|abst|ixpara|ixsent|curr");

nextparalab is "P:" // str(ixpara) // "/" // str(paragraphs#) // " >>";
nextsentencelab is "S:" // str(sentencessofar) // "/" // str(allsentences#) // ">>";
nextsentence is Button("nextsent", nextsentencelab, jspeleft-400, ${{ $('#jspe').height()+15 }}$, nextsentenceenabled);
nextparagraph is Button("nextpara", nextparalab, jspeleft-500, ${{ $('#jspe').height()+15 }}$, nextparaenabled);

backbutt is Button("lastpara", "<<", jspeleft-535, ${{ $('#jspe').height()+15 }}$, ixpara>1);

buttonPrev is SlideButton("buttonPrev","<<", jspeleft-155, ${{ $('#jspe').height()+15 }}$, buttonPrevEnabled);
buttonNext is SlideButton("buttonNext","Stream " // str(currentSlide) // " >>", jspeleft-120,  ${{ $('#jspe').height()+15 }}$, buttonNextEnabled);

centredSlides = [1,4,5,6,7,8,10,12];

func isinlist {
	para ix, ls;
	auto i, result;
	result = 0;
	for (i = 1; i<=ls#; i++) {
		if (ls[i]==ix) result = 1;
	}
	return result;
}

proc alignSlides : currAuxSlide, currentSlide {
  	${{
		$('#jspe_slide').css("text-align","left");
	}}$;
	if (currentSlide == 2) {
		if (isinlist(currAuxSlide, centredSlides)) {
			${{
				$('#jspe_slide').css("text-align","center");
			}}$;
		}
	}
}

## binding stream change actions to the keyboard

${{ $(document).bind('keydown', 'down', function () { $('#jspe_buttonPrev').click(); }); }}$;
${{ $(document).bind('keydown', 'up', function () { $('#jspe_buttonNext').click(); }); }}$;
${{ $(document).bind('keydown', 'left', function () { $('#canvas_lastpara').click(); }); }}$;
${{ $(document).bind('keydown', 'right', function () { $('#canvas_nextsent').click(); }); }}$;


ixpara = 178;
