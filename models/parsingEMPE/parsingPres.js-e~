slideList is[slidei, slide1,slide1a, slide2,slide2a, slide3,slide4,slide5,slide6,slide7,slide8,slide9,slide10,slide11,slide12,slide13,slide14,slide15,slide16,slide17,slide18,slide19,slide20,slide21,slide22,slide23,slide24,slide25];

slidei is Slide("<h3>Hui Zhu's JS-EDEN parsing model: a tutorial</h3> <p> Traditional parsers are often implemented using parser generator tools, such as the UNIX utilities Flex and Bison. The full details of the parsing techniques used by Flex and Bison are beyond the scope of this tutorial, but the general principles will be illustrated by making an EM construal. Before tracing the stages in the development of the construal, we first demonstrate it in operation in a simple application: transforming an arithmetic expression in '+' and '*' into postfix (\"Reverse Polish\") notation.</p>");

slide1 is Slide("<h3>Exploring and understanding the JS-EDEN Parsing model</h3>

<p>
The JS-EDEN parsing model is an EM construal of a traditional parser.
Making the construal exposes the 
whole process of parsing in detail.
In its fully developed form the construal can also be used to parse given strings according to a specified grammar.
</p>
<p>
Because the model serves as a parser written in JS-EDEN, it enables users
to write a model in a new notation without
using any external compiler.
It also benefits students of parsing theory who can gain 
understanding of the process of parsing through exploring the model.


</p>
<p>
Before tracing the construction of the parsing model in detail,
we first illustrate key features of the complete model.

</p>
");

slide1a is Slide("
<h3>Exercising the completed parsing model</h3>
<p>
When Flex and Bison are used to generate a parser for a grammar, a
crucial step is the construction of a finite state machine (FSM) that is
based on the grammar. 
</p>
<p>
The graph on the default HTML5 Canvas is a visualisation of the FSM
that is generated from the following simple expression grammar:
<pre>
E &rarr; E+T
E &rarr; T


T &rarr; T*F
T &rarr; F

F &rarr; (E)
F &rarr; <i>id</i>

</pre> 

In this grammar, the terminal symbol <i>id</i> refers either to
a specific numerical value or to an identifier which has a numerical value
associated with it. 

The non-terminal symbol E stands for an arbitrary arithmetic expression
in + and * in which the operands are numbers or identifiers with an associated
numerical value.
</p>
<p>
Note that this grammar (which is taken from teaching resources published at the University of Alaska Fairbanks at the url http://www.cs.uaf.edu/~cs631/aho/y.output) is rather ill-suited to automated parsing. It is however quite a good example for the purposes of EM construal. 
</p>


");



slide2 is Slide("
<b>

The FSM derived from the grammar

</b>

<p>

The FSM depicted on the default HTML5 Canvas is derived from a textual
representation that can be produced by Flex and Bison.

To display
<ul>
<li>the grammar in the form in which it is entered into the Bison
specification of the parser</li>
</ul>
together with
<ul>
<li>the FSM machine in the textual form which is generated in the file y.output
</li>
</ul>you can execute the following JS-EDEN code:
</p>

<jseden>

include(\"models/parsingEMPE/funcGrammar.js-e\");
</jseden>

<p>
To restore the visualisation of the FSM, you should then execute the following 
code:

<jseden>
picture is nodes//edges//nodeLabels//edgeLabels;

</jseden>

</p>

<p>
The 13 states of the FSM are linked by transitions associated with the terminal and non-terminal symbols in the grammar.
These edges are labelled by their corresponding symbols, and are also colour coded accordingly.
The initial state of the FSM is state 0 and the final state is state 7. The FSM makes transitions
from state to state as the parse proceeds and in the process builds up a path within the FSM.
The edges of this path are displayed in black.
</p>

");



slide2a is Slide("
<p>
We can illustrate parsing using the construal with a simple example: the conversion of the expression
a*(b+3*(b+c)) into reverse Polish notation. To follow the parsing process step-by-step, dispose the panels on the display
so that the finite state machine and the Canvas panels view_3, view_4 and vew_5 are visible. To initialise the parse,
then execute:
</p>
<jseden>
inputstr = \"a*(b+3*(b+c))\";
</jseden>
</p>
You will notice that the input string is registered in view_5 and (after lexical analysis) is represented as a string of tokens of the form
\"i*(i+i*(i+i))\", where i here represents an instance of an ID terminal symbol.
</p>
<p>
The parser reads the input string from left to right. There are two basic operations - <b>shift</b> and <b>reduce</b>.
A shift operation transfers the next symbol from the input string to the stack that is depicted in view_4.
A reduce operation replaces the top segment of the stack by a single non-terminal symbol in accordance with the grammar rules set out in view_3.
These operations can be performed manually by pressing the <b>Next Step</b> and <b>Apply Rule</b> buttons, which correspond to shift and reduce respectively.  
</p>


");


slide3 is Slide("
<h3>Setting up the Model and Grammar information</h3>
<p>
In order to achieve this, we can use a list with 12 elements because the finite state machine has 12 states</p>


<p>
For example, from the grammar, we see that in state 1, reading a LPAREN, we should go
<br/> to state 4. This piece of information will be stored in the list as a 3-tuple element of the first entry,[1,\"LPAREN\",4];
</p>
<p>
Even though we can use a list to store grammar information, transforming all the information manually is still a tiresome work. To avoid this, we could use a file mkeden(to be run in 
sed environment):</p>
<a href=models/parsingEMPE/mkeden.txt target=_blank>mkeden file</a><br/><br/>

The mkeden file will transform the grammar information in to an eddi table named transformations. According to the Eddi table, we can make a corresponding EDEN list with 12 states. The list
should be like
<jseden>include(\"models/parsingEMPE/TransitionsPicture.js-e\");</jseden>

");
slide4 is Slide("
<h3>Setting up the parsing model environment</h3>
<p>To set up the parsing model, execute the code below: </p>
<jseden>include(\"models/parsingEMPE/parsingModelRun.js-e\");</jseden>

<p>
Now we have a plain canvas. In order to understand how traditional parser works, the next thing to do
is to make a visualisation of the finite state machine on the canvas.
</p>

<p>
We are going to use the graph tool in JS-Eden. Before starting adding something to the canvas,
we need to set values for two observables: numberOfNodes(number of states) and numberOfSyms(number of symbols appeared in the grammar).
</p>

<jseden>numberOfNodes=13;
numberOfSyms=8;</jseden>

");

slide5 is Slide("
<p><b>Visualisation of the finite state machine</b>:Nodes
<jseden>addNode(mygraph,\"s0\");</jseden><br/>
The red node on the canvas is a graph representation of node 0(state 0).
Of course, we want to have more:<br/>
<jseden>addNode(mygraph,\"s1\");
addNode(mygraph,\"s2\");
addNode(mygraph,\"s3\");</jseden>
We will add a label to each node to distinguish the nodes.
<jseden>makeNodeLabel(0);
makeNodeLabel(1);
makeNodeLabel(2);
makeNodeLabel(3);</jseden>
Following this procedure, we can draw all the 12 nodes on the canvas:
<jseden>addNode(mygraph,\"s4\");makeNodeLabel(4); addNode(mygraph,\"s5\");makeNodeLabel(5);
addNode(mygraph,\"s6\");makeNodeLabel(6); addNode(mygraph,\"s7\");makeNodeLabel(7);
addNode(mygraph,\"s8\");makeNodeLabel(8); addNode(mygraph,\"s9\");makeNodeLabel(9);
addNode(mygraph,\"s10\");makeNodeLabel(10); addNode(mygraph,\"s11\");makeNodeLabel(11);
addNode(mygraph,\"s12\");makeNodeLabel(12);</jseden>
</p>

");
slide6 is Slide("
<p>

<h3><b>Visualisation of the finite state machine</b>: Edges</h3>
Edges mean transitions between states and can be added to the canvas.
<jseden>addEdge(mygraph,\"s0\",\"s4\");</jseden><br/>
We can see an arrowed line pointing from source(s1) to target(s4), which indicates there is an available transition
from state 0 to state 4.
<br/>
A label for an edge means the symbol to be read in order to carry out this transition. From the grammar, we know that
the symbol for transition from state 1 to state 4 is LPAREN(\"(\").
<jseden>makeEdgeLabel(0,4);</jseden>
Consequently, according to the actual transitions from the grammar, the rest of the edges can be shown on the canvas:
<jseden>addEdge(mygraph,\"s0\",\"s5\"); makeEdgeLabel(0,5); addEdge(mygraph,\"s0\",\"s3\"); makeEdgeLabel(0,3);
addEdge(mygraph,\"s0\",\"s2\"); makeEdgeLabel(0,2);  addEdge(mygraph,\"s0\",\"s1\"); makeEdgeLabel(0,1);
addEdge(mygraph,\"s2\",\"s1\"); makeEdgeLabel(2,1);  addEdge(mygraph,\"s2\",\"s2\"); makeEdgeLabel(2,2);
addEdge(mygraph,\"s2\",\"s6\"); makeEdgeLabel(2,6);  addEdge(mygraph,\"s2\",\"s4\"); makeEdgeLabel(2,4);
addEdge(mygraph,\"s2\",\"s5\"); makeEdgeLabel(2,5);  addEdge(mygraph,\"s3\",\"s7\"); makeEdgeLabel(3,7);
addEdge(mygraph,\"s3\",\"s8\"); makeEdgeLabel(3,8);  addEdge(mygraph,\"s4\",\"s9\"); makeEdgeLabel(4,9);
addEdge(mygraph,\"s6\",\"s8\"); makeEdgeLabel(6,8); addEdge(mygraph,\"s6\",\"s10\"); makeEdgeLabel(6,10);  
addEdge(mygraph,\"s8\",\"s11\"); makeEdgeLabel(8,11); addEdge(mygraph,\"s8\",\"s5\"); makeEdgeLabel(8,5);
addEdge(mygraph,\"s8\",\"s1\"); makeEdgeLabel(8,1); addEdge(mygraph,\"s8\",\"s2\"); makeEdgeLabel(8,2);
addEdge(mygraph,\"s9\",\"s1\"); makeEdgeLabel(9,1);  addEdge(mygraph,\"s9\",\"s2\"); makeEdgeLabel(9,2);
addEdge(mygraph,\"s9\",\"s12\"); makeEdgeLabel(9,12); addEdge(mygraph,\"s11\",\"s9\"); makeEdgeLabel(11,9);  
</jseden>
</p>
");
slide7 is Slide("
<h3>Change the Graph</h3>

<p>
In addition to displaying nodes and edges on the canvas, you can also moving them by clicking.
A procedure is required to move each node on the canvas:
<jseden>proc mouseMove_s1: mousePressed {
if(((mouseX-ps1x)*(mouseX-ps1x)<100 )&&((mouseY-ps1y)*(mouseY-ps1y)<100))
  {	if(mousePressed)	{
	  ps1x is mouseX;
	  ps1y is mouseY;
	} else{
      ps1x = mouseX;
      ps1y = mouseY;
    }
   }
}</jseden><br/>
Now s1 is movable. To move other nodes is routine. Just put the node's name which you like to move
in place of s1 in the above code. <br/>
However the whole process does not seem fast, you can try to use
the tool definition factory(also available in JS-Eden) to save time. In this session, we won't go
further with the use of definition factory, you can explore it yourself. 
The code to make all the nodes movable:
<jseden>include(\"models/parsingEMPE/moveNodes.js-e\");</jseden>
</p>
");
slide8 is Slide("
<p>
In previous slides, we have stored the grammar information in a JS-Eden list. In addition, we also want 
it to appear on one window, where we can refer to when trying to parse a string manually. 
</p>

<p>
<b>parsingrules</b> is a list which stores the grammar information. It is different from <b>transitions</b>, 
in that each of its entry is one line in the grammar, in the human-readable form  and it does not store any information
about the finite state machine.
<jseden>parsingrules is [line1,line2,line3,line4,line5,line6,line7];
line1=\"$accept: E $end\";
line2=\"1 E: E+T\";
line3=\"2  | T\";
line4 =\"3 T: T*F\";
line5 =\"4   | F\";
line6 =\"5 F: (E) \";
line7 =\"6   | ID \";
</jseden>
<br/>
In the window named \"CANVAS HTML5 view_3\", you will see the grammar information displayed.

</p>
<hr>
The graph adjacent to the slides is the finite state machine, it shows the state of parser at each 
stage. To distinguish between edges traversed and edges not traversed, we are going to make the 
traversed edges to be black, and others to remain in their default color.

<p>In order to do this, we need a function which returns how many times each edge has been traversed, 
and observables responsible for the colours of the edges, then make a dependency on them.
</p></hr>
");
slide9 is Slide("
<h4>
Dependency between the color of the edge and number of times it has been traversed.
</h4>

<p>
<ul>

<li>What mechanisms are used to change the color of the edge?</li>

<li>What observables do we need to model this kind of change?</li> 

</ul>
</p>
<p>
Suppose we have an observable <b>cols0s1</b>, which is the color of the edge s0s1, What kind of dependency do we want?<br/>
We want the color of the edge dependent on the times it has been traversed. Obviously, we need another observable of edge
s0s1 for the number of times it has been traversed.

</p>
<p>
<i>ctxy</i> is a function, which takes three parameters: the start point,the end point of an edge and <i>currpath (observable for current path traversed)</i>,
and returns the number of times that this edge has been traversed. <br/>

So if we make the colour of the edge depend on the number of times it has been traversed, the colours of the edges together will clearly show the path. For edge s0s1,
</p>
<jseden>
cts0s1 is ctxy(0,1,currpath);
cols0s1 is cts0s1>0 ? \"black\": defaultcolour(0,1,transitions[13]);
</jseden>

");

slide10 is Slide("
<p> To define the colours of all the edges:</p>
<jseden>
cts0s1 is ctxy(0,1,currpath);cts0s3 is ctxy(0,3,currpath);
cts0s2 is ctxy(0,2,currpath);cts0s4 is ctxy(0,4,currpath);
cts0s5 is ctxy(0,5,currpath);cts2s1 is ctxy(2,1,currpath);
cts2s6 is ctxy(2,6,currpath);cts2s2 is ctxy(2,2,currpath);
cts2s4 is ctxy(2,4,currpath);cts2s5 is ctxy(2,5,currpath);
cts3s7 is ctxy(3,7,currpath);cts3s8 is ctxy(3,8,currpath);
cts4s9 is ctxy(4,9,currpath);cts6s8 is ctxy(6,8,currpath);
cts6s10 is ctxy(6,10,currpath);cts8s1 is ctxy(8,1,currpath);
cts8s5 is ctxy(8,5,currpath);cts8s2 is ctxy(8,2,currpath);
cts8s11 is ctxy(8,11,currpath);cts9s1 is ctxy(9,1,currpath);
cts9s2 is ctxy(9,2,currpath);cts9s12 is ctxy(9,12,currpath);
cts11s9 is ctxy(11,9,currpath);


</jseden>
");


slide11 is Slide("
<jseden>
cols0s1 is cts0s1>0 ? \"black\": defaultcolour(0,1,transitions[13]);
cols0s2 is cts0s2>0 ? \"black\": defaultcolour(0,2,transitions[13]);
cols0s3 is cts0s3>0 ? \"black\": defaultcolour(0,3,transitions[13]);
cols0s4 is cts0s4>0 ? \"black\": defaultcolour(0,4,transitions[13]);
cols0s5 is cts0s5>0 ? \"black\": defaultcolour(0,5,transitions[13]);
cols2s1 is cts2s1>0 ? \"black\": defaultcolour(2,1,transitions[2]);
cols2s2 is cts2s2>0 ? \"black\": defaultcolour(2,2,transitions[2]);
cols2s4 is cts2s4>0 ? \"black\": defaultcolour(2,4,transitions[2]);
cols2s5 is cts2s5>0 ? \"black\": defaultcolour(2,5,transitions[2]);
cols2s6 is cts2s6>0 ? \"black\": defaultcolour(2,6,transitions[2]);
cols3s7 is cts3s7>0 ? \"black\": defaultcolour(3,7,transitions[3]);
cols3s8 is cts3s8>0 ? \"black\": defaultcolour(3,8,transitions[3]);
cols4s9 is cts4s9>0 ? \"black\": defaultcolour(4,9,transitions[4]);
cols6s8 is cts6s8>0 ? \"black\": defaultcolour(6,8,transitions[6]);
cols6s10 is cts6s10>0 ? \"black\": defaultcolour(6,10,transitions[6]);
cols8s1 is cts8s1>0 ? \"black\": defaultcolour(8,1,transitions[8]);
cols8s2 is cts8s2>0 ? \"black\": defaultcolour(8,2,transitions[8]);
cols8s5 is cts8s5>0 ? \"black\": defaultcolour(8,15,transitions[8]);
cols8s11 is cts8s11>0 ? \"black\": defaultcolour(8,11,transitions[8]);
cols9s1 is cts9s1>0 ? \"black\": defaultcolour(9,1,transitions[9]);
cols9s2 is cts9s2>0 ? \"black\": defaultcolour(9,2,transitions[9]);
cols9s12 is cts9s12>0 ? \"black\": defaultcolour(9,12,transitions[9]);
cols11s9 is cts11s9>0 ? \"black\": defaultcolour(11,9,transitions[11]);
</jseden>
");


slide12 is Slide("
<p>Key Observables:</p>
<b>currpath</b>     - stores the content on the state stack as a list.<br/>

<b>currstack</b>     - current content on the stack as a list.<br/>
<b>currrule</b>     - the number of the grammar rule the parser determines that all the items on the right-hand side of which have been seen(the production by which the parser reduces).<br/>

<b>currrstate</b>    - current state of the parser (the last element of the currpath, or the top element on the stack state).<br/>
<br/>
<b>nextsymbol</b>   - represents the look ahead token.<br/>
<br/>
<b>isreduction</b>  - reads the transformations table and decides if the parser should reduce in the current state. If there is a shift-reduce conflict, it always chooses to shift.<br/>
<br/>

<b>InputText</b>	  - the input string, stays the same all the time.<br/>

<b>InputTextt</b>   - same as the input string at the beginning, but changes according to the reduction.<br/>
<br/>
<b>k</b>			  - the index of the current symbol in the InputText (how far we have read in the InputText).<br/>
<b>j</b>			  - the index of the current symbol in the InputTextt (how far we have read in the InputTextt).<br/>
The observables k and j are used to control how many tokens the parser has read from the input. The values of k and j are increased by 1 every time the \"next step\" button is clicked.

");
slide13 is Slide("<p>

<h3>Making dependencies</h3>

<p>
The observables whose values are subject to be changed directly by an agent action, rather than being defined by a dependency relation, are InputText and k. <br/>
This network of dependency is derived from the real traditional parsers: The input and how far the parser has read from the beginning defines the look ahead token;<br/>
The shift action pops a token and a state onto the stack; Based on its current state, the model decides whether it needs a look ahead token to carry out the next action,<br/>
or whether it should reduce.<br/>
The observable<i>InputTextt</i> has the same initial value as <i>InputText</i> and changes when reduction occurs. An index <i>j</i> is associated to measure how far the parser has read in the<br/>
<i>InputTextt</i>. Like <i>InputText</i>, <i>InputTextt</i> is independent of other observables and the observables <i>currstack</i>, <i>currpath</i>, <i>currstate</i>,etc depend on it.<br\>

The dependencies between key observables:
<jseden>
k=0;
InputText=\"\";
InputTextt = InputText//\"$\";
InputTextEnd = oneline(InputText)//\"$\";

j is InputTextt#-nextpart#;
currstack is makestack(stringtolist(substr(InputTextt,1,j)));
currpath is makepath(currstack);
currstate is findstate(currpath);
nextsymbol is strplus(substr(InputTextEnd,k+1,k+1),currstate);
nextpart is substr(InputTextEnd,k+1,InputTextEnd#);
</jseden>

</p>

");

slide14 is Slide("
<p>
<b>
Lexical Analysis
</b>
</p>
<p>

The lexical analysis part of parsing models in JS-EDEN is different from the lexical analysis of the traditional parser. This is done by using the function subpatt, which is an example of embedding JavaScript in EDEN:
<jseden>
func substpatt { 
&#36;{{ var th = arguments[0]; 
	var repatt = arguments[1]; 
	var reattr = arguments[2]; 
	var repstr = arguments[3]; 
	return th.replace(RegExp(repatt, reattr), repstr); 
}}&#36;; }
</jseden>
This function recognizes regular expressions and the set of tokens are defined by regular expressions. 
</p>
<p>If an input string is given, the model should find IDs and exprs, and mark them as identifiers.</p>
<jseden>
proc makeinputtext : inputstr{
InputText=inputstr;

InputText = substpatt(InputText,\"[A-Za-z][a-zA-Z0-9]*\",\"g\",\"i\");
InputText = substpatt(InputText,\"[0-9]+\",\"g\",\"i\");
InputTextEnd = oneline(InputText)//\"$\";
InputTextt=InputText//\"$\";
}
</jseden>

");

slide15 is Slide("
<h3>Input values</h3>

<p>

Using the subspatt function, we substitute values in the input by lexified tokens. And we want to keep a record of the original input values, and store them into a list.

</p>

<p>
The record of the input values, can be used in the last step of parsing - syntax directed translation. So we make a function named <i>makeinputvals</i>. This function will be different
for different grammars. It makes uses of the function findpatt(which finds and returns a regular string):</p>
<jseden>
func findpatt { 
&#36{{ var th = arguments[0];
	var repatt = arguments[1];
	var reattr = arguments[2]; 
	var result = th.match(RegExp(repatt, reattr));
	if(result==null)
        return \"\";
        else return result; 
	}}&#36;;
	}
</jseden>
<p> and analyzes the input to many cases. <i>strvals</i> stores the values of the input string to a list. Below is the definition for <i>strvals</i>.</p> 
<jseden>
strvals is findpatt(inputstr,\"[A-Za-z][a-zA-Z0-9]*|[1-9][0-9]*\",\"g\");
</jseden>
Can you make a <i>makeinputvals</i> function for the func3 grammar? After please include the function in the input window. 

");

slide16 is Slide("
<jseden>
func makeinputvals {
para input, val;
auto i,j,result,found,vals;
vals=val.slice(0);
j=1;result=[];
   for(i=1;i<=input#;i++)
    {	if(input[i]==\"i\")
		{
			for(j=1;j<=vals#;j++)
			{  if (findpatt(vals[j],\"[A-Za-z][a-zA-Z0-9]*\",\"g\") != \"\")
				{			
					result=result//vals[j];
					vals[j]=\"\";	
					break;	
				}
				else if (findpatt(vals[j],\"[0-9]+\",\"g\") != \"\")
				{
					result=result//vals[j];
					vals[j]=\"\";
					break;
				}
			}
			
         }else {result=result//[\"\"];}				
    }
	return result;
}
</jseden>
");

slide17 is Slide("
<h3>Shift and Reduce</h3>

<p>

When the value of <i>k</i> increases 1, the parsing model reads the next token and shifts. In some certain points of the parsing, the parsing model should reduce according to the grammar rules. This means that it should change some thing on the top of the stack. So to do reduction, we make functions which takes <i> InputTextt</i> as parameter, and returns the changed value of <i> InputTextt</i>.

</p>

<p>
In grammar, we have 6 reductions rules:</p>
$accept: E $end\";<br/>
1 E: E+T;<br/>
2  | T;<br/>
3 T: T*F;<br/>
4   | F;<br/>
5 F: (E) ;<br/>
6   | ID ;<br/>

</p>

<p>

</p>

<jseden>
func substituteID{
	para cstack;
	auto result;
	if(currstack#-1>0)
	result=substr(cstack,1,currstack#-1)//\"F\"//nextpart;
	else
	result=\"F\"//nextpart;
	return result;
	}
</jseden>
");
slide18 is Slide(" 
<jseden>	
func substituteEplusT{
        para cstack;
	auto result;
	if(currstack#-3>0)
	result=substr(cstack,1,currstack#-3)//\"E\"//nextpart;
	else
	result=\"E\"//nextpart;

	return result;
	}
func substituteT{
	para cstack;
	auto result;
	if(currstack#-1>0)
	result=substr(cstack,1,currstack#-1)//\"E\"//nextpart;
	else
	result=\"E\"//nextpart;

	return result;
	}
func substituteTmultiF{
	para cstack;
	auto result;
	if(currstack#-3>0)
	result=substr(cstack,1,currstack#-3)//\"T\"//nextpart;
	else
	result=\"T\"//nextpart;

	return result;
	}
</jseden>
");
slide19 is Slide("
<jseden>	
func substituteF{
	para cstack;
	auto result;
	if(currstack#-1>0)
	result=substr(cstack,1,currstack#-1)//\"T\"//nextpart;
	else
	result =\"T\"//nextpart;

	return result;
	}
	
func substituteEbrackets{
	para cstack;
	auto result;
	if (currstack#-3>0)
	result=substr(cstack,1,currstack#-3)//\"F\"//nextpart;
	else
	result=\"F\"//nextpart;
	return result;
	}
</jseden>");

slide20 is Slide("
<p> Then we need a function to decide which of the substitute function should be called: 
<jseden>
func applyrule{
	para ruleno;
       if (ruleno==1)
	execute(\"InputTextt=substituteEplusT(InputTextt);\");
	else if (ruleno==2)
	execute(\"InputTextt=substituteT(InputTextt);\");
	else if (ruleno==3)
	execute(\"InputTextt=substituteTmultiF(InputTextt);\");
	else if (ruleno==4)
	execute(\"InputTextt=substituteF(InputTextt);\");
	else if (ruleno==5)
	execute(\"InputTextt=substituteEbrackets(InputTextt);\");
	else if (ruleno==6)
	execute(\"InputTextt=substituteID(InputTextt);\");
	else
	execute(\"InputTextt=InputTextt;\");
}</jseden>
");

slide21 is Slide("
<h3>Syntax Directed Translation</h3>

<p> 
In parallel with the observables <i> InputTextt</i> and <i> currstack</i>, we have observables<i> inputvals </i> and <i>stackvals</i> to record the values of the input.
When the parsing model reduces by rule 1, the <i> inputvals</i> is not changed. But when it reduces by rule 2, the <i> inputvals</i> changes as it combines the eight elements to one entry.
</p>
<jseden>

func substituteEplusT2{
	para vals;
	auto calc, result;
	calc=j;
	if(calc-3>0)
	result=sublist(vals,1,calc-3)//[vals[calc-2]//\" \"//vals[calc]//\"+\"]//nextvals;
	else
	result=[vals[calc-2]//\" \"//vals[calc]//\"+\"]//nextvals;
	return result;
}
func substituteTmultiF2{
	para vals;
	auto calc, result;
	calc=j;
	if(calc-3>0)
	result=sublist(vals,1,calc-3)//[vals[calc-2]//\" \"//vals[calc]//\"*\"]//nextvals;
	else
	result=[vals[calc-2]//\" \"//vals[calc]//\"*\"]//nextvals;
	return result;
}
</jseden>");
slide22 is Slide("
<jseden>
func substituteEbrackets2{
	para vals;
	auto calc, result;
	calc=j;
	if(calc-3>0)
	result=sublist(vals,1,calc-3)//[vals[calc-1]]//nextvals;
	else
	result=[vals[calc-1]]//nextvals;
	return result;
}	


proc evalrule{
 para ruleno;
if ((ruleno==2)||(ruleno==4)||(ruleno==6))
	 execute(\"inputtvals=inputtvals;\");
    else if (ruleno==1)
	 execute(\"inputtvals=substituteEplusT2(inputtvals);\");
    else if (ruleno==3)
 	
	execute(\"inputtvals=substituteTmultiF2(inputtvals);\");
    else if (ruleno ==5)
        execute(\"inputtvals=substituteEbrackets2(inputtvals);\");

    
	 }
</jseden>

");

slide23 is Slide("
<h3>Parsing Input</h3>
<p>
Finally we have set up the environment for parsing. We can try to give some input string and the parser will do the lexical analysis and produce an input text.
<jseden>
inputstr=\"a+b*3+(d+e)\";
</jseden>
Above is an input string accepted by the parser. You can also try some input string which is not accepted:
<jseden>
inputstr=\"p**f\";
</jseden>
and
<jseden>
inputstr=\"3+*5\";
</jseden>
</p>

");
