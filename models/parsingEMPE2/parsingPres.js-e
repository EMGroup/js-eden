slideList is[slide1,slide2,slide3,slide4,slide5,slide6,slide7,slide8,slide9,slide10,slide11,slide12,slide13,slide14,slide15,slide16,slide17,slide18,slide19,slide20,slide21,slide22];
slide1 is Slide("<h3>Exploring and understanding JS-Eden Parsing model</h3>



<b>Guidance for exploring JS-EDEN parsing model using the EM presentation environment</b>

<p>

This session is an example of exploring JS-Eden parsing model with the expression grammar.


</p>


<p>
JS-Eden parsing model is a simulation of traditional parser with EM spirits. It demonstrates the 
whole process of parsing in detail and parses given strings according to certain grammar.
</p>
<p>
The model is a parser written in JS-Eden, which allows users to write a model in a new notation without
using any external compiler. It also benefits users who are interested in parsing theory, making them 
understand the process of parsing during their exploring.


</p>
");
slide2 is Slide("
<b>

Setting up the Model and Grammar information

</b>

<p>

In this session we are using the expression grammar as an example. First let us learn about the expression
grammar by executing the code below.
</p>

<jseden>

include(\"models/parsingEmpe/funcGrammar.js-e\");
</jseden>

<p>
The first four lines shows the accept string and the reduction rules.<br/>
The remaining part is the finate state machine generated by the Yacc.<br/>
expr- expression symbol:e<br/>
ID- identifier symbol:i<br/>
func-function symbol:f<br/>
LPAREN-left parenthesis symbol:(<br/>
RPAREN-right parenthesis symbol:)<br/>
</p>

<p>
The grammar displayed on the canvas is for us to learn about, JS-Eden do not understand this file.</p>
<p>Hence we should transform the information of grammar into some form which JS-Eden can interpret.<br/></p>

");
slide3 is Slide("
<h3>Setting up the Model and Grammar information</h3>
<p>
In order to achieve this, we can use a list with 12 elements because the finite state machine has 12 states</p>


<p>
For example, from the grammar, we see that in state 1, reading a LPAREN, we should go
<br/> to state 4. This piece of information will be stored in the list as a 3-tuple element of the first entry,[1,\"LPAREN\",4];
</p>
<p>
Even though we can use a list to store grammar information, transforming all the information manually is still a tiresome work. To avoid this, we could use a file mkeden(to be run in 
sed environment):</p>
<a href=models/parsingEmpe/mkeden.txt target=_blank>mkeden file</a><br/><br/>

The mkeden file will transform the grammar information in to an eddi table named transformations. According to the Eddi table, we can make a corresponding EDEN list with 12 states. The list
should be like
<jseden>include(\"models/parsingEmpe/funcTransitionsPicture.js-e\");</jseden>

");
slide4 is Slide("
<h3>Setting up the parsing model environment</h3>
<p>To set up the parsing model, execute the code below: </p>
<jseden>include(\"models/parsingEmpe/parsingModelRun.js-e\");</jseden>

<p>
Now we have a plain canvas. In order to understand how traditional parser works, the next thing to do
is to make a visualisation of the finite state machine on the canvas.
</p>

<p>
We are going to use the graph tool in JS-Eden. Before starting adding something to the canvas,
we need to set values for two observables: numberOfNodes(number of states) and numberOfSyms(number of symbols appeared in the grammar).
</p>

<jseden>numberOfNodes=12;
numberOfSyms=7;</jseden>

");

slide5 is Slide("
<p><b>Visualisation of the finite state machine</b>:Nodes
<jseden>addNode(mygraph,\"s0\");</jseden><br/>
The red node on the canvas is a graph representation of node 0(state 0).
Of course, we want to have more:<br/>
<jseden>addNode(mygraph,\"s1\");
addNode(mygraph,\"s2\");
addNode(mygraph,\"s3\");</jseden>
We will add a label to each node to distinguish the nodes.
<jseden>makeNodeLabel(0);
makeNodeLabel(1);
makeNodeLabel(2);
makeNodeLabel(3);</jseden>
Following this procedure, we can draw all the 12 nodes on the canvas:
<jseden>addNode(mygraph,\"s4\");makeNodeLabel(4); addNode(mygraph,\"s5\");makeNodeLabel(5);
addNode(mygraph,\"s6\");makeNodeLabel(6); addNode(mygraph,\"s7\");makeNodeLabel(7);
addNode(mygraph,\"s8\");makeNodeLabel(8); addNode(mygraph,\"s9\");makeNodeLabel(9);
addNode(mygraph,\"s10\");makeNodeLabel(10); addNode(mygraph,\"s11\");makeNodeLabel(11);</jseden>
</p>

");
slide6 is Slide("
<p>

<h3><b>Visualisation of the finite state machine</b>: Edges</h3>
Edges mean transitions between states and can be added to the canvas.
<jseden>addEdge(mygraph,\"s1\",\"s4\");</jseden><br/>
We can see an arrowed line pointing from source(s1) to target(s4), which indicates there is an available transition
from state 1 to state 4.
<br/>
A label for an edge means the symbol to be read in order to carry out this transition. From the grammar, we know that
the symbol for transition from state 1 to state 4 is LPAREN(\"(\").
<jseden>makeEdgeLabel(1,4);</jseden>
Consequently, according to the actual transitions from the grammar, the rest of the edges can be shown on the canvas:
<jseden>addEdge(mygraph,\"s3\",\"s5\"); makeEdgeLabel(3,5); addEdge(mygraph,\"s4\",\"s1\"); makeEdgeLabel(4,1);
addEdge(mygraph,\"s4\",\"s2\"); makeEdgeLabel(4,2);  addEdge(mygraph,\"s4\",\"s6\"); makeEdgeLabel(4,6);
addEdge(mygraph,\"s6\",\"s7\"); makeEdgeLabel(6,7);  addEdge(mygraph,\"s7\",\"s1\"); makeEdgeLabel(7,1);
addEdge(mygraph,\"s7\",\"s2\"); makeEdgeLabel(7,2);  addEdge(mygraph,\"s7\",\"s8\"); makeEdgeLabel(7,8);
addEdge(mygraph,\"s8\",\"s9\"); makeEdgeLabel(8,9);  addEdge(mygraph,\"s9\",\"s1\"); makeEdgeLabel(9,1);
addEdge(mygraph,\"s9\",\"s2\"); makeEdgeLabel(9,2);  addEdge(mygraph,\"s9\",\"s10\"); makeEdgeLabel(9,10);
addEdge(mygraph,\"s10\",\"s11\"); makeEdgeLabel(10,11); addEdge(mygraph,\"s0\",\"s1\"); makeEdgeLabel(0,1);  
addEdge(mygraph,\"s0\",\"s2\"); makeEdgeLabel(0,2); addEdge(mygraph,\"s0\",\"s3\"); makeEdgeLabel(0,3); </jseden>
</p>
");
slide7 is Slide("
<h3>Change the Graph</h3>

<p>
In addition to displaying nodes and edges on the canvas, you can also moving them by clicking.
A procedure is required to move each node on the canvas:
<jseden>proc mouseMove_s1: mousePressed {
if(((mouseX-ps1x)*(mouseX-ps1x)<100 )&&((mouseY-ps1y)*(mouseY-ps1y)<100))
  {	if(mousePressed)	{
	  ps1x is mouseX;
	  ps1y is mouseY;
	} else{
      ps1x = mouseX;
      ps1y = mouseY;
    }
   }
}</jseden><br/>
Now s1 is movable. To move other nodes is routine. Just put the node's name which you like to move
in place of s1 in the above code. <br/>
However the whole process does not seem fast, you can try to use
the tool definition factory(also available in JS-Eden) to save time. In this session, we won't go
further with the use of definition factory, you can explore it yourself. 
The code to make all the nodes movable:
<jseden>include(\"models/parsingEmpe/moveNodes.js-e\");</jseden>
</p>
");
slide8 is Slide("
<p>
In previous slides, we have stored the grammar information in a JS-Eden list. In addition, we also want 
it to appear on one window, where we can refer to when trying to parse a string manually. 
</p>

<p>
<b>parsingrules</b> is a list which stores the grammar information. It is different from <b>transitions</b>, 
in that each of its entry is one line in the grammar, in the human-readable form  and it does not store any information
about the finite state machine.
<jseden>parsingrules is [line1,line2,line3];
line1=\"$accept: expr $end\";
line2=\"1 expr: ID\";
line3=\"2     | func3 LPAREN expr COMMA expr COMMA expr RPAREN\";
</jseden>
<br/>
In the window named \"CANVAS HTML5 view_3\", you will see the grammar information displayed.

</p>
<hr>
The graph adjacent to the slides is the finite state machine, it shows the state of parser at each 
stage. To distinguish between edges traversed and edges not traversed, we are going to make the 
traversed edges to be black, and others to remain in their default color.

<p>In order to do this, we need a function which returns how many times each edge has been traversed, 
and observables responsible for the colours of the edges, then make a dependency on them.
</p></hr>
");
slide9 is Slide("
<h4>
Dependency between the color of the edge and number of times it has been traversed.
</h4>

<p>
<ul>

<li>What mechanisms are used to change the color of the edge?</li>

<li>What observables do we need to model this kind of change?</li> 

</ul>
</p>
<p>
Suppose we have an observable <b>cols0s1</b>, which is the color of the edge s0s1, What kind of dependency do we want?<br/>
We want the color of the edge dependent on the times it has been traversed. Obviously, we need another observable of edge
s0s1 for the number of times it has been traversed.

</p>
<p>
<i>ctxy</i> is a function, which takes three parameters: the start point,the end point of an edge and <i>currpath (observable for current path traversed)</i>,
and returns the number of times that this edge has been traversed. <br/>

So if we make the colour of the edge depend on the number of times it has been traversed, the colours of the edges together will clearly show the path. For edge s0s1,
</p>
<jseden>
cts0s1 is ctxy(0,1,currpath);
cols0s1 is cts0s1>0 ? \"black\": defaultcolour(0,1,transitions[12]);
</jseden>

");

slide10 is Slide("
<p> To define the colours of all the edges:</p>
<jseden>
cts0s1 is ctxy(0,1,currpath);cts0s3 is ctxy(0,3,currpath);
cts0s2 is ctxy(0,2,currpath);cts10s11 is ctxy(10,11,currpath);
cts9s2 is ctxy(9,2,currpath);cts9s1 is ctxy(9,1,currpath);
cts9s10  is ctxy(9,10,currpath);cts8s9 is ctxy(8,9,currpath);
cts4s1 is ctxy(4,1,currpath);cts4s2 is ctxy(4,2,currpath);
cts4s6 is ctxy(4,6,currpath);cts3s5 is ctxy(3,5,currpath);
cts7s1 is ctxy(7,1,currpath);cts7s2 is ctxy(7,2,currpath);
cts7s8 is ctxy(7,8,currpath);cts6s7 is ctxy(6,7,currpath);
cts1s4 is ctxy(1,4,currpath);
</jseden>
");


slide11 is Slide("
<jseden>
cols0s1 is cts0s1>0 ? \"black\": defaultcolour(0,1,transitions[12]);
cols0s2 is cts0s2>0 ? \"black\": defaultcolour(0,2,transitions[12]);
cols0s3 is cts0s3>0 ? \"black\": defaultcolour(0,3,transitions[12]);
cols1s4 is cts1s4>0 ? \"black\": defaultcolour(1,4,transitions[1]);
cols10s11 is cts10s11>0 ? \"black\": defaultcolour(10,11,transitions[10]);
cols9s10 is cts9s10>0 ? \"black\": defaultcolour(9,10,transitions[9]);
cols9s2 is cts9s2>0 ? \"black\": defaultcolour(9,2,transitions[9]);
cols9s1 is cts9s1>0 ? \"black\": defaultcolour(9,1,transitions[9]);
cols8s9 is cts8s9>0 ? \"black\": defaultcolour(8,9,transitions[8]);
cols4s1 is cts4s1>0 ? \"black\": defaultcolour(4,1,transitions[4]);
cols4s2 is cts4s2>0 ? \"black\": defaultcolour(4,2,transitions[4]);
cols4s6 is cts4s6>0 ? \"black\": defaultcolour(4,6,transitions[4]);
cols3s5 is cts3s5>0 ? \"black\": defaultcolour(3,5,transitions[3]);
cols7s8 is cts7s8>0 ? \"black\": defaultcolour(7,8,transitions[7]);
cols7s2 is cts7s2>0 ? \"black\": defaultcolour(7,2,transitions[7]);
cols7s1 is cts7s1>0 ? \"black\": defaultcolour(7,1,transitions[7]);
cols6s7 is cts6s7>0 ? \"black\": defaultcolour(6,7,transitions[6]);
</jseden>
");


slide12 is Slide("
<p>Key Observables:</p>
<b>currpath</b>     - stores the content on the state stack as a list.<br/>

<b>currstack</b>     - current content on the stack as a list.<br/>
<b>currrule</b>     - the number of the grammar rule the parser determines that all the items on the right-hand side of which have been seen(the production by which the parser reduces).<br/>

<b>currrstate</b>    - current state of the parser (the last element of the currpath, or the top element on the stack state).<br/>
<br/>
<b>nextsymbol</b>   - represents the look ahead token.<br/>
<br/>
<b>isreduction</b>  - reads the transformations table and decides if the parser should reduce in the current state. If there is a shift-reduce conflict, it always chooses to shift.<br/>
<br/>

<b>InputText</b>	  - the input string, stays the same all the time.<br/>

<b>InputTextt</b>   - same as the input string at the beginning, but changes according to the reduction.<br/>
<br/>
<b>k</b>			  - the index of the current symbol in the InputText (how far we have read in the InputText).<br/>
<b>j</b>			  - the index of the current symbol in the InputTextt (how far we have read in the InputTextt).<br/>
The observables k and j are used to control how many tokens the parser has read from the input. The values of k and j are increased by 1 every time the \"next step\" button is clicked.

");
slide13 is Slide("<p>

<h3>Making dependencies</h3>

<p>
The observables whose values are subject to be changed directly by an agent action, rather than being defined by a dependency relation, are InputText and k. <br/>
This network of dependency is derived from the real traditional parsers: The input and how far the parser has read from the beginning defines the look ahead token;<br/>
The shift action pops a token and a state onto the stack; Based on its current state, the model decides whether it needs a look ahead token to carry out the next action,<br/>
or whether it should reduce.<br/>
The observable<i>InputTextt</i> has the same initial value as <i>InputText</i> and changes when reduction occurs. An index <i>j</i> is associated to measure how far the parser has read in the<br/>
<i>InputTextt</i>. Like <i>InputText</i>, <i>InputTextt</i> is independent of other observables and the observables <i>currstack</i>, <i>currpath</i>, <i>currstate</i>,etc depend on it.<br\>

The dependencies between key observables:
<jseden>
k=0;
InputText=\"\";
InputTextt = InputText//\"$\";
InputTextEnd = oneline(InputText)//\"$\";

j is InputTextt#-nextpart#;
currstack is makestack(stringtolist(substr(InputTextt,1,j)));
currpath is makepath(currstack);
currstate is findstate(currpath);
nextsymbol is strplus(substr(InputTextEnd,k+1,k+1),currstate);
nextpart is substr(InputTextEnd,k+1,InputTextEnd#);
</jseden>

</p>

");

slide14 is Slide("
<p>
Lexical Analysis</p>
<p>

The lexical analysis part of parsing models in JS-EDEN is different from the lexical analysis of the traditional parser. This is done by using the function subpatt, which is an example of embedding JavaScript in EDEN:
<jseden>
func substpatt { 
&#36;{{ var th = arguments[0]; 
	var repatt = arguments[1]; 
	var reattr = arguments[2]; 
	var repstr = arguments[3]; 
	return th.replace(RegExp(repatt, reattr), repstr); 
}}&#36;; }
</jseden>
This function recognizes regular expressions and the set of tokens are defined by regular expressions. 
</p>
<p>If an input string is given, the model should find IDs and exprs, and mark them as identifiers.</p>
<jseden>
proc makeinputtext : inputstr{
InputText=inputstr;

InputText = substpatt(InputText,\"[A-Ea-e|G-Zg-z][a-zA-Z0-9]*\",\"g\",\"i\");

InputTextEnd = oneline(InputText)//\"$\";
InputTextt=InputText//\"$\";
}
</jseden>

");

slide15 is Slide("
<h3>Input values</h3>

<p>

Using the subspatt function, we substitute values in the input by lexified tokens. And we want to keep a record of the original input values, and store them into a list.

</p>

<p>
The record of the input values, can be used in the last step of parsing - syntax directed translation. So we make a function named <i>makeinputvals</i>. This function will be different
for different grammars. It makes uses of the function findpatt(which finds and returns a regular string):</p>
<jseden>
func findpatt { 
&#36{{ var th = arguments[0];
	var repatt = arguments[1];
	var reattr = arguments[2]; 
	var result = th.match(RegExp(repatt, reattr));
	if(result==null)
        return \"\";
        else return result; 
	}}&#36;;
	}
</jseden>
<p> and analyzes the input to many cases. <i>strvals</i> stores the values of the input string to a list. Below is the definition for <i>strvals</i>.</p> 
<jseden>
strvals is findpatt(inputstr,\"[A-Ea-e|G-Zg-z][a-zA-Z0-9]*\",\"g\")//findpatt(inputstr,\"[0-9]+\",\"g\");
</jseden>
Can you make a <i>makeinputvals</i> function for the func3 grammar? After please include the function in the input window. 

");

slide16 is Slide("
<jseden>
func makeinputvals {
para input, val;
auto i,j,result,found,vals;
vals=val.slice(0);
j=1;result=[];
   for(i=1;i<=input#;i++)
    {	if(input[i]==\"i\")
		{
			for(j=1;j<=vals#;j++)
			{  if (findpatt(vals[j],\"[A-Ea-e | G-Zg-z][a-zA-Z0-9]*\",\"g\") != \"\")
				{			
					result=result//vals[j];
					vals[j]=\"\";	
					break;	
				}
				else writeln(\"syntax error\");
			}
			
         }else {result=result//[\"\"];}
    }
	return result;
}
</jseden>
");

slide17 is Slide("
<h3>Shift and Reduce</h3>

<p>

When the value of <i>k</i> increases 1, the parsing model reads the next token and shifts. In some certain points of the parsing, the parsing model should reduce according to the grammar rules. This means that it should change some thing on the top of the stack. So to do reduction, we make functions which takes <i> InputTextt</i> as parameter, and returns the changed value of <i> InputTextt</i>.

</p>

<p>
In func3 grammar, we have 2 reductions rules:</p>
    1 expr: ID<br/>
    2     | func3 LPAREN expr COMMA expr COMMA expr RPAREN<br/>

</p>

<p>
The first rule says that if an id on the stack, replace it by expr. The second says that if func3 LPAREN expr COMMA expr COMMA expr RPAREN appears on the stack, replace it by expr.
The thing to keep in mind is that after changing the value on the stack, we also need to update the values of <i> j</i>.

</p>

<jseden>
func substituteI{
	para cstack;
	auto result;
	if(currstack#-1>0)
	result=substr(cstack,1,currstack#-1)//\"e\"//nextpart;
	else
	result=\"e\"//nextpart;
	return result;
	}
</jseden>
");
slide18 is Slide(" 
<jseden>	
func substituteFLR{
	para cstack;
	auto size, result;
	size=currstack#-8;
	if(size>0)
	result=substr(cstack,1,size)//\"e\"//nextpart;
	else
	result=\"e\"//nextpart;
	return result;
} 
</jseden>
<p> Then we need a function to decide which of the substitute function should be called: <jseden>
proc applyrule{
	para ruleno;

	
    if (ruleno==1)
	 execute(\"InputTextt=substituteI(InputTextt);\");
    else if (ruleno==2)
	 execute(\"InputTextt=substituteFLR(InputTextt);\");
}</jseden>
");

slide19 is Slide("
<h3>Syntax Directed Translation</h3>

<p> 
In parallel with the observables <i> InputTextt</i> and <i> currstack</i>, we have observables<i> inputvals </i> and <i>stackvals</i> to record the values of the input.
When the parsing model reduces by rule 1, the <i> inputvals</i> is not changed. But when it reduces by rule 2, the <i> inputvals</i> changes as it combines the eight elements to one entry.
</p>
<jseden>
func substituteFLR2{
	para vals;
	auto size,calc, result;
	size=stackvals#-8;
	calc=j;
	if(size>0)
	result=sublist(vals,1,size)//[vals[calc-1]]//nextvals;
	else
	result=[vals[calc-1]]//nextvals;
	return result;
}
</jseden>
<jseden>
proc evalrule{
 para ruleno;
if (ruleno==1)
	 execute(\"inputtvals=inputtvals;\");
    else if (ruleno==2)
	 execute(\"inputtvals=substituteFLR2(inputtvals);\");
	 }
</jseden>

");

slide20 is Slide("
<h3>Parsing Input</h3>
<p>
Finally we have set up the environment for parsing. We can try to give some input string and the parser will do the lexical analysis and produce an input text.
<jseden>
inputstr=\"f(app1,app2,app3)\";
</jseden>
Above is an input string accepted by the parser. You can also try some input string which is not accepted:
<jseden>
inputstr=\"f((app,app2,(app3))\";
</jseden>
and
<jseden>
inputstr=\"f(f(app,app2,app3)\";
</jseden>
</p>

");
