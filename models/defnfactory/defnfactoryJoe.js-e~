## to protect against loss of information whilst constructing patterns

${{
  
var workIsDone = false;
window.onbeforeunload = confirmBrowseAway;

function confirmBrowseAway()
{
  if (!workIsDone) {
    return "Are you sure? If you leave this page now, your work will NOT be saved.";
  }
};
  
}}$;

## to allow JS-EDEN to handle the Greek characters a-?

${{
parser.lexer.rules = [/^\*\//,/^./,/^\/\*/,/^[\n\r]/,/^./,/^\u0023\u0023/,/^\$\{\{/,/^\}\}\$/,/^([\n\r]|.)/,/^\\"/,/^"/,/^(.|\n)/,/^"/,/^\\./,/^'/,/^./,/^'/,/^\s+/,/^@/,/^[0-9]+(\.[0-9]+)?\b/,/^is\b/,/^delete\b/,/^insert\b/,/^append\b/,/^shift\b/,/^after\b/,/^if\b/,/^else\b/,/^for\b/,/^while\b/,/^do\b/,/^switch\b/,/^case\b/,/^default\b/,/^break\b/,/^continue\b/,/^return\b/,/^func\b/,/^proc\b/,/^auto\b/,/^para\b/,/^[a-zA-Z\u03B1-\u03C9_a-d][a-zA-Z\u03B1-\u03C9_0-9]*/,/^\?/,/^\/\//,/^<=/,/^>=/,/^</,/^>/,/^==/,/^!=/,/^and\b/,/^or\b/,/^\|\|/,/^&&/,/^!/,/^=/,/^\+=/,/^-=/,/^\+\+/,/^--/,/^&/,/^\*/,/^\//,/^%/,/^-/,/^\+/,/^;/,/^\?/,/^:/,/^,/,/^~>/,/^\[/,/^\]/,/^\{/,/^\}/,/^\(/,/^\)/,/^\./,/^`/,/^\$[0-9]+/,/^\$/,/^#/,/^$/,/^./];
}}$;

## the instance of '##' in the above RE definition 
## has been replaced by '^\u0023\u0023'
## this means that it can be accepted via the EDEN
## interface, but needs to be interpreted before
## Greek characters in the file can be interpreted.

/*
valrange	α	β	γ	δ	ε	ζ	η	θ	ι	κ	λ	μ	ν	ξ	ο	π	ρ	ς	σ	τ	υ	φ	χ	ψ	ω
03B0		01	02	03	04	05	06	07	08	09	0A	0B	0C	0D	0E	0F	
03C0																00	01	02	03	04	05	06	07	08	09

*/

## ideally this extension to the parser should be more "call-by-need" - only implemented in the script factory environment

## from Tim Monks - procedure for manipulating REs in the search box:

/*

proc showObservables { ${{
   $('#symbol-search > .side-bar-topic-title').click();
   $('#observable-search').val(arguments[0]);
}}$; }

proc showFunctions { ${{
   $('#functions > .side-bar-topic-title').click();
   $('#functions-search').val(arguments[0]);
}}$; }

*/

proc showObservables { ${{
   $('.symbollist-search').val(arguments[0]);
   $('.symbollist-search').keyup();
}}$; }


func split {
  ${{
  	var str = arguments[0];
  	var patt = arguments[1];
  	return str.split(patt);
  }}$;
}

###########
## preliminary set up to this point ...
###########

## astr is the source string to be transformed:

astr = "";

## create a Div that displays the string colour-coded
## so as to reflect a selection of segments and a selected scriptvar

segcolarr is ["red", "green", "brown", "seablue", "red", "green", "brown", "seablue","red", "green", "brown", "seablue","red", "green", "brown", "seablue" ];

currscriptvarix = 1;
segcol is segcolarr[currscriptvarix];
fontsegbra is "<font color='"// segcol // "'>";
fontsegket = "</font>";

func sumls {
	para sls;
	auto i, result;
	result = 0;
	for (i=1; i<=sls#; i++) {
		result = result + sls[i]#;
	}
	return result;
};

func mkxtr {
	para sls, lenmatch;
	auto i, j, result;
	result = [0];
	for (i=1; i<=sls#; i++) {
		for (j=1; j<=sls[i]#; j++) result = result // [0];
		if (result# <= sumls(sls) + (sls#-1)*lenmatch) {
			for (j=1; j<=lenmatch; j++) result = result // [j]; 
		}
	}
	return result // [0];
};

strtomatch = "";
lenmatch is strtomatch#;
matcharr is (strtomatch=="") ? [astr] : split(astr, strtomatch);
xstr is mkxtr(matcharr, lenmatch);

func mksegdispstr {
	para srcstr, selpatt, fbra, fket;
	auto i, selpattil, selpattir, result;
	result = "";
  	if ((srcstr#!=0) && (selpatt#>2)) {
	  for (i=1; i<=srcstr#; i++) {
		selpattil = selpatt[i];
		selpattir = selpatt[i+1];
		if ((selpattil==0) && (selpattir==1)) {
			result = result // fbra // srcstr[i];
		}
		else
		if ((selpattir==0) && (selpattil > selpattir)) {
				result = result // fket // srcstr[i];
		}
		else result = result // srcstr[i];
	  }
	}
	return result;
};

segdispstr is mksegdispstr(astr, xstr, fontsegbra, fontsegket);

## last two parameters are width and default value
 
pattvaridbox is Inputbox("pattvaridbox", 110, vertpos2, true, 100, "");
picture is [pattvaridbox];
segtomatch is Inputbox("segtomatch", 110, vertpos2+30, true, 100, "");
picture is [pattvaridbox, segtomatch];

templatetext is Textbox("templatetext", 110, vertpos2+60, true);
picture is [pattvaridbox, segtomatch, templatetext];


pattvaridtxt is Text("Pattern var id", 10, vertpos2);

segtomatchtxt is Text("Match segment", 10, vertpos2+30, "black", 14);

picture is [pattvaridbox, segtomatch, templatetext, pattvaridtxt, segtomatchtxt];

## text in these boxes stored as segtomatch_value etc





## mkpattable Div includes radio buttons for Greek chars
## also includes table displaying script var, patt varid
## template, match str and pattern resulting

## for defining scriptvar

func unicode { ${{
  var x = arguments[0];
  return String.fromCharCode(x + 944);
}}$; };

scriptvar is fontsegbra + unicode(currscriptvarix) + fontsegket;

## for defining pattvarid

allgkch is ["α","β","γ","δ","ε","ζ","η","θ","ι","κ","λ","μ","ν","ξ","ο"];

func subststar {
  ${{
	var s = arguments[0];
	var lsgkch = arguments[1];
	var i, gkch, repstr;
	for (i=0; i<lsgkch.length; i++) {
        gkch = lsgkch[i];
		repstr = root.lookup(gkch).cached_value;
		s=s.replace(RegExp(gkch,"g"),repstr);
	}
	return s;
  }}$;
}

scriptvarid = ""; 
## part of pattvarid supplied by the modeller

func mkstr { ${{
  var x1 = arguments[0];
  var y1 = arguments[1];
  var i;
  var result = (x1.length>0) ? x1[0] : "";
  if (x1.length>0) {
	for (i=1; i<x1.length; i++) {
		result += y1 + x1[i];	 
	}
  }
  return result;
}}$;
};

pattstr is mkstr(matcharr, unicode(currscriptvarix));

αpresent is split(pattstr,"α")# > 1;
βpresent is split(pattstr,"β")# > 1;
γpresent is split(pattstr,"γ")# > 1;
δpresent is split(pattstr,"δ")# > 1;
εpresent is split(pattstr,"ε")# > 1;
ζpresent is split(pattstr,"ζ")# > 1;
ηpresent is split(pattstr,"η")# > 1;
θpresent is split(pattstr,"θ")# > 1;
ιpresent is split(pattstr,"ι")# > 1;
κpresent is split(pattstr,"κ")# > 1;
λpresent is split(pattstr,"λ")# > 1;
μpresent is split(pattstr,"μ")# > 1;
νpresent is split(pattstr,"ν")# > 1;
ξpresent is split(pattstr,"ξ")# > 1;
οpresent is split(pattstr,"ο")# > 1;

prefixpattvarid is ((αpresent) ? "α" : "") // ((βpresent) ? "β" : "") // ((γpresent) ? "γ" : "") // ((δpresent) ? "δ" : "") // ((εpresent) ? "ε" : "") // ((ζpresent) ? "ζ" : "") // ((ηpresent) ? "η" : "") // ((θpresent) ? "θ" : "") // ((ιpresent) ? "ι" : "") // ((κpresent) ? "κ" : "") // ((λpresent) ? "λ" : "") // ((μpresent) ? "μ" : "") // ((νpresent) ? "ν" : "") // ((ξpresent) ? "ξ" : "") // ((οpresent) ? "ο" : "");

pattvarid is prefixpattvarid // "_" // subststar(scriptvarid, allgkch);

## for defining createdstr

func compose { ${{
  var x1 = arguments[0];
  var y1 = arguments[1];
  var fcol = arguments[2];
  var i, result;
  if (x1.length < 1) {
	result = "";
  }
  else {
	result = x1[0];
	for (i=1; i<x1.length; i++) {
		result += y1 + x1[i];	 
	}
  }
  return result;
}}$;
};

createdstr is compose(matcharr, scriptvar, segcol);

## simplification here: 26th Sept had "subststr is scriptvar;"
## and used subststr as a parameter to compose()

## now have ingredients for displaying mkpatttable
## which shows script var, patt var id, template, match and pattern

vertpos = 15;

gkbutnames is ["α","β","γ","δ", "ε","ζ","η","θ","ι","κ","λ","μ","ν","ξ","ο"];


gkradiobuts is RadioButtons("gkradiobuts", gkbutnames, 10, vertpos, true, true);

mkpatttable is Div("Selection table", 10,vertpos+30, 800, 100, "
	<table border='1'  style='text-align:center; font-size:12pt; background-color:lightgrey; color:black'>
	  <tr>
	    <th>Script Variable</th>
	    <th>Pattern Var id</th>
	    <th>Template</th>
	    <th>Match</th>
	    <th>Pattern</th>
	  </tr>
	  <tr>
		<td>" + scriptvar + "</td>
	    <td><pre>" + pattvarid + "</pre></td>
	    <td style='text-align:left'><pre>" + segdispstr + "</pre></td>
		<td><pre>" + strtomatch + "</pre></td>
		<td style='text-align:left'><pre>" + createdstr + "</pre></td>
	  </tr>
	</table>"
	
);

picture is [pattvaridbox, segtomatch, templatetext, pattvaridtxt, segtomatchtxt, mkpatttable, gkradiobuts];




################### 99999999999999999999999999999999999999999999999999999999999999999

vertpos2 = 370;


## the Div segdisp lays out the left-hand corner of the display 
## to show the pattern var id, match segment and template text 
/*

segdisp is Div("", 10, vertpos2, 800, vertpos2, "
<div id='forinput'>
<pre>
  Pattern var id: <input type='text' id='scriptvid' /><br />
  Match segment : <input type='text' id='matchseg' /><br />
  Template text : <textarea id='srcstring'  rows='15' cols='80'></textarea><br />
</pre>
</div>");

*/

## picture is [segdisp];

showObservables("astr|curr|seg|font|strtom|len|match|xstr|vertpos2");
## showFunctions("sum|mkx|mkseg");
