
s1 is Slide("<h3>A construal for reading music on a piano keyboard</h3><p>This presentation describes the development of a construal intended to assist in teaching and learning basic musical concepts.
This is work-in-progress to which there are several contributors:
<ul>
<li>Megan Beynon, who conceived the construal as a way of teaching piano pupils how to read music from the treble and bass staves.</li>
<br>
<li>Elizabeth Hudnott, who developed the construal of the keyboard and explored its integration with the construal of the staves
from the critical perspective of an expert developer with limited musical knowledge.</li>
<br>
<li>Meurig Beynon, who initiated the development of the construal with guidance from Megan.
</li>
</ul>
</p>
");

slideList is [s1];


s2 is Slide("<h3>Loading the construal</h3>
<p>
The construal has been built using the JS-EDEN interpreter. To load the construal:
<ul>
<li>Use a text editor to open the files: <b>musicapp1.js-e</b> and <b>piano.js-e</b></li>
<br>
<li>Cut-and-paste the content of the file <b>musicapp1.js-e</b> into the Input Window and press the Submit button.
</li>
<br>
<li>Cut-and-paste the first ten lines of the file <b>piano.js-e</b> and enter this via the Input Window similarly.</li>
<br>
<li>Cut-and-paste the entire contents of the file <b>piano.js-e</b> and enter this via the Input Window similarly.</li>
</ul>
The image of the keyboard is initially placed directly on top of the stave, and has to be moved downwards: 
You can redefine the position of the keyboard by making the new definition:
</p>
<jseden>pianoPositionY = 200;</jseden>
<p>
Note that a larger value for its Y coordinate moves an object <i>down</i> the screen.
</p>
");

slideList is [s1, s2];

s2b is Slide("<h3>Basic features of the construal</h3><p>
The construal - as depicted on the HTML5 Canvas panel - has two components: a display of the treble and bass staves, and an associated keyboard.
The lines of the staves are highlighted in such a way that the top, middle and botton lines of each stave are black and other lines are grey.
The notes that correspond to the lines displayed in black play an important role in the construal.
The note on the stave highlighted in turqouise has been generated by selecting one of the black stave lines at random.
The corresponding key on the keyboard is highlighted in turquoise. 
</p>
<p>
To the right of the staves there is a 'Combobox' widget that allows the 'user' of the construal to select a note name from a drop down menu.
The six options available correspond one-to-one to notes on the six black stave lines.
When a selection is made, the corresponding note is displayed in red.
</p>
<p>
The depiction of the treble and bass staves is non-standard: the distance between the treble and bass staves is contrived so that the correspondence between lines and the keyboard is
easier to understand.
You can change the distance between the staves by giving different values to the observable bassY:
<jseden>bassY=90;</jseden>
</p>
<p>
For this purpose, you select <b>copy to input</b>, then edit and submit the definition in the Input Window.
Note that there is a missing dependency: moving the bass stave does not move the bass clef.
</p>
");

slideList is [s1, s2, s2b];

s3 is Slide("<h3>More about the construal</h3><p>
The construal comprises a family of <b>observables</b> subject to certain <b>dependencies</b>
that are reconfigurable both directly through the agency of the maker and indirectly through other agencies.
(For instance, in this particular construal, the observables that make up the piano keyboard have been generated dynamically and are displayed
in an <b>HTML View</b> panel. Each key on the keyboard is a rectangle defined by supplying different parameters to the function <code>keyVisual()</code>.)</p>
<p>
To inspect a sample of the observables in the model, you can instantiate a 'Symbol List' from the <b>Views</b> drop down
menu, and type a regular expression (RE) in to the search box at the top of the <b>Symbol List</b> panel to select a subset of observables.
Alternatively, you can display a specific family of observables by executing a showObservables command with a given RE as its argument:
<jseden>showObservables(\"bassY|keyboard|keyC.*1|pianoPosi|nat|picture$|sel|tbNo|treblebassNote_val|tbsel\");</jseden>
</p>
<p>
In the Symbol List, observables that have explicit values are
displayed in black, whilst whose values are defined by dependency are displayed in green.
You can inspect the definitions of observables displayed in green using mouseover.
To explore the construal further, you can redefine observables freely by entering new definitions for them via the Input Window.
For instance, you can see how the size of the keyboard is determined by the observable <b>naturalKeyWidth</b>, upon which the observable
<b>naturalKeyLength</b> depends:
<jseden>naturalKeyWidth = 15;</jseden>
</p>
<p>
To limit the size of the keyboard visualisation, it is convenient to make an assignment such as:
 <jseden>naturalKeyWidth = 10;</jseden>
</p>
");

slideList is [s1, s2, s2b, s3];

s4 is Slide("<h3>Modifying the construal</h3><p>
As a simple exercise in the modifying the construal, we can introduce the 'missing dependency' between the position of the bass clef and the bass stave.
For this purpose, we can create a <b>Symbol Lookup Table</b> view, and enter the RE 'bass' into the search box at the top of it.
This gives comprehensive details of the current definitions and values of observables whose names have the form 'bass...'.
</p>
<p>
By inspection, we find the definition of the observable bassClef, viz:
<jseden>bassClef is Image(\"bassClef\", 27, 95, 28, 33,\"http://www.dcs.warwick.ac.uk/~wmb/bass_clef.png\");</jseden>
</p>
<p>
By refining the search in the <b>Symbol Lookup Table</b> to display the definition of the Image() function, it
becomes clear that the y-coordinate of the observable <b>bassClef</b> is explicitly defined above to be 95.
To remedy this, we can introduce an alternative definition to link the y-coordinate of the bass clef to the observable <b>bassY</b>:
<jseden>bassClef is Image(\"bassClef\", 27, bassY + 5, 28, 33,\"http://www.dcs.warwick.ac.uk/~wmb/bass_clef.png\");</jseden>
</p>
<p>
A similar redefinition can be made for the observable treble as follows:
<jseden>trebleClef is Image(\"trebleClef\", 9, trebleY - 6, 64, 68,\"http://www.dcs.warwick.ac.uk/~wmb/Treble_Clef_Pin.PNG\");</jseden>
</p>
<p>
This serves the additional purpose of positioning the treble clef more accurately on the stave.
</p>
");

slideList is [s1, s2, s2b, s3, s4];

s5 is Slide("<h3>Using the construal</h3><p>
One simple application of the construal involves testing whether users can name the randomly generated note highlighted in turquoise.
The internal mechanism for selecting this note and resetting the Combobox selection to '?' is as follows:
<jseden>
selnumt = int(random()*3);
tselnum is 2*selnumt;

selnumb = int(random()*3);
bselnum is 2*selnumb;

stavesel = int(random()*2);

treblebassNote_value = \"?\";</jseden>
</p>
<p>
Executing the above set of redefinitions then displays a random note and allows the user to try to select its name via the drop-down menu.
</p>
<p>
To refine this mechanism, we can wrap the above refinitions into a single procedure, removing the redundant redefinitions of <b>tselnum</b> and <b>bselnum</b>
which were included above for readability:
<jseden>
proc generaterandnote {
	selnumt = int(random()*3);
	selnumb = int(random()*3);
	stavesel = int(random()*2);
	treblebassNote_value = \"?\";
}
</jseden>
</p>
<p>
This procedure is in effect a family of definitions that can be invoked through many different kinds of agency.
</p>
");

slideList is [s1, s2, s2b, s3, s4, s5];

s6 is Slide("<h3>Illustrating modes of agency</h3><p>
The most direct way to generat a new random note is to invoke the <b>generaterandnote</b> procedure directly:
<jseden>generaterandnote();</jseden>
</p>
<p>
An alternative way is to trigger the procedure from a mouseclick to the right of the generated note in the stave region:
<jseden>
proc generaterandnote: mousePressed {
   if (mousePressed && (mouseX >= trebleX + 55) && (mouseX <= trebleX + 150) && (mouseY >= trebleY) && (mouseY <= bassY + width*4)) {
	selnumt = int(random()*3);
	selnumb = int(random()*3);
	stavesel = int(random()*2);
	treblebassNote_value = \"?\";
   }
}
</jseden>
</p>
<!--
CRASHES BROWSER
<p>
As a further refinement, we can arrange for a new note to be generated when the user has correctly identified the note.
The observable <b>tbok</b> is defined in such a way as to capture this condition.
<jseden>
proc generaterandnote: mousePressed, treblebassNote_value {
   if (tbok || (mousePressed && (mouseX >= trebleX + 55) && (mouseX <= trebleX + 150) && (mouseY >= trebleY) && (mouseY <= bassY + width*4))) {
	selnumt = int(random()*3);
	selnumb = int(random()*3);
	stavesel = int(random()*2);
	treblebassNote_value = \"?\";
   }
}
</jseden>
-->  
</p>
");

slideList is [s1, s2, s2b, s3, s4, s5, s6];

s7 is Slide("<h3>Finger frames</h3><p>The main purpose of the construal is to capture other dependencies that can be helpful in learning to interpret music
from treble and bass staves on a keyboard.

These make use of the 'finger frame' concept devised by Megan Beynon.
A finger frame is represented by a box that can be moved up and down the stave by manipulating the value of the observable
<b>framenum</b>:

<jseden>
picture is [fingerFrame] // bass // treble // [ trebleClef, bassClef, tbnote, selnote, tbsel, leftline] // keyboard;
</jseden>
<p>
Incrementing and decrementing the observable <b>framenum</b> move the frame down and up respectively:
To move the frame down:
</p>

<jseden>
framenum++;
</jseden>
<p>
To move the frame up:
</p>
<p>
<jseden>
framenum--;
</jseden>
</p>
<p>
A simple dependency can be used to put finger labels on the five contiguous white notes that are associated with the finger frame:

<jseden>

fingerlabel1 is Text(\"5\", keyB4.x1 + 0.5*naturalKeyWidth - 3 - naturalKeyWidth * 2 * framenum, pianoPositionY + naturalKeyLength - 4, \"red\");
fingerlabel2 is Text(\"4\", keyB4.x1 + 0.5*naturalKeyWidth - 3 + naturalKeyWidth * (1-2*framenum), pianoPositionY + naturalKeyLength - 4, \"red\");
fingerlabel3 is Text(\"3\", keyB4.x1 + 0.5*naturalKeyWidth - 3 + naturalKeyWidth * (2-2*framenum), pianoPositionY + naturalKeyLength - 4, \"red\");
fingerlabel4 is Text(\"2\", keyB4.x1 + 0.5*naturalKeyWidth - 3 + naturalKeyWidth * (3-2*framenum), pianoPositionY + naturalKeyLength - 4, \"red\");
fingerlabel5 is Text(\"1\", keyB4.x1 + 0.5*naturalKeyWidth - 3 + naturalKeyWidth * (4-2*framenum), pianoPositionY + naturalKeyLength - 4, \"red\");

fingerlabels is [fingerlabel1, fingerlabel2, fingerlabel3, fingerlabel4, fingerlabel5];

picture is  [fingerFrame] // bass // treble // [ trebleClef, bassClef, tbnote, selnote, tbsel, leftline] // keyboard // fingerlabels;
</jseden>
</p>

");

slideList is [s1, s2, s2b, s3, s4, s5, s6, s7];

s8 is Slide("<h3>Refining finger frames</h3><p>

It is obvious that, in order to make the construal more effective as a teaching aid, there are many refinements to be made.
The way in which the finger indices are displayed (e.g. position and fontsize) could be improved, and should be configured to be
effective irrespective of the size of the keyboard display. The colours used to depict the finger frame on the stave and the
fingers on the keyboard should be coordinated. The movement of the finger frame could be managed by clicking on the frame.
None of these refinements is technically difficult to implement, but each requires knowledge of the observables concerned, and
the operators that are available (or can be readily written) that can be used to frame dependencies to relate them.

</p>
<p>
Several techniques can be used to find out about observables in the construal.
The use of the <b>Symbol List</b> and <b>Symbol Lookup Table</b> have already been illustrated.
It is also possible to obtain a listing of all the observables and dependencies in the construal by invoking a <b>Script Generator</b>,
and introducing a <b>Dependency Map</b> to explore the network of dependencies that links specific subsets of observables.
For instance, to find out what observables govern the width and length of the keys as displayed, we can identify some of the relevant observables by searching a Symbol List with the RE 'key', then entering the explicit names of keys on the piano (such as <bcode>keyCSharp4</code>) into a <b>Dependency Map</b>.
</p>
<p>
A standard technique for refinement is to replace explicit values by observables whose values can then be manipulated interactively or subsequently defined by dependency. 
<jseden>
fingerlabelYoffset = -4;

fingerlabel1 is Text(\"5\", keyB4.x1 + 0.5*naturalKeyWidth - 3 - naturalKeyWidth * 2 * framenum, pianoPositionY + naturalKeyLength + fingerlabelYoffset, \"red\");
fingerlabel2 is Text(\"4\", keyB4.x1 + 0.5*naturalKeyWidth - 3 + naturalKeyWidth * (1-2*framenum), pianoPositionY + naturalKeyLength + fingerlabelYoffset, \"red\");
fingerlabel3 is Text(\"3\", keyB4.x1 + 0.5*naturalKeyWidth - 3 + naturalKeyWidth * (2-2*framenum), pianoPositionY + naturalKeyLength + fingerlabelYoffset, \"red\");
fingerlabel4 is Text(\"2\", keyB4.x1 + 0.5*naturalKeyWidth - 3 + naturalKeyWidth * (3-2*framenum), pianoPositionY + naturalKeyLength + fingerlabelYoffset, \"red\");
fingerlabel5 is Text(\"1\", keyB4.x1 + 0.5*naturalKeyWidth - 3 + naturalKeyWidth * (4-2*framenum), pianoPositionY + naturalKeyLength + fingerlabelYoffset, \"red\");
</jseden>
</p>
<p>
This makes it possible to refine values by experiment. For instance:
<jseden>
fingerlabelYoffset = 12;
</jseden>
<jseden>
fingerlabelYoffset is (sharpKeyLength - naturalKeyLength) * 0.5 + 3;
</jseden>
</p>

");

s9 is Slide("<h3>Illustrating refinement of finger frames</h3><p>
An obvious refinement of the construal makes it possible to choose whether or not to use right-hand or left-hand finger labels.
To this end, we can introduce an observable that lists the finger indices in ascending or descending order according to whether
the right or left hand is being considered:
<jseden>
func takefrom6 {
	para n;
	return 6-n;
}

whichhand = \"R\";

fingeringLRhand is (whichhand == \"L\") ? map(str, map(takefrom6, [1,2,3,4,5])) : map(str, [1,2,3,4,5]) ; 
</jseden>
</p>
<p>
To switch hands, we can then use:
<jseden>
whichhand = \"L\";
</jseden>
</p>
<p>
The <b>fingeringLRhand</b> observable can then be integrated into the display as follows:
<jseden>
fingerlabel1 is Text(fingeringLRhand[1], keyB4.x1 + 0.5*naturalKeyWidth - 3 - naturalKeyWidth * 2 * framenum, pianoPositionY + naturalKeyLength + fingerlabelYoffset, \"red\");
fingerlabel2 is Text(fingeringLRhand[2], keyB4.x1 + 0.5*naturalKeyWidth - 3 + naturalKeyWidth * (1-2*framenum), pianoPositionY + naturalKeyLength + fingerlabelYoffset, \"red\");
fingerlabel3 is Text(fingeringLRhand[3], keyB4.x1 + 0.5*naturalKeyWidth - 3 + naturalKeyWidth * (2-2*framenum), pianoPositionY + naturalKeyLength + fingerlabelYoffset, \"red\");
fingerlabel4 is Text(fingeringLRhand[4], keyB4.x1 + 0.5*naturalKeyWidth - 3 + naturalKeyWidth * (3-2*framenum), pianoPositionY + naturalKeyLength + fingerlabelYoffset, \"red\");
fingerlabel5 is Text(fingeringLRhand[5], keyB4.x1 + 0.5*naturalKeyWidth - 3 + naturalKeyWidth * (4-2*framenum), pianoPositionY + naturalKeyLength + fingerlabelYoffset, \"red\");
</jseden>
</p>
");

slideList is [s1, s2, s2b, s3, s4, s5, s6, s7, s8, s9];

s10 is Slide("<h3>Embellishing finger frames</h3><p>
A full development of a practically useable construal is beyond the scope of this presentation, the main purpose of which
is to illustrate the principal technical features and conceptual qualities of building construals in JS-EDEN.
</p>
<p>
To further demonstrate what kind of activities are involved, we shall modify the construal to make the correspondence between the finger frame and the
associated notes on the keyboard easier to apprehend.
To this end, we can place markers on the keys to which the finger frame relate as follows:
<jseden>
markrad = 2;
fingermarkYoffset is (sharpKeyLength - naturalKeyLength) * 0.5 - markrad*0.5;

fingermark1 is Circle(keyB4.x1 + 0.5*naturalKeyWidth - naturalKeyWidth * 2 * framenum, pianoPositionY + naturalKeyLength + fingermarkYoffset, markrad, \"red\", \"red\");
fingermark2 is Circle(keyB4.x1 + 0.5*naturalKeyWidth + naturalKeyWidth * (1-2*framenum), pianoPositionY + naturalKeyLength + fingermarkYoffset, markrad, \"red\", \"red\");
fingermark3 is Circle(keyB4.x1 + 0.5*naturalKeyWidth + naturalKeyWidth * (2-2*framenum), pianoPositionY + naturalKeyLength + fingermarkYoffset, markrad, \"red\", \"red\");
fingermark4 is Circle(keyB4.x1 + 0.5*naturalKeyWidth + naturalKeyWidth * (3-2*framenum), pianoPositionY + naturalKeyLength + fingermarkYoffset, markrad, \"red\", \"red\");
fingermark5 is Circle(keyB4.x1 + 0.5*naturalKeyWidth + naturalKeyWidth * (4-2*framenum), pianoPositionY + naturalKeyLength + fingermarkYoffset, markrad, \"red\", \"red\");

fingermarks is [fingermark1, fingermark2, fingermark3, fingermark4, fingermark5];

picture is  [fingerFrame] // bass // treble // [ trebleClef, bassClef, tbnote, selnote, tbsel, leftline] // keyboard // fingerlabels // fingermarks;
</jseden>
</p>
");


slideList is [s1, s2, s2b, s3, s4, s5, s6, s7, s8, s9, s10];

s11 is Slide("<h3>Adding mouse movement of finger frames</h3><p>
The definition of the finger frame rectangle is as follows:
<jseden> 
fingerFrame is Rectangle(trebleX+125, trebleY+width*framenum, width*2, width*2, \"lightgreen\");
</jseden>
</p>
<p>
We can trigger the incrementing and decrementing of <b>framenum</b> by clicking the mouse on the upper and lower parts of the finger frame:
<jseden>
proc movefingerframe: mousePressed {
   if (mousePressed && (mouseX >= trebleX +125) && (mouseX <= trebleX + 125+width*2) && (mouseY >= trebleY+width*framenum) && (mouseY <= trebleY+width*framenum + width*2)) {
		if (mouseY > trebleY+width*framenum + width) framenum++; else framenum--;
   } 
}
</jseden>

</p>
");

slideList is [s1, s2, s2b, s3, s4, s5, s6, s7, s8, s9, s10, s11];

s12 is Slide("<h3>Adding colour conventions to finger frames</h3><p>
It is helpful to colour the lines and spaces on the stave and the corresponding keys and the keyboard so that the correspondence is more easily recognised.

<jseden>
fingermarkcol1 is \"red\";
fingermarkcol2 is \"red\";
fingermarkcol3 is \"red\";
fingermarkcol4 is \"red\";
fingermarkcol5 is \"red\";

fingermark1 is Circle(keyB4.x1 + 0.5*naturalKeyWidth - naturalKeyWidth * 2 * framenum, pianoPositionY + naturalKeyLength + fingermarkYoffset, markrad, fingermarkcol1, fingermarkcol1);
fingermark2 is Circle(keyB4.x1 + 0.5*naturalKeyWidth + naturalKeyWidth * (1-2*framenum), pianoPositionY + naturalKeyLength + fingermarkYoffset, markrad, fingermarkcol2, fingermarkcol2);
fingermark3 is Circle(keyB4.x1 + 0.5*naturalKeyWidth + naturalKeyWidth * (2-2*framenum), pianoPositionY + naturalKeyLength + fingermarkYoffset, markrad, fingermarkcol3, fingermarkcol3);
fingermark4 is Circle(keyB4.x1 + 0.5*naturalKeyWidth + naturalKeyWidth * (3-2*framenum), pianoPositionY + naturalKeyLength + fingermarkYoffset, markrad, fingermarkcol4, fingermarkcol4);
fingermark5 is Circle(keyB4.x1 + 0.5*naturalKeyWidth + naturalKeyWidth * (4-2*framenum), pianoPositionY + naturalKeyLength + fingermarkYoffset, markrad, fingermarkcol5, fingermarkcol5);
</jseden>
</p>
<p>
This makes it convenient to mark keys with different colours: for instance to alternate the marks as follows:
<jseden>
oddindexcol = \"blue\";
evenindexcol = \"yellow\";
fingermarkcol1 is oddindexcol;
fingermarkcol2 is evenindexcol;
fingermarkcol3 is oddindexcol;
fingermarkcol4 is evenindexcol;
fingermarkcol5 is oddindexcol;
</jseden>
</p>
<p>
The yellow colour doesn't show up very well and could be darker. An alternative way of specifying a colour is to use an RGB hex representation:
<jseden>
evenindexcol = \"#e0e000\";
</jseden>
</p>
<p>
Modifying the visualisation of the finger frame accordingly is the subject of the next slide.
</p>
");

slideList is [s1, s2, s2b, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12];

s13 is Slide("<h3>Adding colour to the finger frames</h3><p>
To decorate the finger frame so that it matches the finger marks on the keyboard, we first reset the background colour:
<jseden>
fingerFrame is Rectangle(trebleX+125, trebleY+width*framenum, width*2, width*2, evenindexcol);
</jseden>
</p>
<p>
To re-engineer the finger frame display, we can then introduce some extra lines, coloured so as to reflect the alternating black and grey colour of the stave lines, as follows:
<jseden>
topline is Line(trebleX+125, trebleY+width*framenum, trebleX+125 + width*2, trebleY+width*framenum, \"blue\");
middleline is Line(trebleX+125, trebleY+width*framenum+width, trebleX+125 + width*2, trebleY+width*framenum+width, \"blue\");
bottomline is Line(trebleX+125, trebleY+width*framenum+2*width, trebleX+125 + width*2, trebleY+width*framenum+2*width, \"blue\");
rightframe is Line(trebleX+125, trebleY+width*framenum, trebleX+125, trebleY+width*framenum + width*2, \"white\");
leftframe is Line(trebleX+125+width*2, trebleY+width*framenum, trebleX+125+width*2, trebleY+width*framenum + width*2, \"white\");
picture is [fingerFrame] // bass // treble // [ trebleClef, bassClef, tbnote, selnote, tbsel, leftline] // keyboard // fingerlabels // fingermarks // [topline, middleline, bottomline, rightframe, leftframe];
</jseden>
</p>
");


slideList is [s1, s2, s2b, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13];


s14 is Slide("<h3>Refining the colour in the finger frames</h3><p>
To refine the display to reflect the black and grey colour of the stave lines:
<jseden>
framelinecol is (framenum % 2 == 0) ? [\"blue\", \"aqua\", \"blue\"] : [\"aqua\", \"blue\",\"aqua\"]; 
topline is Line(trebleX+125, trebleY+width*framenum, trebleX+125 + width*2, trebleY+width*framenum, framelinecol[1]);
middleline is Line(trebleX+125, trebleY+width*framenum+width, trebleX+125 + width*2, trebleY+width*framenum+width, framelinecol[2]);
bottomline is Line(trebleX+125, trebleY+width*framenum+2*width, trebleX+125 + width*2, trebleY+width*framenum+2*width, framelinecol[3]);
rightframe is Line(trebleX+125, trebleY+width*framenum, trebleX+125, trebleY+width*framenum + width*2, \"white\");
leftframe is Line(trebleX+125+width*2, trebleY+width*framenum, trebleX+125+width*2, trebleY+width*framenum + width*2, \"white\");
picture is [fingerFrame] // bass // treble // [ trebleClef, bassClef, tbnote, selnote, tbsel, leftline] // keyboard // fingerlabels // fingermarks // [topline, middleline, bottomline, rightframe, leftframe];
</jseden>
</p>
<p>
It is also helpful te experiment with different colour assignments:
<jseden>
framelinecol is (framenum % 2 == 0) ? [\"red\", \"pink\",\"red\"] :  [\"pink\", \"red\", \"pink\"]; 
</jseden>
</p>
<p>
The colour scheme for marking keys on the keyboard can be made consistent with this as follows:
<jseden>
fingermarkcol1 is framelinecol[1];
fingermarkcol3 is framelinecol[2];
fingermarkcol5 is framelinecol[3];
</jseden>
</p>
");

slideList is [s1, s2, s2b, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14];
