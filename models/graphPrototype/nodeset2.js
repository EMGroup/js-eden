${{
  
var workIsDone = false;
window.onbeforeunload = confirmBrowseAway;

function confirmBrowseAway()
{
  if (!workIsDone) {
    return "Are you sure? If you leave this page now, your work will NOT be saved.";
  }
};
  
}}$;

${{

/*
## The function Vertex creates vertex objects which have  
## two random coordinate values x and y on the canvas 
*/
 var Vertex = function(value) {
  this.value = value;
  do {
 	this.x = Math.random()*500;
 	this.y = Math.random()*300;
  } while ((this.x>495)||(this.y>295)||(this.x<5)||(this.y<5));

  }

/*
## The Edge function creates edge objects with specified source and target.
## The source and target of an edge are vertices.
*/ 
 
 var Edge = function(source,target) {
 	this.source=source;
        this.target=target;
  }

/*
## g is a graph object.
## Using "g = " rather than "var g =" makes g a global variable
## "var g = " is appropriate if entering code via the console
*/

 g = {
   graphName: "_G",
   nodes : [],
   edges : [],
   nodeset: {},
   strNodes:"",
   strEdges:"",

   initialise : function() {
         this.nodes = [];
         this.edges = [];
          this.nodeset={};
   },

xaddNode : function(value) {
var key = value;
console.log("key:"+value);
var node = this.nodeset[key];
console.log("node: \/ below");
console.log(node); // set the var node to the position indexed by key in the nodeset array if(node == undefined) { // if node points to something which is undefined (which means that
console.log("node undefined...");
node = new Vertex(value); // value has not been added to the nodeset array). Hence create
console.log("node is now... \/ below");
console.log(node); this.nodeset[key]=node; // a new node containing value and store it. Else do nothing. console.log("this.nodeset[key]=node");
this.nodes.push(node);
console.log("pushing the node"); this.strNodes = (this.strNodes === "") ? this.strNodes + "c" + value : this.strNodes + "," + "c" +value; console.log("this.strNodes = "+this.strNodes);
// strNodes is a string representation of all the nodes in the nodeset in the format:"ca,cb,cc..." // this is used to display the graph in JS-EDEN (root.lookup(g.graphName+value)).assign([node.x,node.y]);
}else{
console.log("node already defined");
console.log("do nothing");
} return node; },


   addNode : function(value) {
	var key  = value;
	var node = this.nodeset[key]; 
									// set the var node to the position indexed by key in the nodeset array 
	if(node == undefined) {					// if node points to something which is undefined (which means that
		node = new Vertex(value);				// value has not been added to the nodeset array). Hence create
		this.nodeset[key]=node;				// a new node containing value and store it. Else do nothing.
		this.nodes.push(node);
		this.strNodes = (this.strNodes === "") ? this.strNodes + "c" + value : this.strNodes + "," + "c" +value;	
		// strNodes is a string representation of all the nodes in the nodeset in the format:"ca,cb,cc..."	
		// this is used to display the graph in JS-EDEN
		
		(root.lookup(g.graphName+value)).assign([node.x,node.y]);
 
         }
		

       return node;
   },

   addEdge : function(source, target) {
           var s = this.addNode(source);		// Call the addNode method to create two nodes.
           var t = this.addNode(target);		// If they are already in the nodeset, do nothing.
           var edge = new Edge(s, t);
           this.edges.push(edge);
   
	    this.strEdges=(this.strEdges==="")? this.strEdges+"l"+source+target+","+"l"+source+target+"arr"+","+"r"+source+target+"arr" : this.strEdges+","+"l"+source+target+","+"l"+source+target+"arr"+","+"r"+source+target+"arr";
	    // strEdges is a string representation of all the edges in the graph in the format:"l"+source+target,...
	    // this is used to display the graph in JS-EDEN
	 
	    return edge;
     }
 }


/*
## The drawVertex function does part of the job of drawing a vertex on the canvas.
## It creates or finds existing eden observables and make definitions for a vertex
## in eden as a circle.
## The symbol 'ix' corresponds to the name of the vertex in javascript. 
*/
 Vertex.prototype.drawVertex = function() {
	(function(context,ix) {	
    		var o_Circle = context.lookup('Circle');
    		var o_px = context.lookup('p'+ix+'x');		// the x coordinate of the center of the circle of vertex ix
    		var o_py = context.lookup('p'+ix+'y');		// the y coordinate of the center of the circle of vertex ix
		var o_c = context.lookup('c'+ix);			// the observable for the circle of vertex ix
		var o_r = context.lookup('r'+ix);			// the radius of the circle of vertex ix
		var    o_cl = context.lookup('col'+ix);				// the colour of the node
		/*The definition below is adapted from the code generated by the parser (see jseden.dcs.warwick.ac.uk/emile/test.html).
    		  It defines the drawable elements that will appear on the canvas. 
		*/		
		(o_c.eden_definition = "c"+ix+" is Circle(p"+ix+"x,p"+ix+"y,r"+ix+",\"red\",\"red\")", o_c.define(function(context) {
        		return o_Circle.value().call(this, o_px.value(), o_py.value(), o_r.value(), o_cl.value(), o_cl.value());
    		}).subscribe(["Circle", "p"+ix+"x", "p"+ix+"y","r"+ix,"col"+ix]));

	})(root,this.value);

	/* Below is the code to give initial values to the center of the circle. 
	    If they have values already, do nothing. Otherwise assign them
	   this.x and this.y 
	*/

	if((root.lookup("p"+this.value+"y")).cached_value===undefined){(root.lookup("p"+this.value+"x")).assign(this.x);}
	if((root.lookup("p"+this.value+"y")).cached_value===undefined){(root.lookup("p"+this.value+"y")).assign(this.y);}
	
	(root.lookup("r"+this.value)).assign(5);
	(root.lookup("col"+this.value)).assign("red");}

/*
## The drawEdge function is similar to the drawVertex function, but it is more complicated.
## It creates or finds existing eden observables and defines an edge in JS-EDEN as an arrow
## (which is composed of three lines).The arrow starts from the circumference of the source 
## circle, and ends at the circumference of the target circle. The variables ix1 and ix2 
## are the names of the source node and the target node respectively
*/
 
 Edge.prototype.drawEdge = function() {
	(function(context,ix1,ix2) {	
    		var o_Line = context.lookup('Line');			// extract the JavaScript counterparts of the Line, square root and power functions in JS-EDEN
		var o_sqrt = context.lookup('sqrt');
    		var o_pow = context.lookup('pow');

										// extract the JavaScript counterparts of the JS-EDEN observables ...
    		var o_px = context.lookup('p'+ix1+'x');			// the x coordinate of the center of the circle of the source
    		var o_py = context.lookup('p'+ix1+'y');			// the y coordinate of the center of the circle of the source
    		var o_qx = context.lookup('p'+ix2+'x');			// the x coordinate of the center of the circle of the target
		var o_qy = context.lookup('p'+ix2+'y');			// the y coordinate of the center of the circle of the target
		var o_l = context.lookup('l'+ix1+ix2);			// the line from the source to the target ("the arrowline")
		var o_cl=context.lookup('col'+ix1+ix2);			// the colour of the line				
    		var o_ptarr = context.lookup('pt'+ix1+ix2+'arr');	// the intersection of lines which defines the start point of the arrow head
		var o_l1 = context.lookup('l'+ix1+ix2+'s');		// the start point of the arrowline
		var o_l2 = context.lookup('l'+ix1+ix2+'t');		// the end point of the arrowline
    		var o_larr = context.lookup('l'+ix1+ix2+'arr');		// the left component of the arrowhead
    		var o_rarr = context.lookup('r'+ix1+ix2+'arr');		// the right component of the arrowhead
		var o_x = context.lookup('l'+ix1+ix2+'dx');		// the difference between the x coordinates of the center of the source and of the start point of the arrowline
		var o_y = context.lookup('l'+ix1+ix2+'dy');		// the difference between the y coordinates of the center of the source and of the start point of the arrowline
		var o_lambda = context.lookup('lambda');			// lambda determines the width of the arrow head
		var o_mu = context.lookup('mu');				// mu determines where the arrow head starts
		var o_llength = context.lookup('llength'+ix1+ix2);	// the length of the arrowline
		o_lambda.assign(9);
		o_mu.assign(15);


		/*The definition below is adapted from the code generated by the parser (see jseden.dcs.warwick.ac.uk/emile/test.html).
    		  It defines the drawable elements that will appear on the canvas. 
		*/	

		/*define "lix1ix2dx" to be the difference  between the x coordinates of the center of the source and  of the start point of the arrowline
		*/
		(o_x.eden_definition = "l"+ix1+ix2+"dx is 5/(sqrt(pow((p"+ix2+"x-p"+ix1+"x),2)+pow((p"+ix2+"y-p"+ix1+"y),2)))*(p"+ix2+"x-p"+ix1+"x)", o_x.define(function(context) {
       	 return 5 / (o_sqrt.value().call(this, o_pow.value().call(this, (o_qx.value() - o_px.value()), 2) + o_pow.value().call(this, (o_qy.value() - o_py.value()), 2))) * (o_qx.value() - o_px.value());
    		}).subscribe(["sqrt", "pow", "p"+ix2+"x", "p"+ix1+"x", "p"+ix2+"y", "p"+ix1+"y"]));
		

		/*define "lix1ix2dy"to be the difference between the x coordinates of the center of the source and  of the start point of the arrowline
		*/
		(o_y.eden_definition = "l"+ix1+ix2+"dy is 5/(sqrt(pow((p"+ix2+"x-p"+ix1+"x),2)+pow((p"+ix2+"y-p"+ix1+"y),2)))*(p"+ix2+"y-p"+ix1+"y)", o_y.define(function(context) {
        	return 5 / (o_sqrt.value().call(this, o_pow.value().call(this, (o_qx.value() - o_px.value()), 2) + o_pow.value().call(this, (o_qy.value() - o_py.value()), 2))) * (o_qy.value() - o_py.value());
    		}).subscribe(["sqrt", "pow", "p"+ix2+"x", "p"+ix1+"x", "p"+ix2+"y", "p"+ix2+"y"]));

		/*define "lix1ix2s" to be the start point of the arrowline
		*/
 	   	(o_l1.eden_definition = "l"+ix1+ix2+"s is [p"+ix1+"x+l"+ix1+ix2+"dx,p"+ix1+"y+l"+ix1+ix2+"dy]", o_l1.define(function(context) {
        	return [o_px.value() + o_x.value(), o_py.value() + o_y.value()];
   		 }).subscribe(["p"+ix1+"x", "l"+ix1+ix2+"dx", "p"+ix1+"x", "l"+ix1+ix2+"dy"]));

    		/*define "lix1ix2t" to be the end point of the arrowline
		*/
		(o_l2.eden_definition = "l"+ix1+ix2+"t is [p"+ix2+"x-l"+ix1+ix2+"dx,p"+ix2+"y-l"+ix1+ix2+"dy]", o_l2.define(function(context) {
        	return [o_qx.value() - o_x.value(), o_qy.value() - o_y.value()];
    		}).subscribe(["p"+ix2+"x", "l"+ix1+ix2+"dx", "p"+ix2+"y", "l"+ix1+ix2+"dy"]));
    
		/*define "lix1ix2" to be the arrowline
		*/
		(o_l.eden_definition = "l"+ix1+ix2+" is Line(l"+ix1+ix2+"s[1],l"+ix1+ix2+"s[2],l"+ix1+ix2+"t[1],l"+ix1+ix2+"t[2],col"+ix1+ix2+")", o_l.define(function(context) {
        	return o_Line.value().call(this, o_l1.get(1 - 1).value(), o_l1.get(2 - 1).value(), o_l2.get(1 - 1).value(), o_l2.get(2 - 1).value(), o_cl.value());
    		}).subscribe(["Line", "l"+ix1+ix2+"s", "l"+ix1+ix2+"t","col"+ix1+ix2]));

		/*define "llengthix1ix2" to be the length of the arrowline		
		*/
		(o_llength.eden_definition = "llength"+ix1+ix2+" is sqrt(pow((l"+ix1+ix2+"t[1]-l"+ix1+ix2+"s[1]),2)+pow((l"+ix1+ix2+"t[2]-l"+ix1+ix2+"s[2]),2))", o_llength.define(function(context) {
        	return o_sqrt.value().call(this, o_pow.value().call(this, (o_l2.get(1 - 1).value() - o_l1.get(1 - 1).value()), 2) + o_pow.value().call(this, (o_l2.get(2 - 1).value() - o_l1.get(2 - 1).value()), 2));
    		}).subscribe(["sqrt", "pow", "l"+ix1+ix2+"t", "l"+ix1+ix2+"s"]));		

		/*define "ptix1ix2arr" to be the intersection of lines which determines the start point of the arrow head.
		*/
		(o_ptarr.eden_definition = "pt"+ix1+ix2+"arr is [l"+ix1+ix2+"t[1] -(l"+ix1+ix2+"t[1]-l"+ix1+ix2+"s[1])/llength"+ix1+ix2+"*mu,l"+ix1+ix2+"t[2]-(l"+ix1+ix2+"t[2]-l"+ix1+ix2+"s[2])/llength"+ix1+ix2+" * mu]", o_ptarr.define(function(context) {
        	return [o_l2.get(1 - 1).value() - (o_l2.get(1 - 1).value() - o_l1.get(1 - 1).value()) / o_llength.value() * o_mu.value(), o_l2.get(2 - 1).value() - (o_l2.get(2 - 1).value() - o_l1.get(2 - 1).value()) / o_llength.value() * o_mu.value()];
    		}).subscribe(["l"+ix1+ix2+"t", "l"+ix1+ix2+"s",  "mu"]));
	
		/*define "lix1ix2arr" to be the left component of the arrowhead
		*/
		(o_larr.eden_definition = "l"+ix1+ix2+"arr is Line( pt"+ix1+ix2+"arr[1] + (l"+ix1+ix2+"s[2]-l"+ix1+ix2+"t[2]) /llength"+ix1+ix2+" * (-lambda), pt"+ix1+ix2+"arr[2] + (l"+ix1+ix2+"t[1]-l"+ix1+ix2+"s[1])/llength"+ix1+ix2+"*(-lambda), l"+ix1+ix2+"t[1], l"+ix1+ix2+"t[2], col"+ix1+ix2+")", o_larr.define(function(context) {
        	return o_Line.value().call(this, o_ptarr.get(1 - 1).value() + (o_l1.get(2 - 1).value() - o_l2.get(2 - 1).value()) / o_llength.value() * (-o_lambda.value()), o_ptarr.get(2 - 1).value() + (o_l2.get(1 - 1).value() - o_l1.get(1 - 1).value()) / o_llength.value() * (-o_lambda.value()), o_l2.get(1 - 1).value(), o_l2.get(2 - 1).value(), o_cl.value());		   
                }).subscribe(["Line", "pt"+ix1+ix2+"arr", "l"+ix1+ix2+"s", "l"+ix1+ix2+"t",  "lambda","col"+ix1+ix2]));
		
		
		/*define "rix1ix2arr" to be the right component of the arrowhead
		*/
		(o_rarr.eden_definition = "r"+ix1+ix2+"arr is Line( pt"+ix1+ix2+"arr[1] + (l"+ix1+ix2+"s[2]-l"+ix1+ix2+"t[2]) /llength"+ix1+ix2+"*lambda, pt"+ix1+ix2+"arr[2] + (l"+ix1+ix2+"t[1]-l"+ix1+ix2+"s[1]) /llength"+ix1+ix2+"*lambda, l"+ix1+ix2+"t[1], l"+ix1+ix2+"t[2], col"+ix1+ix2+")", o_rarr.define(function(context) {
        	 return o_Line.value().call(this, o_ptarr.get(1 - 1).value() + (o_l1.get(2 - 1).value() - o_l2.get(2 - 1).value()) / o_llength.value() * o_lambda.value(), o_ptarr.get(2 - 1).value() + (o_l2.get(1 - 1).value() - o_l1.get(1 - 1).value()) / o_llength.value() * o_lambda.value(), o_l2.get(1 - 1).value(), o_l2.get(2 - 1).value(), o_cl.value());	
    		}).subscribe(["Line", "pt"+ix1+ix2+"arr", "l"+ix1+ix2+"s", "l"+ix1+ix2+"t", "lambda", "col"+ix1+ix2]));	
						
	})(root,this.source.value,this.target.value);

	/* Below is the code to give initial values to the coordinates of the source and target 
           If they have values already, do nothing. Otherwise assign them this.x and this.y 
	*/

	if((root.lookup("p"+this.source.value+"x")).cached_value===undefined){(root.lookup("p"+this.source.value+"x")).assign(this.source.x);}

	if((root.lookup("p"+this.source.value+"y")).cached_value===undefined){(root.lookup("p"+this.source.value+"y")).assign(this.source.y);}

	if((root.lookup("p"+this.target.value+"x")).cached_value===undefined){(root.lookup("p"+this.target.value+"x")).assign(this.target.x);}

	if((root.lookup("p"+this.target.value+"y")).cached_value===undefined){(root.lookup("p"+this.target.value+"y")).assign(this.target.y);}
	
	(root.lookup("col"+this.source.value+this.target.value)).assign("red");

}


}}$;
