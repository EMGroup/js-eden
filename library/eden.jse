## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

##Debugging flags.
debug = {jsExceptions: ${{edenUI.getOptionValue("developer") == "true" }}$ };

##MISSING FUNCTIONS

proc eager {
	if (autocalc == 0) {
		autocalc = 1;
		autocalc = 0;
	};
};

func time {
  ${{
  var now = new Date();
  return Math.floor(now.getTime() / 1000);
  }}$;
};

proc writeln {
  ${{
	var message = root.lookup("str").definition(root)(arguments[0]);
	console.log(message);
	message = "Output: " + message;
	root.lookup("_menubar_status").assign(message, this);
	if (!root.autocalc_state) {
		edenUI.plugins.MenuBar.updateStatus(message);
	}
  }}$;
}

##A kind of privilege level that the JS-EDEN user is constrained by.
##
##Possible values:
##	"tool development": The user is allowed to write JS-EDEN code that modifies JS-EDEN itself, for
##		example code that modifies the CSS of the user interface.
##	"making construals": The normal mode without the extra privileges conferred by "tool development"
##		mode.
##	"warnings": Puts extra checks in place to warn the user about situations that are normally
##		permissible in "making construals" mode (and reasonable in some exceptional circumstances)
##		but that are likely indicative of mistakes made by the user in most circumstances.  An
##		example is referring to an observable name that hasn't been defined yet.  This mode isn't
##		implemented yet.
_authoringMode = "making construals";

##Raises an error if fewer or greater than two arguments are given.
##Returns undefined if either argument is undefined.
##tkeden returns strange strings beginning with the word "usage" in these situations.
func apply {
	${{
		if (arguments.length != 2) {
			eden.error(new Error("apply: This function requires exactly 2 arguments."), "error");
			return undefined;			
		} else if (typeof(arguments[0]) != "function") {
			eden.error(new Error("apply: The first argument must be of type func or type proc, not " + typeof(arguments[0])), "error");
			return undefined;
		} else if (!Array.isArray(arguments[1])) {
			eden.error(new Error("apply: The second argument must be of type list, not " + typeof(arguments[1])), "error");
			return undefined;
		} else {
			return arguments[0].apply(this, arguments[1]);
		}
	}}$;
}

func forget {
	${{
		if (arguments.length != 1) {
			eden.error(new Error("forget: This function requires exactly 1 argument."), "error");
			return 2;
		}
	
		var nameToDelete, symbolToDelete;
		
		if (typeof(arguments[0]) == "string") {
			nameToDelete = arguments[0];
			if (!(nameToDelete in root.symbols)) {
				return 1;
			}
			symbolToDelete = root.lookup(nameToDelete);
			if (symbolToDelete.garbage) {
				return 1;
			}
			nameToDelete = "/" + nameToDelete;
		} else if (arguments[0] instanceof Symbol) {
			symbolToDelete = arguments[0];
			nameToDelete = symbolToDelete.name;
		} else {
			eden.error(new Error("forget: The argument must be a string or a pointer, not a " + typeof(arguments[0])), "error");
			return 1;
		}
		
		if (nameToDelete == "/picture") {
			root.lookup("picture").assign(undefined, this);
			return 3;
		}

		if (!symbolToDelete.canSafelyBeForgotten()) {
			return 2;
		}

		symbolToDelete.forget();
		return 0;
	}}$;
};

##Forgets all symbols whose names match a given regular expression or that are explicitly provided
##as a list.  The optional second argument determines if the search is case sensitive.  The optional
##third argument determines if the user will be prompted to confirm the deletions and the optional
##forth "secret" parameter determines if system-defined symbols matching the search criteria will
##also be deleted.
##
##Returns a list.
## 1st element: A list of the symbol names that were successfully forgotten.
## 2nd element: A list of the symbol names that matched the selection criteria but that could not be
##	forgotten either because they are referenced by a dependency or because they act as a trigger for
##	a triggered procedure, or because forgetAll is refusing to forget them because they are system-defined
##	symbols.  This list item is undefined if an error occurs before the relationships between the
##	observables have been analysed (such as if one or more of the arguments are invalid).
## 3rd element: A list of symbol names that could not be forgotten but were set to the undefined
##	value instead of being completely forgotten.  Names such as "picture" appear on this list
##	because forgetting them would destroy some built-in system behaviours that the user might not
##	know how recreate, such as redrawing the canvas if the picture observable is later given a new
##	definition.
##
func forgetAll {
	${{
		/* The forth parameter determines whether or not system defined symbols will also be
		 * deleted.  This feature is for the system's own internal use and is not advertised to end
		 * users.
		 */
		var searchStr, caseSensitive, requireConfirm, includeSystemSymbols;
		var regExp, symbol;
		var obsToDelete = undefined;
		var includeAgent = {name: "/include"};
		
		if (arguments.length == 0 || arguments.length > 4) {
			eden.error(new Error("forgetAll: This function requires at least 1 argument and at most 3 arguments."), "error");
			return [[], undefined, []];
		}
		
		if (typeof(arguments[0]) == "string") {
			searchStr = arguments[0];
		} else if (Array.isArray(arguments[0])) {
			obsToDelete = arguments[0];
		} else if (arguments[0] === undefined) {
			return [[], undefined, []];
		} else {
			eden.error(new Error("forgetAll: The first argument must be a string, not a " + typeof(arguments[0])), "error");
			return [[], undefined, []];
		}

		if (arguments.length > 1) {
			if (typeof(arguments[1]) != "boolean") {
				eden.error(new Error("forgetAll: The second argument must be a boolean, not a " + typeof(arguments[1])), "error");
				return [[], undefined, []];
			}
			caseSensitive = arguments[1];
		} else {
			caseSensitive = true;
		}
		
		if (arguments.length >= 2 && obsToDelete !== undefined) {
			eden.error(new Error("forgetAll: Cannot specify case sensitivity when selecting using a list."), "error");
			return [[], undefined, []];
		}
		
		if (arguments.length >= 3) {
			if (typeof(arguments[2]) != "boolean") {
				eden.error(new Error("forgetAll: The third argument must be a boolean, not a " + typeof(arguments[2])), "error");
				return [[], undefined, []];
			}
			requireConfirm = arguments[2];
		} else {
			requireConfirm = true;
		}
		
		if (arguments.length > 3) {
			if (arguments.length > 4 || typeof(arguments[3]) != "boolean") {
				eden.error(new Error("forgetAll: This function requires at least 1 argument and at most 3 arguments."), "error");
				return [[], undefined, []];
			}
			includeSystemSymbols = arguments[3];
		} else {
			includeSystemSymbols = false;
		}
		
		var references = {};
		var unableToDelete = [];
		var reset = {};

		var initialDefinition;
		if (obsToDelete !== undefined) {

			//Observables given as a list.
			for (var i = 0; i < obsToDelete.length; i++) {
				var name;
				if (obsToDelete[i] instanceof Symbol) {
					name = obsToDelete[i].name.slice(1);
					symbol = obsToDelete[i];
				} else if (typeof(obsToDelete[i]) == "string") {
					name = obsToDelete[i];
					symbol = root.lookup(name);
				} else if (obsToDelete === undefined) {
					continue;
				} else {
					eden.error(new Error("forgetAll: All list items must be strings or pointers.  Item " + i + " is a " + typeof(obsToDelete[i])), "error");
					return [[], undefined, []];
				}

				if (!includeSystemSymbols && Eden.isitSystemSymbol(name)) {
					unableToDelete.push(name);
					continue;
				}

				initialDefinition = eden.initialDefinition(name);
				if (initialDefinition) {
					reset[name] = initialDefinition;
				} else {
					var referencedBy = [];
					for (var dependency in symbol.subscribers) {
						referencedBy.push(dependency.slice(1));
					}
					for (var triggeredProc in symbol.observers) {
						referencedBy.push(triggeredProc.slice(1));
					}
					references[name] = referencedBy;
				}
			}

		} else {

			//Search for observables by regular expression.
			if (caseSensitive) {
				regExp = new RegExp(searchStr);
			} else {
				regExp = new RegExp(searchStr, "i");
			}
			
			for (var name in root.symbols) {
				if (regExp.test(name)) {
					if (!includeSystemSymbols && Eden.isitSystemSymbol(name)) {
						continue;
					}
					
					initialDefinition = eden.initialDefinition(name);
					if (initialDefinition) {
						reset[name] = initialDefinition;
					} else {
						symbol = root.symbols[name];
						var referencedBy = [];
						for (var dependency in symbol.subscribers) {
							referencedBy.push(dependency.slice(1));
						}
						for (var triggeredProc in symbol.observers) {
							referencedBy.push(triggeredProc.slice(1));
						}
						references[name] = referencedBy;
					}
				}
			}
		}
		
		var canForget = {};

		/* Traverses the subgraph of symbols suggested for deletion and returns true if the named
		 * symbol isn't referenced by anything outside of the subgraph.
		 */
		var isSafeToForget = function (name) {
			if (name in canForget) {
				return canForget[name];
			}
			if (name in reset) {
				return true;
			}
			if (!(name in references)) {
				canForget[name] = false;
				return false;
			}
			var referencedBy = references[name];
			if (referencedBy.length == 0) {
				canForget[name] = true;
				return true;
			} else {
				for (var i = 0; i < referencedBy.length; i++) {
					var success = isSafeToForget(referencedBy[i]);
					if (!success) {
						canForget[name] = false;
						return false;
					}
				}
				canForget[name] = true;
				return true;
			}
		};
		
		var namesToDelete = [];
		for (name in references) {
			var success = isSafeToForget(name);
			if (success) {
				namesToDelete.push(name);
			} else {
				unableToDelete.push(name);
			}
		}
		
		var confirmed;
		var resetList = Object.keys(reset);
		var deletePlusReset = namesToDelete.concat(resetList);
		if (deletePlusReset.length >0 && requireConfirm) {
			if (deletePlusReset.length <= 50) {
				confirmed = confirm("You are about to delete the following " + deletePlusReset.length +
					" symbols.  Is this correct?\n\n" + deletePlusReset.join("\n"));
			} else {
				var numNotDisplayed = deletePlusReset.length - 50;
				confirmed = confirm("You are about to delete " + deletePlusReset.length +
					" symbols.  Is this correct?\n\n" + deletePlusReset.slice(0, 50).join("\n") +
					"\n...\n(" + numNotDisplayed + " more)");
			}
		} else {
			confirmed = true;
		}
		
		if (confirmed) {
			var noop = function () { };
			var wasInInitialState = eden.isInInitialState();
			var autocalcSym = root.lookup("autocalc");
			var autoCalcEnabledOnEntry = autocalcSym.value();
			if (autoCalcEnabledOnEntry) {
				autocalcSym.assign(0, this);
			}

			for (name in reset) {
				eden.execute(reset[name], "forgetAll", "", includeAgent, noop);
			}

			for (var i = 0; i < namesToDelete.length; i++) {
				var name = namesToDelete[i];
				symbol = root.symbols[name];
				if ("refreshView" in symbol.jsObservers) {
					/* Clear the view's contents before deleting the associated symbol, so at least
					 * it's clear that the view is no longer valid and isn't merely "hung". */
					symbol.assign(undefined);
				}
				symbol.forget();
			}
			if (wasInInitialState) {
				eden.captureInitialState(); //Re-assert still in initial state.		
			}
			if (autoCalcEnabledOnEntry) {
				autocalcSym.assign(1, this);
			}
			return [namesToDelete, unableToDelete, resetList];
		} else {
			return [[], unableToDelete, []];
		}
	}}$;
}

proc error {
	${{
		if (arguments.length > 1) {
			eden.error(new Error("error: This procedure requires at most 1 argument"), "error");
		}
		if (arguments.length == 0) {
			eden.error(new Error("Runtime error"), "error");
		} else {
			eden.error(new Error(arguments[0]), "error");
		}
	}}$;
}

func nameof {
	${{
		if (arguments.length != 1) {
			eden.error(new Error("nameof: This function requires exactly 1 argument."), "error");
			return undefined;
		}

		var pointer = arguments[0];
		
		if (pointer instanceof Symbol) {	
			return pointer.name.slice(1);
		} else if (
			pointer !== null &&
			typeof(pointer) == "object" &&
			"keys" in pointer &&
			Array.isArray(pointer.keys) &&
			pointer.keys.length > 0 &&
			"parent" in pointer &&
			pointer.parent instanceof Symbol
		) {
			return pointer.parent.name.slice(1) + "[" + pointer.keys[0] + "]";
		} else {
			eden.error(new Error("nameof: The argument must be a pointer, not a " + typeof(pointer)), "error");
			return undefined;
		}
	}}$;
}

proc todo {
	auto code;
	if ($# != 1) {
		error("todo: This proc requires exactly 1 argument.");
		return;
	}
	
	code = $[1];
	
	if (code == @) {
		return;
	} else if (!isString(code)) {
		error("todo: The argument must be of type string, not " // type(code));
		return;
	}
	
	code = code // ";";
	
	after (0) {
		execute(code);
	}
}

proc touch {
	${{
		var autocalcEnabledOnEntry = root.autocalc_state;
		if (autocalcEnabledOnEntry) {
			root.autocalc(false);
		}
		for (var i = 0; i < arguments.length; i++) {
			if (arguments[i] instanceof Symbol) {
				root.expireSymbol(arguments[i]);
			} else {
				eden.error(new Error("touch: Argument " + (i+1) + " must be a pointer, not a " + typeof(arguments[i])), "error");
			}
		}
		if (autocalcEnabledOnEntry) {
			root.autocalc(true);
		}
	}}$;
}

##A new JS-EDEN specific function.
func doDefault {
	para value, defaultValue;
	if ($# != 2) {
		error("doDefault: This function requires exactly 2 arguments.");
	}
	if (value == @) {
		if (defaultValue == @) {
			error("doDefault: The default value cannot be undefined.");
		} else {
			return defaultValue;
		}
	} else {
		return value;
	}
}

proc arrangeWindows {
	para windowOrder;
	auto name, curr_x, i;

	if (windowOrder == @) {
		windowOrder = _view_list;
	} else  {
		for (i =  1; i <= _view_list#; i++) {
			if (indexOf(_view_list[i], windowOrder) == 0) {
				windowOrder = windowOrder // [_view_list[i]];
			}
		}
	}
  
	curr_x = 0;
	for (i = 1; i <= windowOrder#; ++i) {
		name = windowOrder[i];
		if (`"_view_"//name//"_position"` != @) {
			continue;
		}
		`"_view_"//name//"_x"` = curr_x;
		`"_view_"//name//"_y"` = 80;
		curr_x += `"_view_"//name//"_width"` + 27;
	}
}

##Autocalc compatibility
autocalc = 1;

##Include the rest of the library

include("library/types.js-e");
include("library/core.js-e");
include("library/lists.js-e");
include("library/maths.jse");
include("library/strings.js-e");
include("library/algebra.jse");
include("library/include_js.js-e");
include("library/dynamic.js-e");
include("library/edenclocks.js-e");
include("library/html.js-e");
include("library/declarevar.js-e");
include("library/generate_function.js-e");

initialViews = ${{getParameterByName("views") }}$;
if (initialViews == "" || initialViews == "default") {
	createView("projects", "ProjectList");
	_view_projects_x = 0;
	_view_projects_y = 0;
	_view_projects_width = 220;
	_view_projects_height = screenHeight - _views_frame_height;
	createCanvas("picture");
	_view_picture_x = _view_projects_width + _views_frame_width;
	_view_picture_y = 0;
	picture is [Image(_view_picture_width / 2 - 299, _view_picture_height / 2 - 80, "images/construit-logo.jpg")];
	createView("input", "ScriptInput");
	if (${{edenUI.getOptionValue("developer") == "true" }}$) {
		##For JS-EDEN developers, position the input window out of the way of the JavaScript console.
		_view_input_x = _view_picture_x + _view_picture_width + _views_frame_width;
		_view_input_y = 0;
	} else {
		##Position input window underneath the canvas.
		_view_input_x = _view_picture_x;
		_view_input_y = _view_picture_height + _views_frame_height;
		_view_input_width = _view_picture_width;
		_view_input_height = max(170, screenHeight - _view_input_y - _views_frame_height);
	}
}
forget(&initialViews);
