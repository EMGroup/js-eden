
debug = {jsExceptions: ${{edenUI.getOptionValue("developer") == "true" }}$ };


proc eager {
if (autocalc == 0) {
autocalc = 1;
autocalc = 0;
};
};

func time {
${{
var now = new Date();
return Math.floor(now.getTime() / 1000);
}}$;
};

proc writeln {
${{
var message = root.lookup("str").definition(root, root.scope)(arguments[0]);
console.log(message);
message = "Output: " + message;
root.lookup("_menubar_status").assign(message, root.scope, this);
if (!root.autocalc_state) {
edenUI.plugins.MenuBar.updateStatus(message);
}
}}$;
}

_authoringMode = "making construals";

func apply {
${{
if (arguments.length != 2) {
eden.error(new Error("apply: This function requires exactly 2 arguments."), "error");
return undefined;
} else if (typeof(arguments[0]) != "function") {
eden.error(new Error("apply: The first argument must be of type func or type proc, not " + typeof(arguments[0])), "error");
return undefined;
} else if (!Array.isArray(arguments[1])) {
eden.error(new Error("apply: The second argument must be of type list, not " + typeof(arguments[1])), "error");
return undefined;
} else {
return arguments[0].apply(this, arguments[1]);
}
}}$;
}

func forget {
${{
if (arguments.length != 1) {
eden.error(new Error("forget: This function requires exactly 1 argument."), "error");
return 2;
}

var nameToDelete, symbolToDelete;

if (typeof(arguments[0]) == "string") {
nameToDelete = arguments[0];
if (!(nameToDelete in root.symbols)) {
return 1;
}
symbolToDelete = root.lookup(nameToDelete);
if (symbolToDelete.garbage) {
return 1;
}
nameToDelete = "/" + nameToDelete;
} else if (arguments[0] instanceof Symbol) {
symbolToDelete = arguments[0];
nameToDelete = symbolToDelete.name;
} else {
eden.error(new Error("forget: The argument must be a string or a pointer, not a " + typeof(arguments[0])), "error");
return 1;
}

if (nameToDelete == "/picture") {
root.lookup("picture").assign(undefined, root.scope, this);
return 3;
}

if (!symbolToDelete.canSafelyBeForgotten()) {
return 2;
}

symbolToDelete.forget();
return 0;
}}$;
};

func forgetAll {
${{
/* The forth parameter determines whether or not system defined symbols will also be
* deleted.  This feature is for the system's own internal use and is not advertised to end
* users.
*/
var searchStr, caseSensitive, requireConfirm, includeSystemSymbols;
var regExp, symbol;
var obsToDelete = undefined;
var includeAgent = {name: "/include"};

if (arguments.length == 0 || arguments.length > 4) {
eden.error(new Error("forgetAll: This function requires at least 1 argument and at most 3 arguments."), "error");
return [[], undefined, []];
}

if (typeof(arguments[0]) == "string") {
searchStr = arguments[0];
} else if (Array.isArray(arguments[0])) {
obsToDelete = arguments[0];
} else if (arguments[0] === undefined) {
return [[], undefined, []];
} else {
eden.error(new Error("forgetAll: The first argument must be a string, not a " + typeof(arguments[0])), "error");
return [[], undefined, []];
}

if (arguments.length > 1) {
if (typeof(arguments[1]) != "boolean") {
eden.error(new Error("forgetAll: The second argument must be a boolean, not a " + typeof(arguments[1])), "error");
return [[], undefined, []];
}
caseSensitive = arguments[1];
} else {
caseSensitive = true;
}

if (obsToDelete !== undefined && arguments.length > 2) {
eden.error(new Error("forgetAll: Cannot specify case sensitivity when selecting using a list."), "error");
return [[], undefined, []];
}

if (arguments.length >= 3) {
if (typeof(arguments[2]) != "boolean") {
eden.error(new Error("forgetAll: The third argument must be a boolean, not a " + typeof(arguments[2])), "error");
return [[], undefined, []];
}
requireConfirm = arguments[2];
} else if (obsToDelete !== undefined && arguments.length == 2) {
requireConfirm = arguments[1];
} else {
requireConfirm = true;
}

if (arguments.length > 3) {
if (arguments.length > 4 || typeof(arguments[3]) != "boolean") {
eden.error(new Error("forgetAll: This function requires at least 1 argument and at most 3 arguments."), "error");
return [[], undefined, []];
}
includeSystemSymbols = arguments[3];
} else {
includeSystemSymbols = false;
}

var references = {};
var unableToDelete = [];
var reset = {};

var initialDefinition;
if (obsToDelete !== undefined) {

//Observables given as a list.
for (var i = 0; i < obsToDelete.length; i++) {
var name;
if (obsToDelete[i] instanceof Symbol) {
name = obsToDelete[i].name.slice(1);
symbol = obsToDelete[i];
} else if (typeof(obsToDelete[i]) == "string") {
name = obsToDelete[i];
symbol = root.lookup(name);
} else if (obsToDelete === undefined) {
continue;
} else {
eden.error(new Error("forgetAll: All list items must be strings or pointers.  Item " + i + " is a " + typeof(obsToDelete[i])), "error");
return [[], undefined, []];
}

if (!includeSystemSymbols && Eden.isitSystemSymbol(name)) {
unableToDelete.push(name);
continue;
}

initialDefinition = eden.initialDefinition(name);
if (initialDefinition) {
reset[name] = initialDefinition;
} else {
var referencedBy = [];
for (var dependency in symbol.subscribers) {
referencedBy.push(dependency.slice(1));
}
for (var triggeredProc in symbol.observers) {
referencedBy.push(triggeredProc.slice(1));
}
references[name] = referencedBy;
}
}

} else {

//Search for observables by regular expression.
if (caseSensitive) {
regExp = new RegExp(searchStr);
} else {
regExp = new RegExp(searchStr, "i");
}

for (var name in root.symbols) {
if (regExp.test(name)) {
if (!includeSystemSymbols && Eden.isitSystemSymbol(name)) {
continue;
}

initialDefinition = eden.initialDefinition(name);
if (initialDefinition) {
reset[name] = initialDefinition;
} else {
symbol = root.symbols[name];
var referencedBy = [];
for (var dependency in symbol.subscribers) {
referencedBy.push(dependency.slice(1));
}
for (var triggeredProc in symbol.observers) {
referencedBy.push(triggeredProc.slice(1));
}
references[name] = referencedBy;
}
}
}
}

var canForget = {};

/* Traverses the subgraph of symbols suggested for deletion and returns true if the named
* symbol isn't referenced by anything outside of the subgraph.
*/
var isSafeToForget = function (name) {
if (name in canForget) {
return canForget[name];
}
if (name in reset) {
return true;
}
if (!(name in references)) {
canForget[name] = false;
return false;
}
var referencedBy = references[name];
if (referencedBy.length == 0) {
canForget[name] = true;
return true;
} else {
for (var i = 0; i < referencedBy.length; i++) {
var success = isSafeToForget(referencedBy[i]);
if (!success) {
canForget[name] = false;
return false;
}
}
canForget[name] = true;
return true;
}
};

var namesToDelete = [];
for (name in references) {
var success = isSafeToForget(name);
if (success) {
namesToDelete.push(name);
} else {
unableToDelete.push(name);
}
}

var confirmed;
var resetList = Object.keys(reset);
var deletePlusReset = namesToDelete.concat(resetList);
if (deletePlusReset.length >0 && requireConfirm) {
if (deletePlusReset.length <= 50) {
confirmed = confirm("You are about to delete the following " + deletePlusReset.length +
" symbols.  Is this correct?\n\n" + deletePlusReset.join("\n"));
} else {
var numNotDisplayed = deletePlusReset.length - 50;
confirmed = confirm("You are about to delete " + deletePlusReset.length +
" symbols.  Is this correct?\n\n" + deletePlusReset.slice(0, 50).join("\n") +
"\n...\n(" + numNotDisplayed + " more)");
}
} else {
confirmed = true;
}

if (confirmed) {
var noop = function () { };
var wasInInitialState = eden.isInInitialState();
root.beginAutocalcOff();

for (name in reset) {
eden.execute(reset[name], "forgetAll", "", includeAgent, noop);
}

for (var i = 0; i < namesToDelete.length; i++) {
var name = namesToDelete[i];
symbol = root.symbols[name];
if (symbol !== undefined) {
if ("refreshView" in symbol.jsObservers) {
/* Clear the view's contents before deleting the associated symbol, so at least
* it's clear that the view is no longer valid and isn't merely "hung". */
symbol.assign(undefined, root.scope);
// Close the window if it's a canvas picture observable.
if ("Canvas2D" in edenUI.plugins) {
edenUI.plugins.Canvas2D.destroyViews(name);
}
}
symbol.forget();
}
}
if (wasInInitialState) {
eden.captureInitialState(); //Re-assert still in initial state.
}
root.endAutocalcOff();
return [namesToDelete, unableToDelete, resetList];
} else {
return [[], unableToDelete, []];
}
}}$;
}

proc error {
${{
if (arguments.length > 1) {
eden.error(new Error("error: This procedure requires exactly 1 argument."), "error");
}
if (arguments.length == 0) {
eden.error(new Error("error: This procedure requires exactly 1 argument."), "error");
} else {
eden.error(new Error(arguments[0]), "error");
}
}}$;
}

func nameof {
${{
if (arguments.length != 1) {
eden.error(new Error("nameof: This function requires exactly 1 argument."), "error");
return undefined;
}

var pointer = arguments[0];

if (pointer instanceof Symbol) {
return pointer.name.slice(1);
} else if (
pointer !== null &&
typeof(pointer) == "object" &&
"keys" in pointer &&
Array.isArray(pointer.keys) &&
pointer.keys.length > 0 &&
"parent" in pointer &&
pointer.parent instanceof Symbol
) {
return pointer.parent.name.slice(1) + "[" + pointer.keys[0] + "]";
} else {
eden.error(new Error("nameof: The argument must be a pointer, not a " + typeof(pointer)), "error");
return undefined;
}
}}$;
}

proc todo {
auto code;
if ($# != 1) {
error("todo: This proc requires exactly 1 argument.");
return;
}

code = $[1];

if (code == @) {
return;
} else if (!isString(code)) {
error("todo: The argument must be of type string, not " // type(code));
return;
}

code = code // ";";

after (0) {
execute(code);
}
}

proc touch {
${{
root.beginAutocalcOff();
for (var i = 0; i < arguments.length; i++) {
if (arguments[i] instanceof Symbol) {
root.expireSymbol(arguments[i]);
} else {
eden.error(new Error("touch: Argument " + (i+1) + " must be a pointer, not a " + typeof(arguments[i])), "error");
}
}
root.endAutocalcOff();
}}$;
}

func doDefault {
para value, defaultValue;
if ($# != 2) {
error("doDefault: This function requires exactly 2 arguments.");
}
if (value == @) {
if (defaultValue == @) {
error("doDefault: The default value cannot be undefined.");
} else {
return defaultValue;
}
} else {
return value;
}
}

proc arrangeWindows {
para windowOrder;
auto name, curr_x, i;

if (windowOrder == @) {
windowOrder = _views_list;
} else  {
for (i =  1; i <= _views_list#; i++) {
if (indexOf(_views_list[i], windowOrder) == 0) {
windowOrder = windowOrder // [_views_list[i]];
}
}
}

curr_x = 0;
for (i = 1; i <= windowOrder#; ++i) {
name = windowOrder[i];
if (`"_view_"//name//"_position"` != @) {
continue;
}
`"_view_"//name//"_x"` = curr_x;
`"_view_"//name//"_y"` = 80;
curr_x += `"_view_"//name//"_width"` + 27;
}
}

func include2 {
para file;
${{ edenUI.eden.include2(arguments[0], success) }}$;
}

autocalc = 1;




func char {
${{
if (arguments.length != 1) {
eden.error(new Error("char: this function requires exactly one argument."), "error");
return undefined;
}
var type = typeof(arguments[0]);
if (type == "boolean") {
return arguments[0]? String.fromCharCode(1) : String.fromCharCode(0);
} else if (type == "number") {
return String.fromCharCode(arguments[0]);
} else if (type == "string") {
return arguments[0].charAt(0);
} else {
return undefined;
}
}}$;
}

func int {
${{
if (arguments.length != 1) {
eden.error(new Error("int: this function requires exactly one argument."), "error");
return undefined;
}

var value = arguments[0];
var type = typeof(value);
var number = parseInt(value);

switch (type) {
case "number":
return number;
case "string":
if (!isNaN(number)) {
return number;
} else if (arguments[0].length == 1) {
return value.charCodeAt();
} else {
return 0;
}
case "boolean":
return value? 1 : 0;
default:
return undefined;
}
}}$;
}

func charCode {
${{
if (arguments.length != 1) {
eden.error(new Error("charCode: this function requires exactly one argument."), "error");
return undefined;
}

var value = arguments[0];
if (value === undefined) {
return undefined;
} else if (typeof(value) != "string") {
eden.error(new Error("charCode: The argument must be a string, not a " + typeof(value)), "error");
return undefined;
} else if (value.length != 1) {
eden.error(new Error("charCode: The argument must be a single character, not " + value), "error");
return undefined;
} else {
return value.charCodeAt(0);
}
}}$;
}

func str {
para v;
if ($# != 1) {
error("str: this function requires exactly one argument.");
return @;
}

if (v == @) {
return "undefined";
} else if (isString(v)) {
return v;
} else {
return edenCode(v);
}
}


func type {
${{
if (arguments.length != 1) {
eden.error(new Error("type: this function requires exactly one argument."), "error");
return undefined;
}

var value = arguments[0];

if (value === null) {
return "@";
}

var typeName = typeof(value);

if (typeName == "undefined") {
return "@";
} else if (typeName == "number") {
if (isNaN(value)) {
return "@";
} else if (Number.isInteger(value)) {
return "int";
} else {
return "float";
}
} else if (Array.isArray(value)) {
return "list";
} else if (typeName == "function") {
/* Trying to simplify the following expression confuses the JS-EDEN
* parser, which doesn't understand comment characters inside a reg
* exp inside JavaScript inside EDEN code.
*/
if ((new RegExp("\\breturn\\s+([^\\/;]|(\\/[^\\/" + "*]))")).test(value.toString())) {
return "func";
} else {
return "proc";
}
} else if (
(value instanceof Symbol) || (
typeName == "object" &&
"keys" in value &&
Array.isArray(value.keys) &&
value.keys.length > 0 &&
"parent" in value &&
value.parent instanceof Symbol
)) {
return "pointer";
} else {
//boolean, object or string
return typeName;
}
}}$;
}

func isBoolean {
${{
if (arguments.length != 1) {
eden.error(new Error("isBoolean: This function requires exactly 1 argument."), "error");
return undefined;
}
return typeof(arguments[0]) == "boolean";
}}$;
}

func isCallable {
${{
if (arguments.length != 1) {
eden.error(new Error("isCallable: This function requires exactly 1 argument."), "error");
return undefined;
}
return typeof(arguments[0]) == "function";
}}$;
}

func isChar {
${{
if (arguments.length != 1) {
eden.error(new Error("isChar: This function requires exactly 1 argument."), "error");
return undefined;
}
return typeof(arguments[0]) == "string" && arguments[0].length == 1;
}}$;
}

func isDefined {
${{
if (arguments.length != 1) {
eden.error(new Error("isDefined: This function requires exactly 1 argument."), "error");
return undefined;
} else if (arguments[0] === undefined) {
return undefined;
} else if (typeof(arguments[0]) == "string") {
var name = arguments[0];
return name in root.symbols;
} else {
eden.error(new Error("isDefined: The argument must be a string, not a " + typeof(arguments[0])), "error");
return undefined;
}
}}$;
}

func isValue {
${{
if (arguments.length != 1) {
eden.error(new Error("isValue: This function requires exactly 1 argument."), "error");
return undefined;
}
var v = arguments[0];
return v !== undefined && v !== null && (typeof(v) != "number" || !isNaN(v));
}}$;
}

func isFunc {
${{
if (arguments.length != 1) {
eden.error(new Error("isFunc: This function requires exactly 1 argument."), "error");
return undefined;
}
var value = arguments[0];
return typeof(value) == "function" && (new RegExp("\\breturn\\s+([^\\/;]|(\\/[^\\/" + "*]))")).test(value.toString());
}}$;
}

func isInt {
${{
if (arguments.length != 1) {
eden.error(new Error("isInt: This function requires exactly 1 argument."), "error");
return undefined;
}
var v = arguments[0];
return Number.isInteger(v);
}}$;
}

func isList {
${{
if (arguments.length != 1) {
eden.error(new Error("isList: This function requires exactly 1 argument."), "error");
return undefined;
}
return Array.isArray(arguments[0]);
}}$;
}

func isNaN {
${{
if (arguments.length != 1) {
eden.error(new Error("isNaN: This function requires exactly 1 argument."), "error");
return undefined;
}
return isNaN(arguments[0]);
}}$;
}

func isNumber {
${{
if (arguments.length != 1) {
eden.error(new Error("isNumber: This function requires exactly 1 argument."), "error");
return undefined;
}
return typeof(arguments[0]) == "number";
}}$;
}

func isObject {
${{
if (arguments.length != 1) {
eden.error(new Error("isObject: This function requires exactly 1 argument."), "error");
return undefined;
}
return arguments[0] !== null && typeof(arguments[0]) == "object" && !Array.isArray(arguments[0]) && !root.lookup("isPointer").definition(root)(arguments[0]);
}}$;
}

func isPoint {
${{
if (arguments.length != 1) {
eden.error(new Error("isPoint: This function requires exactly 1 argument."), "error");
return undefined;
}
return (arguments[0] instanceof Point);
}}$;
}

func isPointer {
${{
if (arguments.length != 1) {
eden.error(new Error("isPointer: This function requires exactly 1 argument."), "error");
return undefined;
}
var value = arguments[0];
return (value instanceof Symbol) || (
typeof(value) == "object" &&
"keys" in value &&
Array.isArray(value.keys) &&
value.keys.length > 0 &&
"parent" in value &&
value.parent instanceof Symbol);
}}$;
}

func isProc {
${{
if (arguments.length != 1) {
eden.error(new Error("isProc: This function requires exactly 1 argument."), "error");
return undefined;
}
var value = arguments[0];
return typeof(value) == "function" && !(new RegExp("\\breturn\\s+([^\\/;]|(\\/[^\\/" + "*]))")).test(value.toString());
}}$;
}

func isString {
${{
if (arguments.length != 1) {
eden.error(new Error("isString: This function requires exactly 1 argument."), "error");
return undefined;
}
return typeof(arguments[0]) == "string";
}}$;
}


func execute {
${{
eden.execute(arguments[0], "execute", "", {name: "/execute"}, function () { } );
}}$;
}

func Point {
${{
var x = arguments[0];
var y = arguments[1];
return new Point(x, y);
}}$;
}

proc createView {
${{
var name = arguments[0];
var type = arguments[1];
var initData = arguments[2];
edenUI.createView(name, type, initData);
}}$;
}

proc showView {
${{
var name = arguments[0];
edenUI.showView(name);
edenUI.brieflyHighlightView(name);
}}$;
}

proc highlightView {
${{
var name = arguments[0];
edenUI.highlightView(name, false);
}}$;
}

proc stopHighlightingView {
${{
var name = arguments[0];
edenUI.stopHighlightingView(name, false, false);
}}$;
}

proc hideView {
${{
var name = arguments[0];
edenUI.minimizeView(name);
}}$;
}

proc destroyView {
${{
var name = arguments[0];
edenUI.destroyView(name);
}}$;
}

proc moveView {
para name, x, y;
together {
`"_view_" // name // "_x"` = x;
`"_view_" // name // "_y"` = y;
}
}

proc resizeView {
para name, width, height;
together {
`"_view_" // name // "_width"` = width;
`"_view_" // name // "_height"` = height;
}
}

_views_frame_width = ${{ edenUI.dialogFrameWidth }}$;
_views_frame_height = ${{ edenUI.dialogFrameHeight }}$;
_views_unit_x = ${{ edenUI.gridSizeX }}$;
_views_unit_y = ${{ edenUI.gridSizeY }}$;

screenWidth = ${{ window.innerWidth }}$ - _views_frame_width;
screenHeight = ${{ window.innerHeight - edenUI.menuBarHeight - edenUI.dialogFrameHeight -  (edenUI.getOptionValue("optHideOnMinimize") != "true"? edenUI.bottomBarHeight : 0)}}$;
${{
window.addEventListener("resize", function (event) {
root.lookup("screenWidth").assign(window.innerWidth - edenUI.dialogFrameWidth, root.scope, Symbol.hciAgent);
root.lookup("screenHeight").assign(window.innerHeight - edenUI.menuBarHeight - edenUI.dialogFrameHeight - (edenUI.getOptionValue("optHideOnMinimize") != "true"? edenUI.bottomBarHeight : 0), root.scope, Symbol.hciAgent);
});
}}$;

proc showObservables { ${{
if (arguments.length > 2) {
eden.error(new Error("showObservables: This procedure requires at most 2 parameters."), "error");
return;
}

var searchStr, viewName;

searchStr = arguments[0];
if (searchStr === undefined) {
searchStr = "";
}
if (typeof(searchStr) != "string") {
eden.error(new Error("showObservables: The first argument must be a string, not a " + typeof(searchStr)), "error");
return;
}

viewName = arguments[1];
if (viewName === undefined) {
viewName = "showObservables";
} else if (typeof(viewName) != "string") {
eden.error(new Error("showObservables: The second argument must be a string, not a " + typeof(viewName)), "error");
return;
}

var inputBox = $('#' + viewName + '-dialog .symbollist-search');
if (inputBox.length == 0) {
edenUI.createView(viewName, "SymbolList");
root.lookup("_view_" + viewName + "_title").assign("Symbol List (" + viewName + ")", root.scope, this);
inputBox = $('#' + viewName + '-dialog .symbollist-search');
} else {
edenUI.showView(viewName);
}
edenUI.brieflyHighlightView(viewName);
inputBox.val(searchStr);
inputBox.keyup();
}}$; }


func array {
${{
if (arguments.length == 0 || arguments.length > 2) {
eden.error(new Error("array: This function requires at least 1 argument and at most 2 arguments."), "error");
return undefined;
}

var n = arguments[0];

if (n === undefined) {
return undefined;
} else if (typeof(n) != "number" || !Number.isInteger(n)) {
eden.error(new Error("array: The first argument must be an int, not a " + typeof(n)), "error");
return undefined;
}

var arr = new Array(n);
if (arguments[1] !== undefined) {
for (var i = 0; i < n; i++) {
arr[i] = arguments[1];
}
}
return arr;
}}$;
}

func indexOf {
para searchValue, list, lowerBound, isSorted;
auto low, high, middle, element, i, haystackType;
if ($# < 2 || $# > 4) {
error("indexOf: this function requires a minimum of 2 arguments and a maximum of 4 arguments.");
return @;
}

if (list == @ || searchValue == @) {
return @;
}

haystackType = type(list);
if (haystackType == "string") {
if (type(searchValue) != "string") {
error("indexOf: the first argument is a string so the second argument must also be a string and not a " // type(searchValue));
return @;
}
if(!isSorted || searchValue# > 1) {
${{
if (arguments[1].length < arguments[0].length) {
//console.log("Warning: possible usage error for indexOf.  The source string has fewer characters than the search string.");
}
return arguments[1].indexOf(arguments[0], arguments[2]) + 1;
}}$;
}
} else if (haystackType != "list") {
error("indexOf: the first argument must be a string or a list.");
return @;
}

if (list# < searchValue#) {
}

if (lowerBound == @) {
low = 1;
} else {
low = lowerBound;
}

high = list#;
if (high == 0) {
return 0;
}

if (isSorted) {
while (low <= high) {
middle = int((low + high) / 2);
element = list[middle];
if (element > searchValue) {
high = middle - 1;
} else if (element < searchValue) {
low = middle + 1;
} else {
return middle;
}
}
} else {
for (i = low; i <= high; i++) {
if (list[i] == searchValue) {
return i;
}
}
}
return 0;
}

func reverse {
para list;
auto result, i;
if ($# != 1) {
error("reverse: This function requires exactly one argument.");
return @;
}
if (list == @) {
return @;
} else if (type(list) != "list") {
error("reverse: The argument must be a list, not a " // type(list));
return @;
}

result = array(list#, @);
for (i = 1; i <= list#; i++) {
result[i] = list[list# - i + 1];
}
return result;
}

func search {
para searchValue, list, compare, lowerBound, isSorted;
auto low, high, middle, relativeOrder, element, i, haystackType;
if ($# < 3 || $# > 5) {
error("search: this function requires a minimum of 3 arguments and a maximum of 5 arguments.");
return @;
}

if (list == @) {
return @;
}

haystackType = type(list);
if (haystackType == "string") {
if (type(searchValue) != "string") {
error("search: the first argument is a string so the second argument must also be a string and not a " // type(searchValue));
return @;
}
if(searchValue# > 1) {
error("search: search can only find a character within a string, not a string of length " // str(searchValue#));
return @;
}
} else if (haystackType != "list") {
error("indexOf: the first argument must be a string or a list, not a " // haystackType);
return @;
}

high = list#;
if (high == 0) {
return 0;
}

if (lowerBound == @) {
low = 1;
} else {
low = lowerBound;
}

if (isSorted) {
while (low <= high) {
middle = int((low + high) / 2);
element = list[middle];
relativeOrder = compare(element, searchValue);
if (relativeOrder > 0) {
high = middle - 1;
} else if (relativeOrder < 0) {
low = middle + 1;
} else {
return middle;
}
}
} else {
for (i = low; i <= high; i++) {
if (compare(list[i], searchValue) == 0) {
return i;
}
}
}
return 0;
}

func sort {
${{
if (arguments.length == 0 || arguments.length > 2) {
eden.error(new Error("sort: this function requires a minimum of 1 argument and a maximum of 2 arguments."), "error");
return undefined;
}
var values = arguments[0];
var sortingSingleString;
if (values === undefined) {
return undefined;
} else if (typeof(values) == "string") {
values = values.split("");
sortingSingleString = true;
} else if (!Array.isArray(values)) {
eden.error(new Error("sort: first argument must be a list or a string, not a " + typeof(values) + "."), "error");
return undefined;
} else {
values = values.slice();
sortingSingleString = false;
}

var sortFunction;
if (arguments.length < 2) {
sortFunction = "ascending";
} else {
sortFunction = arguments[1];
}

if (sortFunction === undefined) {
return values;
} else if (sortFunction == "ascending") {
if (sortingSingleString) {
sortFunction = undefined;
} else {
sortFunction = function (a, b) {
if (a > b) {
return 1;
} else if (a < b) {
return -1;
} else {
return 0;
}
}
}
} else if (sortFunction == "descending") {
sortFunction = function (a, b) {
if (a > b) {
return -1;
} else if (a < b) {
return 1;
} else {
return 0;
}
}
} else if (typeof(sortFunction) != "function") {
eden.error(new Error("sort: unknown collation order " + sortFunction), "error");
return undefined;
}

if (sortingSingleString) {
return values.sort(sortFunction).join("");
} else {
var begin = 0;
var sorted, partition;
for (var i = 0; i < values.length; i++) {
if (values[i] === undefined) {
partition = values.slice(begin, i);
partition.sort(sortFunction);
if (sorted === undefined) {
sorted = partition;
} else {
sorted = sorted.concat(partition);
}
sorted.push(undefined);
begin = i + 1;
}
}

partition = values.slice(begin, values.length);
partition.sort(sortFunction);
if (sorted === undefined) {
sorted = partition;
} else {
sorted = sorted.concat(partition);
}
return sorted;
}
}}$;
}

func sublist {
${{
if (arguments.length < 2 || arguments.length > 3) {
eden.error(new Error("substr: this function requires a minimum of 2 arguments and a maximum of 3 arguments."), "error");
return undefined;
}

var list = arguments[0];
var from = arguments[1];
var to = arguments[2];

if (list === undefined) {
return undefined;
}
if (!Array.isArray(list)) {
eden.error(new Error("sublist: expected list but got " + typeof(list)), "error");
return undefined;
}
if (from === undefined) {
from = 1;
} else if (from > to) {
return [];
}
if (from > 0) {
from = from - 1;
} else if (from == 0) {
eden.error(new Error("sublist: from cannot be 0."), "error");
return undefined;
}
if (to == 0) {
to = list.length;
}

var result = list.slice(from, to);

if (to > list.length) {
result = result.concat(new Array(to - list.length));
}

return result;
}}$;
}

func tail {
if ($# != 1) {
error("tail: This function requires exactly 1 argument.");
return @;
} else if ($[1] == @) {
return @;
} else if (!isList($[1])) {
error("tail: The argument must be a list, not a " // type($[1]));
return @;
} else if ($[1]# == 0) {
error("tail: The empty list does not have a tail.");
return @;
} else {
return sublist($[1], 2, $[1]#);
}
}


PI = ${{ Math.PI }}$;
radiansPerUnit is PI / 180;


${{
/**
* Decimal adjustment of a number.
* from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
*
* @param {String}  type  The type of adjustment ("round", "floor", "ceil" or any other static Math method).
* @param {Number}  value The number.
* @param {Integer} exp   The exponent (the 10 logarithm of the adjustment base) (exp = 0 - number of decimal places required).
* @returns {Number} The adjusted value.
*/
decimalAdjust = function (type, value, exp) {
// If the exp is undefined or zero...
if (typeof exp === 'undefined' || +exp === 0) {
return Math[type](value);
}
value = +value;
exp = +exp;
// If the value is not a number or the exp is not an integer...
if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
return NaN;
}
// Shift
value = value.toString().split('e');
value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
// Shift back
value = value.toString().split('e');
return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
};
}}$;


func roundDown {
${{
if (arguments.length == 0 || arguments.length > 2) {
eden.error(new Error("roundDown: This function requires at least 1 argument and at most 2 arguments."), "error");
return undefined;
}

var number = arguments[0];
if (number === undefined) {
return undefined;
} else if (typeof(number) != "number") {
eden.error(new Error("roundDown: The first argument must be a number, not a " + typeof(number)), "error");
return undefined;
}

var decimalPlaces;
if (arguments.length == 2) {
decimalPlaces = arguments[1];
} else {
decimalPlaces = 0;
}

if (decimalPlaces === 0) {
return Math.round(number);
} else if (decimalPlaces === undefined) {
return undefined;
} else if (typeof(decimalPlaces) != "number") {
eden.error(new Error("roundDown: The second argument must be an int, not a " + typeof(decimalPlaces)), "error");
return undefined;
} else if (!Number.isInteger(decimalPlaces)) {
eden.error(new Error("roundDown: The second argument must be an int, not a float"), "error");
return undefined;
} else {
return decimalAdjust("floor", number, -decimalPlaces);
}
}}$;
}

func round {
${{
if (arguments.length == 0 || arguments.length > 2) {
eden.error(new Error("round: This function requires at least 1 argument and at most 2 arguments."), "error");
return undefined;
}

var number = arguments[0];
if (number === undefined) {
return undefined;
} else if (typeof(number) != "number") {
eden.error(new Error("round: The first argument must be a number, not a " + typeof(number)), "error");
return undefined;
}

var decimalPlaces;
if (arguments.length == 2) {
decimalPlaces = arguments[1];
} else {
decimalPlaces = 0;
}

if (decimalPlaces === 0) {
return Math.round(number);
} else if (decimalPlaces === undefined) {
return undefined;
} else if (typeof(decimalPlaces) != "number") {
eden.error(new Error("round: The second argument must be an int, not a " + typeof(decimalPlaces)), "error");
return undefined;
} else if (!Number.isInteger(decimalPlaces)) {
eden.error(new Error("round: The second argument must be an int, not a float"), "error");
return undefined;
} else {
return parseFloat(number.toFixed(decimalPlaces));
}
}}$;
}

func roundUp {
${{
if (arguments.length == 0 || arguments.length > 2) {
eden.error(new Error("roundUp: This function requires at least 1 argument and at most 2 arguments."), "error");
return undefined;
}

var number = arguments[0];
if (number === undefined) {
return undefined;
} else if (typeof(number) != "number") {
eden.error(new Error("roundUp: The first argument must be a number, not a " + typeof(number)), "error");
return undefined;
}

var decimalPlaces;
if (arguments.length == 2) {
decimalPlaces = arguments[1];
} else {
decimalPlaces = 0;
}

if (decimalPlaces === 0) {
return Math.round(number);
} else if (decimalPlaces === undefined) {
return undefined;
} else if (typeof(decimalPlaces) != "number") {
eden.error(new Error("roundUp: The second argument must be an int, not a " + typeof(decimalPlaces)), "error");
return undefined;
} else if (!Number.isInteger(decimalPlaces)) {
eden.error(new Error("roundUp: The second argument must be an int, not a float"), "error");
return undefined;
} else {
return decimalAdjust("ceil", number, -decimalPlaces);
}
}}$;
}



func floor {
${{
if (arguments.length < 1 || arguments.length > 2) {
eden.error(new Error("floor: This function requires at least 1 argument and at most 2 arguments."), "error");
return undefined;
}

var number = arguments[0];
if (number === undefined) {
return undefined;
} else if (typeof(number) != "number") {
eden.error(new Error("floor: The first argument must be a number, not a " + typeof(number)), "error");
return undefined;
}

var multiple;
if (arguments.length == 2) {
multiple = arguments[1];
if (multiple === undefined) {
return undefined;
} else if (typeof(multiple) != "number") {
eden.error(new Error("floor: The second argument must be a number, not a " + typeof(multiple)), "error");
return undefined;
}
} else {
multiple = 1;
}

if (multiple == 1) {
return Math.floor(number);
} else {
return Math.floor((number / multiple).toPrecision(16)) * multiple;
}
}}$;
}

func roundMultiple {
${{
if (arguments.length != 2) {
eden.error(new Error("roundMultiple: This function requires exactly 2 arguments."), "error");
return undefined;
}

var number = arguments[0];
if (number === undefined) {
return undefined;
} else if (typeof(number) != "number") {
eden.error(new Error("roundMultiple: The first argument must be a number, not a " + typeof(number)), "error");
return undefined;
}

var multiple = arguments[1];
if (multiple === undefined) {
return undefined;
} else if (typeof(multiple) != "number") {
eden.error(new Error("roundMultiple: The second argument must be a number, not a " + typeof(multiple)), "error");
return undefined;
}

if (multiple == 1) {
return Math.round(number);
} else {
return Math.round((number / multiple).toPrecision(16)) * multiple;
}
}}$;
}

func ceil {
${{
if (arguments.length < 1 || arguments.length > 2) {
eden.error(new Error("ceil: This function requires at least 1 argument and at most 2 arguments."), "error");
return undefined;
}

var number = arguments[0];
if (number === undefined) {
return undefined;
} else if (typeof(number) != "number") {
eden.error(new Error("ceil: The first argument must be a number, not a " + typeof(number)), "error");
return undefined;
}

var multiple;
if (arguments.length == 2) {
multiple = arguments[1];
if (multiple === undefined) {
return undefined;
} else if (typeof(multiple) != "number") {
eden.error(new Error("ceil: The second argument must be a number, not a " + typeof(multiple)), "error");
return undefined;
}
} else {
multiple = 1;
}

if (multiple == 1) {
return Math.ceil(number);
} else {
return Math.ceil((number / multiple).toPrecision(16)) * multiple;
}
}}$;
}




func abs {
return ${{ Math.abs(arguments[0]); }}$;
}

func acos {
return ${{ Math.acos(arguments[0]) }}$ / radiansPerUnit;
}

func asin {
return ${{ Math.asin(arguments[0]) }}$ / radiansPerUnit;
}

func atan {
return ${{ Math.atan(arguments[0]) }}$ / radiansPerUnit;
}

func cos {
return ${{ Math.cos(arguments[0]*root.lookup("radiansPerUnit").value()); }}$;
}

func exp {
return ${{ Math.exp(arguments[0]); }}$;
}

func ln {
return ${{ Math.log(arguments[0]); }}$;
}

func log {
${{
var number = arguments[0];
var base;
if (arguments.length == 1) {
base = 10;
} else if (arguments.length != 2) {
eden.error(new Error("log: The function requires at least one argument and at most two arguments."), "error");
return undefined;
} else {
base = arguments[1];
}

if (number === undefined || base === undefined) {
return undefined;
} else if (typeof(number) != "number") {
eden.error(new Error("log: The first argument must be a number, not a " + typeof(number)), "error");
} else if (typeof(base) != "number") {
eden.error(new Error("log: The second argument must be a number, not a " + typeof(base)), "error");
}

return Math.log(number) / Math.log(base);
}}$;
}

func max {
auto list, i, maxSoFar;

if ($# == 0) {
return @;
} else if ($# == 1 && type($[1]) == "list") {
list = $[1];
if (list# == 0) {
return @;
}
} else {
list = $;
}

maxSoFar = list[1];
for (i = 2; i <= list#; i++) {
if (list[i] > maxSoFar) {
maxSoFar = list[i];
}
}
return maxSoFar;
}

func min {
auto list, i, minSoFar;

if ($# == 0) {
return @;
} else if ($# == 1 && type($[1]) == "list") {
list = $[1];
if (list# == 0) {
return @;
}
} else {
list = $;
}

minSoFar = list[1];

for (i = 2; i <= list#; i++) {
if (list[i] < minSoFar) {
minSoFar = list[i];
}
}
return minSoFar;
}

func mod {
para x, n;
return x>=0? x % n : (n + (x % n));
}

func pow {
return ${{ Math.pow(arguments[0],arguments[1]); }}$;
}

func randomBoolean {
para probability;
if (probability == @) {
probability = 0.5;
}
return random() <= probability;
}

func randomInteger {
${{
if (arguments.length != 2) {
eden.error(new Error("randomInteger: This function requires exactly 2 arguments"), "error");
return undefined;
}

var lowerBound = arguments[0];
var upperBound = arguments[1];

if (lowerBound === undefined || upperBound === undefined) {
return undefined;
} else if (typeof(lowerBound) != "number") {
eden.error(new Error("randomInteger: The lower bound must be an int, not a " + typeof(lowerBound)), "error");
return undefined;
} else if (isNaN(lowerBound)) {
return undefined;
} else if (!Number.isInteger(lowerBound)) {
eden.error(new Error("randomInteger: The lower bound must be an int, not a float."), "error");
return undefined;
} else if (typeof(upperBound) != "number") {
eden.error(new Error("randomInteger: The upper bound must be an int, not a " + typeof(upperBound)), "error");
return undefined;
} else if (isNaN(upperBound)) {
return undefined;
} else if (!Number.isInteger(upperBound)) {
eden.error(new Error("randomInteger: The upper bound must be an int, not a float."), "error");
return undefined;
}

var n = Math.floor(root.lookup("random").definition(root, root.scope)() * (upperBound - lowerBound + 1) + lowerBound);
if (n > upperBound) {
// 1 / 2^62 chance
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
n = upperBound;
}
return n;
}}$;
}

func randomFloat {
${{
if (arguments.length != 2) {
eden.error(new Error("randomFloat: This function requires exactly 2 arguments"), "error");
return undefined;
}

var lowerBound = arguments[0];
var upperBound = arguments[1];

if (lowerBound === undefined || upperBound === undefined) {
return undefined;
} else if (typeof(lowerBound) != "number") {
eden.error(new Error("randomFloat: The lower bound must be a float, not a " + typeof(lowerBound)), "error");
return undefined;
} else if (isNaN(lowerBound)) {
return undefined;
} else if (typeof(upperBound) != "number") {
eden.error(new Error("randomFloat: The upper bound must be a float, not a " + typeof(upperBound)), "error");
return undefined;
} else if (isNaN(upperBound)) {
return undefined;
}

var n = root.lookup("random").definition(root)() * (upperBound - lowerBound + 1) + lowerBound;
if (n > upperBound) {
n = upperBound;
}
return n;
}}$;
}

${{
xorshift32Random = function (state) {
state ^= state << 13;
state ^= state >>> 17;
state ^= state << 5;
return state;
}
}}$;

func xorshiftRandomGenerator {
${{
var stateSym = root.lookup("randomGeneratorState");
var lower = xorshift32Random(stateSym.value());
var upper = xorshift32Random(lower);
stateSym.assign(upper, root.scope, root.lookup("xorshiftRandomGenerator"));
upper = Math.abs(upper) * 4194304; // 2^22, 53 bits of precision in total
return (upper + Math.abs(lower)) / 9007199254740991; // 2^53 - 1
}}$;
}

randomSeed = @;
randomGenerator is xorshiftRandomGenerator;

${{
window.inRandomFunc = false;

root.lookup("randomSeed").addJSObserver("applySeed", function (obs, seed) {
root.lookup("randomGeneratorState").assign(seed, root.scope, obs);
root.lookup("randomIndex").assign(0, root.scope, obs);
});

root.lookup("randomGenerator").addJSObserver("applySeed", function (obs, generator) {
root.lookup("randomGeneratorState").assign(root.lookup("randomSeed").value(), root.scope, obs);
root.lookup("randomIndex").assign(0, root.scope, obs);
});

root.lookup("randomIndex").addJSObserver("skipToIndex", function (obs, desiredIndex) {
if (inRandomFunc) {
return;
}
inRandomFunc = true;
var generator = root.lookup("randomGenerator").value();
root.lookup("randomGeneratorState").assign(root.lookup("randomSeed").value(), root.scope, obs);
for (var i = 0; i < desiredIndex; i++) {
generator();
}
inRandomFunc = false;
});
}}$;

func random {
auto result;
${{ inRandomFunc = true; }}$;
randomIndex++;
if (randomSeed == @) {
result = ${{ Math.random() }}$;
} else {
result = randomGenerator();
}
${{ inRandomFunc = false; }}$;
return result;
}

func sin {
return ${{ Math.sin(arguments[0]*root.lookup("radiansPerUnit").value()); }}$;
}

func sqrt {
return ${{ Math.sqrt(arguments[0]); }}$;
}

func sum {
${{
var list, total, type;
if (arguments.length == 1 && Array.isArray(arguments[0])) {
list = arguments[0];
} else {
list = arguments;
}

total = 0;
for (var i = 0; i < list.length; i++) {
type = typeof(list[i]);
if (type === undefined) {
return undefined;
} else if (type == "number" || type == "boolean") {
total = total + list[i];
} else {
eden.error(new Error("sum: Item " + i + " must be a number, not a " + type));
return undefined;
}
}
return total;
}}$;
}

func tan {
return ${{ Math.tan(arguments[0]*root.lookup("radiansPerUnit").value()); }}$;
}



func concat {
auto separator, concatStrings, list, i, item, result;
concatStrings = false;
if ($# == 0) {
error("concat: This function requires at least one argument.");
return @;
} else if ($# == 1 && isList($[1])) {
list = $[1];
} else if ($# == 2 && isList($[2])) {
if (isList($[1])) {
return $[2];
} else {
separator = $[1];
list = $[2];
}
} else {
separator = $[1];
list = sublist($, 2, $#);
}

for (i = 1; i <= list#; i++) {
if (list[i] == @) {
return @;
} else if (!isList(list[i])) {
concatStrings = true;
break;
}
}

if ($# == 1 && isList($[1])) {
if (concatStrings) {
separator = "";
result = "";
} else {
separator = [];
result = [];
}
} else if (concatStrings) {
if (separator == @) {
if (list# > 1) {
return @;
}
} else {
separator = str(separator);
}
result = "";
} else {
if (!isList(separator)) {
separator = [separator];
}
result = [];
}

for (i = 1; i < list#; i++) {
if (concatStrings) {
item = str(list[i]);
} else {
item = list[i];
}
result = result // item // separator;
}
if (list# > 0) {
if (concatStrings) {
item = str(list[list#]);
} else {
item = list[list#];
}
result = result // item;
}
return result;
}

${{
/* Replaces HTML character entities in a string with the equivalent real characters with the
* following exceptions: &amp; &lt; &gt; &quot; &apos;
*/
root.lookup("decodeHTML").assignFunction( (function() {
var element = document.createElement('div');

function decodeHTML (str) {
if (typeof(str) == "string") {
//Strip html tags
str = str.replace(/&(amp|#38|lt|#60|gt|#62|quot|#34|apos|#39);/g, "&amp;$1;");
str = str.replace(/&([^\s;]*\s)/g, "&amp;$1");
str = str.replace(/</g, "&lt;");
element.innerHTML = str;
str = element.textContent;
element.textContent = '';
}

return str;
}

return decodeHTML;
})(), {name: "/include"} );
}}$;


func lowercase {
${{
if (arguments.length != 1) {
eden.error(new Error("lowercase: This function requires exactly 1 argument."), "error");
return undefined;
}

var arg = arguments[0];

if (arg === undefined) {
return undefined;
} else if (typeof(arg) == "string") {
return arg.toLocaleLowerCase();
} else {
eden.error(new Error("lowercase: This function cannot be applied to a value of type " + typeof(arg)), "error");
return undefined;
}
}}$;
}

func RE {
${{
if (arguments.length < 1 || arguments.length > 3) {
eden.error(new Error("RE: The function requires at least 1 argument and at most 3 arguments"), "error");
return undefined;
}
var pattern = arguments[0];
if (pattern === undefined) {
return undefined;
} else if (typeof(pattern) != "string") {
eden.error(new Error("RE: The first argument must be a string, not a " + typeof(pattern)), "error");
return undefined;
}

var caseSensitive, global;
if (arguments.length >= 2) {
caseSensitive = arguments[1];
if (caseSensitive === undefined) {
return undefined;
} else if (typeof(caseSensitive) != "boolean") {
eden.error(new Error("RE: The second argument must be a boolean, not a " + typeof(caseSensitive)), "error");
return undefined;
}
if (arguments.length == 3) {
global = arguments[2];
if (global === undefined) {
return undefined;
} else if (typeof(global) != "boolean") {
eden.error(new Error("RE: The third argument must be a boolean, not a " + typeof(global)), "error");
return undefined;
}
} else {
global = true;
}
} else {
caseSensitive = true;
global = true;
}

var flags;
if (caseSensitive) {
flags = "";
} else {
flags = "i";
}
if (global) {
flags = flags + "g";
}
return new RegExp(pattern, flags);
}}$;
}

func indexOfRE {
${{
if (arguments.length < 2 || arguments.length > 4) {
eden.error(new Error("indexOfRE: The function requires at least 2 arguments and at most 4 arguments"), "error");
return undefined;
}
var pattern = arguments[0];
var reFromObject = false;
if (pattern === undefined) {
return undefined;
} else if (pattern instanceof RegExp) {
reFromObject = true;
} else if (typeof(pattern) != "string") {
eden.error(new Error("indexOfRE: The first argument must be a string or a regular expression object, not a " + typeof(pattern)), "error");
return undefined;
}

var caseSensitive = true;
var argsProcessed = 1;
var subject, offset;

if (arguments.length > 2) {
if (arguments[1] === undefined) {
return undefined;
} else if (typeof(arguments[1]) == "string") {
subject = arguments[1];
argsProcessed = 2;
} else if (reFromObject) {
if (arguments[1] !== undefined) {
eden.error(new Error("indexOfRE: Case sensitivity cannot be specified separately when the regular expression is selected using the RE function."), "error");
}
return undefined;
} else if (typeof(arguments[1]) == "boolean") {
caseSensitive = arguments[1];
subject = arguments[2];
argsProcessed = 3;
} else {
eden.error(new Error("indexOfRE: The second argument must be a string or a boolean, not a " + typeof(arguments[1])), "error");
return undefined;
}
if (arguments.length > argsProcessed) {
offset = arguments[argsProcessed];
if (typeof(offset) == "number") {
if (!Number.isInteger(offset) || offset < 1) {
eden.error(new Error("indexOfRE: The starting offset must be a positive integer."), "error");
return undefined;
}
offset--;
} else {
eden.error(new Error("indexOfRE: The starting offset must be a positive integer, not a " + typeof(offset)), "error");
return undefined;
}
}
} else {
subject = arguments[1];
}

if (subject === undefined) {
return undefined;
} else if (typeof(subject) != "string") {
eden.error(new Error("indexOfRE: The value to match against must be a string, not a " + typeof(caseSensitive)), "error");
return undefined;
}

var regExp;
if (reFromObject) {
regExp = pattern;
if (offset !== undefined && offset != 0 && !regExp.global) {
return subject.slice(offset).search(regExp) + offset + 1;
}
} else if (caseSensitive) {
regExp = new RegExp(pattern, "g");
} else {
regExp = new RegExp(pattern, "ig");
}
if (offset !== undefined) {
regExp.lastIndex = offset;
}
if (offset !== undefined || (reFromObject && regExp.global)) {
var match = regExp.exec(subject);
if (match === null) {
return 0;
} else {
return regExp.lastIndex;
}
} else {
return subject.search(regExp) + 1;
}
}}$;
}

func escapeRE {
${{
if (arguments.length != 1) {
eden.error(new Error("escapeRE: This function requires exactly one argument."), "error");
return undefined;
}
var str = arguments[0];
if (str === undefined) {
return undefined;
} else if (typeof(str) != "string") {
eden.error(new Error("escapeRE: The argument must be a string, not a " + typeof(str)), "error");
return undefined;
}

metaRE = /([\\^$*+?.()|{[\]])/g;
return str.replace(metaRE, "\\$1");
}}$;
}

func replaceFirst {
${{
if (arguments.length < 3 || arguments.length > 4) {
eden.error(new Error("replaceFirst: This function requires a minimum of 3 arguments and a maximum of 4 arguments."), "error");
return undefined;
}
var source = arguments[0];
if (source === undefined) {
return undefined;
} else if (typeof(source) != "string") {
eden.error(new Error("replaceFirst: The first argument must be a string, not a " + typeof(source)), "error");
return undefined;
}

var search = arguments[1];
if (search === undefined) {
return undefined;
} else if (typeof(search) != "string") {
eden.error(new Error("replaceFirst: The second argument must be a string, not a " + typeof(search)), "error");
return undefined;
}

var replacement = arguments[2];
if (replacement === undefined) {
if (source.indexOf(search) == -1) {
return source;
} else {
return undefined;
}
} else if (typeof(replacement) != "string") {
eden.error(new Error("replaceFirst: The third argument must be a string, not a " + typeof(replacement)), "error");
return undefined;
}

if (arguments.length == 3) {
return source.replace(search, replacement);
} else {
var startPos = arguments[3];
if (startPos !== undefined && typeof(startPos) != "number") {
eden.error(new Error("replaceFirst: The forth argument must be an int, not a " + typeof(startPos)), "error");
return undefined;
} else if (startPos === undefined || isNaN(startPos)) {
if (source.indexOf(search) == -1) {
return source;
} else {
return undefined;
}
} else if (!Number.isInteger(startPos)) {
eden.error(new Error("replaceFirst: The forth argument must be an int, not a float."), "error");
return undefined;
} else if (startPos == 0) {
eden.error(new Error("replaceFirst: The forth argument must cannot be 0."), "error");
return undefined;
} else if (startPos > 0) {
return source.slice(0, startPos - 1).concat(source.slice(startPos - 1).replace(search, replacement));
} else {
return source.slice(0, startPos).concat(source.slice(startPos).replace(search, replacement));
}
}
}}$;
}

func substitute {
${{
var placeholderRE = /(^|[^\\])\{([^}]+)\}/g;
if (arguments.length == 0) {
eden.error(new Error("substitute: This function requires at least one argument."), "error");
return undefined;
} else if (arguments[0] === undefined) {
return undefined;
} else if (typeof(arguments[0]) != "string") {
eden.error(new Error("substitute: The first argument must be a string, not a " + typeof(arguments[0])), "error");
return undefined;
} else if (arguments.length == 1 && placeholderRE.test(arguments[0])) {
eden.error(new Error("substitute: The target string contains placeholders but no placeholder values were provided."), "error");
return undefined;
}

var argList;
var useObject = false;
var isArray = Array.isArray(arguments[1]);
if (arguments.length == 2 && isArray && arguments[1].length > 0) {
argList = arguments[1];
argList.unshift("");
} else {
argList = arguments;
if (arguments.length == 2 && !isArray && typeof(arguments[1]) == "object" && arguments[1] !== null) {
useObject = true;
}
}
var meArgs = arguments;

var strFunc = root.lookup("str").value();
var digitsRE = /\d+/;
var observables = {};
var scannedForObservables = false;
var errorMsg;
function replaceFunc (match, beforeChar, varName) {
var value;
if (digitsRE.test(varName)) {
//Case 1: Placeholders are numeric, {1}, etc.
var num = parseInt(varName);
if (num == 0) {
errorMsg = "Bad placeholder {0}";
value = "";
} else if (num < argList.length) {
value = argList[num];
} else if (argList.length == 2 && argList[1] === undefined) {
//Could have intended to pass a list but passed undefined instead.
value = "undefined";
} else {
errorMsg = "Found placeholder {" + varName + "} but only " + (argList.length - 1) + " values were provided.";
value = "";
}
} else if (useObject) {
//Case 2: Placeholders refer to object properties.
value = meArgs[1][varName];
} else {
//Case 3: Placeholders refer to observable names.
if (!scannedForObservables) {
for (var i = 1; i < argList.length ; i++) {
if (argList[i] instanceof Symbol) {
observables[argList[i].name.slice(1)] = argList[i];
}
}
scannedForObservables = true;
}
if (!(varName in observables)) {
if (meArgs.length == 2 && (meArgs[1] === undefined || meArgs[1] === null)) {
value = "undefined";
} else {
errorMsg = "Found placeholder for observable " + varName + " but couldn't find a matching pointer-typed argument in the argument list.";
}
} else {
value = observables[varName].value();
}
}
return beforeChar + strFunc(value);
};

var replaced = arguments[0].replace(placeholderRE, replaceFunc);
if (errorMsg !== undefined) {
eden.error(new Error("substitute: " + errorMsg), "error");
return undefined;
}
return replaced;
}}$;
}

func substr {
${{
if (arguments.length < 2 || arguments.length > 3) {
eden.error(new Error("substr: this function requires a minimum of 2 arguments and a maximum of 3 arguments."), "error");
return undefined;
}

var str = arguments[0];
var from = arguments[1];
var to = arguments[2];

if (str === undefined) {
return undefined;
}
if (typeof(str) != "string") {
eden.error(new Error("substr: expected string but got " + typeof(str)), "error");
return undefined;
}
if (from === undefined) {
from = 1;
} else if (from > to) {
return "";
}
if (from > 0) {
from = from - 1;
} else if (from == 0) {
eden.error(new Error("substr: from cannot be 0."), "error");
return undefined;
}
if (to == 0) {
to = str.length;
}

var result = str.slice(from, to);

if (to > str.length) {
result = result + Array(to - str.length + 1).join(" ");
}

return result;
}}$;
}

func trim {
${{
if (arguments.length < 1 || arguments.length > 2) {
eden.error(new Error("trim: This function requires at least 1 argument and at most 2 arguments."), "error");
return undefined;
}

var value = arguments[0];

var trimType;
if (arguments.length == 1) {
trimType = "both";
} else {
trimType = arguments[1];
}

if (value === undefined) {
if (trimType == "left" || trimType == "right" || trimType == "both") {
return undefined;
}
} else if (typeof(value) != "string") {
eden.error(new Error("trim: The first argument cannot be of type " + typeof(value)), "error");
return undefined;
}

if (trimType == "left") {
return value.replace(/^\s*/, "");
} else if (trimType == "right") {
return value.replace(/\s*$/, "");
} else if (trimType == "both") {
return value.replace(/(^\s*)|(\s*$)/g, "");
} else {
eden.error(new Error("trim: type of trimming must be \"left\", \"right\" or \"both\"."), "error");
return undefined;
}
}}$;
}

func uppercase {
${{
if (arguments.length != 1) {
eden.error(new Error("uppercase: This function requires exactly 1 argument."), "error");
return undefined;
}

var arg = arguments[0];

if (arg === undefined) {
return undefined;
} else if (typeof(arg) == "string") {
return arg.toLocaleUpperCase();
} else {
eden.error(new Error("upercase: This function cannot be applied to a value of type " + typeof(arg)), "error");
return undefined;
}
}}$;
}


func centroid {
auto points, x, y, i, nx, ny;
if ($# == 1 && isList($[1])) {
points = $[1];
} else {
points = $;
}

nx = 0;
ny = 0;
for (i = 1; i <= points#; i++) {
if (points[i] != @) {
if (!isPoint(points[i])) {
error("centroid: Item " // str(i) // " must be a Point, not a " // type(points[i]));
return @;
}
if (points[i].x != @) {
if (x == @) {
x = points[i].x;
} else {
x = x + points[i].x;
}
nx++;
}
if (points[i].y != @) {
if (y == @) {
y = points[i].y;
} else {
y = y + points[i].y;
}
ny++;
}
}
}
if (nx != 0) {
x = x / nx;
}
if (ny != 0) {
y = y / ny;
}
return {x, y};
}

func length {
${{
var from, to;
if (arguments.length == 1) {
if (arguments[0] instanceof Line) {
var line = arguments[0];
from = new Point(line.x1, line.y1);
to = new Point(line.x2, line.y2);
} else {
to = arguments[0];
from = new Point(0, 0);
}
} else if (arguments.length == 2) {
from = arguments[0];
to = arguments[1];
if (from == undefined) {
return undefined;
} else if (!(from instanceof Point)) {
eden.error(new Error("length: The first argument must be a Point or a Line, not a " + typeof(from)), "error");
return undefined;
}
} else {
eden.error(new Error("length: This function requires at least 1 argument and at most 2 arguments"), "error");
return undefined;
}
if (to == undefined) {
return undefined;
} else if (!(to instanceof Point)) {
eden.error(new Error("length: The destination point must be a Point, not a " + typeof(to)), "error");
return undefined;
}
if (from.x == undefined || from.y == undefined || to.x == undefined || to.y == undefined) {
return undefined;
}
var xDist = to.x - from.x;
var yDist = to.y - from.y;
return Math.sqrt(xDist * xDist + yDist * yDist);
}}$;
}

func rotatePoint {
para point, theta, centre;
auto translatedX, translatedY, rotatedX, rotatedY, cosTheta, sinTheta;
if ($# < 2 || $# > 3) {
error("rotatePoint: This function requires at least 2 arguments and at most 3 arguments.");
return @;
}
if ($# == 2) {
centre = {0, 0};
}

if (point == @ || theta == @ || centre == @) {
return @;
}

if (!isPoint(point)) {
error("rotatePoint: The first argument must be a Point, not a " // type(point));
return @;
} else if (!isNumber(theta)) {
error("rotatePoint: The second argument must be a number, not a " // type(theta));
return @;
} else if (!isPoint(centre)) {
error("rotatePoint: The centre of enlargement must be a Point, not a " // type(centre));
return @;
} else if (point.x == @ || point.y == @ || centre.x == @ || centre.y == @) {
return @;
}

cosTheta = cos(theta);
sinTheta = sin(-theta);
translatedX = point.x - centre.x;
translatedY = point.y - centre.y;

rotatedX = translatedX * cosTheta - translatedY * sinTheta + centre.x;
rotatedY = translatedX * sinTheta + translatedY * cosTheta + centre.y;
return {rotatedX, rotatedY};
}

func scalePoint {
auto point, scaleX, scaleY, centre, x, y;
if ($# < 2 || $# > 4) {
error("scalePoint: This function requires at least 2 arguments and at most 3 arguments.");
return @;
}
if ($# == 2) {
point = $[1];
scaleX = $[2];
scaleY = $[2];
centre = {0, 0};
} else if ($# == 3) {
point = $[1];
scaleX = $[2];
if (isPoint($[3])) {
scaleY = scaleX;
centre = $[3];
} else {
scaleY = $[3];
centre = {0, 0};
}
}

if (point == @ || scaleX == @ || scaleY == @ || centre == @) {
return @;
}

if (!isPoint(point)) {
error("scalePoint: The first argument must be a Point, not a " // type(point));
return @;
} else if (!isNumber(scaleX)) {
error("scalePoint: The second argument must be a number, not a " // type(scaleX));
return @;
} else if (!isNumber(scaleY)) {
error("scalePoint: The third argument must be a number, not a " // type(scaleY));
return @;
} else if (!isPoint(centre)) {
error("scalePoint: The centre of enlargement must be a Point, not a " // type(centre));
return @;
}

if (point.x == @ || centre.x == @) {
x = @;
} else {
x = (point.x - centre.x) * scaleX + centre.x;
}
if (point.y == @ || centre.y == @) {
y = @;
} else {
y = (point.y - centre.y) * scaleY + centre.y;
}
return {x, y};
}


func include_css {
${{
$("<link/>", {
rel: "stylesheet",
type: "text/css",
href: arguments[0]
}).appendTo("head");
}}$;
};



proc alias {
para aliasN, original;
auto str;
if ($# != 2) {
error("alias: This procedure requires exactly two arguments.");
return;
}

if (isPointer(aliasN)) {
aliasN = nameof(aliasN);
} else if (!isString(aliasN)) {
error("alias: The first argument must be a string or a pointer, not a " // type(aliasN));
return;
}

if (isPointer(original)) {
original = nameof(original);
} else if (!isString(original)) {
error("alias: The second argument must be a string or a pointer, not a " // type(original));
return;
}

str = aliasN // " is " // original // ";\n\n";

str = str // "proc _alias_" // aliasN // " : " // aliasN // " {\n";
str = str // "	if (!isDependency(&" // aliasN // ")) {\n";
str = str // "		" // original // " = " // aliasN // ";\n";
str = str // "		execute(\"" // aliasN // " is " // original // ";\");\n";
str = str // "	} else if (definitionRHS(&" // aliasN // ") != \"" // original // "\") {\n";
str = str // "		forget(\"_alias_" // aliasN // "\");\n";
str = str // "		if (!isDependent(&" // aliasN // ", \"" // original // "\")) {\n";
str = str // "			alias(\"" // original // "\", \"" // aliasN // "\");\n";
str = str // "		}\n";
str = str // "	}\n";
str = str // "}\n";
execute(str);
}

func definitionOf {
${{
if (arguments.length != 1) {
eden.error(new Error("definitionOf: This function requires exactly 1 argument."), "error");
return undefined;
}

var observable = arguments[0];
var name, symbol
if (observable === undefined) {
return undefined;
} else if (observable instanceof Symbol) {
symbol = observable;
name = symbol.name.slice(1);
} else if (typeof(observable) == "string") {
name = observable;
symbol = root.lookup(name);
} else {
eden.error(new Error("definitionOf: The argument must be a pointer or a string, not a " + typeof(observable)), "error");
return undefined;
}

if (symbol.eden_definition !== undefined && symbol.definition !== undefined) {
return symbol.eden_definition + ";";
} else {
return name + " = " + Eden.edenCodeForValue(symbol.cache.value) + ";";
}
}}$;
}

func definitionRHS {
${{
if (arguments.length != 1) {
eden.error(new Error("definitionRHS: This function requires exactly 1 argument."), "error");
return undefined;
}

var observable = arguments[0];
var name, symbol
if (observable === undefined) {
return undefined;
} else if (observable instanceof Symbol) {
symbol = observable;
name = symbol.name.slice(1);
} else if (typeof(observable) == "string") {
name = observable;
symbol = root.lookup(name);
} else {
eden.error(new Error("definitionRHS: The argument must be a pointer or a string, not a " + typeof(observable)), "error");
return undefined;
}

if (symbol.eden_definition !== undefined && symbol.definition !== undefined) {
var lhsRegExp = new RegExp("^\\s*" + name + "\\s+is\\s+", "");
var rhs = symbol.eden_definition.replace(lhsRegExp, "");
rhs = rhs.replace(/^\[\s*\]/, "[]");
rhs = rhs.replace(/\[\s*\]$/, "[]");
return rhs;
} else {
return Eden.edenCodeForValue(symbol.cache.value);
}
}}$;
}

func isDependent {
${{
if (arguments.length != 2) {
eden.error(new Error("isDependent: This function requires exactly 2 arguments."), "error");
return undefined;
}

var searchName, symbol;

if (typeof(arguments[0]) == "string") {
symbol = root.lookup(arguments[0]);
} else if (arguments[0] instanceof Symbol) {
symbol = arguments[0];
} else {
eden.error(new Error("isDependent: The first argument must be a string or a pointer, not a " + typeof(arguments[0])), "error");
return undefined;
}

if (typeof(arguments[1]) == "string") {
searchName = "/" + arguments[1];
} else if (arguments[1] instanceof Symbol) {
searchName = arguments[1].name;
} else {
eden.error(new Error("isDependent: The second argument must be a string or a pointer, not a " + typeof(arguments[1])), "error");
return undefined;
}

return symbol.isDependentOn(searchName);
}}$;
}

func edenCode {
${{
if (arguments.length != 1) {
eden.error(new Error("edenCode: This function requires exactly 1 argument."), "error");
return undefined;
} else {
return Eden.edenCodeForValue(arguments[0]);
}
}}$;
}

func isDependency {
${{
if (arguments.length != 1) {
eden.error(new Error("isDependency: This function requires exactly 1 argument."), "error");
return undefined;
}

var symbol;

if (typeof(arguments[0]) == "string") {
symbol = root.lookup(arguments[0]);
} else if (arguments[0] instanceof Symbol) {
symbol = arguments[0];
} else {
eden.error(new Error("isDependency: The argument must be a string or a pointer, not a " + typeof(arguments[0])), "error");
return undefined;
}

return symbol.eden_definition !== undefined && symbol.definition !== undefined;
}}$;
}

proc patch {
${{
if (arguments.length != 2) {
eden.error(new Error("patch: This procedure requires exactly 2 arguments.", "error"));
return;
}
if (!(arguments[0] instanceof Symbol)) {
eden.error(new Error("patch: The first argument must be a pointer to a func or a proc, not a " + typeof(arguments[0])), "error");
return;
}
if (!(arguments[1] instanceof Symbol)) {
eden.error(new Error("patch: The second argument must be a pointer to a func or a proc, not a " + typeof(arguments[1])), "error");
return;
}

var funcName = arguments[1].name.slice(1);
var patchName = arguments[0].name.slice(1);

var patchFunc = arguments[0].value();
var originalFunc = arguments[1].value();

if (typeof(patchFunc) != "function") {
eden.error(new Error("patch: The first argument must be a pointer to a func or a proc, not a pointer to a " + typeof(patchFunc)), "error");
return;
}
if (typeof(originalFunc) != "function") {
eden.error(new Error("patch: The second argument must be a pointer to a func or a proc, not a pointer to a " + typeof(originalFunc)), "error");
return;
}

root.lookup(funcName).assign(function () {
return patchFunc(originalFunc, Array.prototype.slice.call(arguments));
}, root.scope, this);

arguments[0].forget();
}}$;
}

proc withAppendedItem {
para target, appendItem;
auto listObs, oldRHS, currentValue, last2Chars;

if ($# != 2) {
error("withAppendedItems: This procedure requires at exactly 2 arguments.");
return @;
} else if (isString(target)) {
oldRHS = definitionRHS(target);
listObs = target;
currentValue = `listObs`;
} else if (isPointer(target)) {
oldRHS = definitionRHS(target);
listObs = nameof(target);
currentValue = *(target);
} else {
error("withAppendedItem: The first argument must be a string or a pointer, not a " // type(target));
return @;
}

if (currentValue != @ && !isList(currentValue)) {
error("withAppendedItem: " // listObs // " must be a list type observable, not a " // type(currentValue) // " observable.");
return @;
}

if (!isString(appendItem)) {
error("withAppendedItem: The second argument must be a string, not a " // type(appendItem) // ".  Place the expression inside quotes (ordinarily), or use edenCode() to append a fixed value.");
return @;
}

if (oldRHS# >= 2) {
last2Chars = substr(oldRHS, oldRHS# - 1, oldRHS#);
} else {
last2Chars = @;
}

if (oldRHS == "@" || oldRHS == "[]") {
execute(listObs // " is [" // appendItem // "];");
} else if (last2Chars != @ && last2Chars[2] == "]" && last2Chars[1] != "[") {
execute(listObs // " is " // substr(oldRHS, 1, oldRHS# - 1) // ", " // appendItem // "];");
} else {
execute(listObs // " is " // oldRHS // " // [" // appendItem // "];");
}
}



edenclocks = [];
edenclocks_paused = false;
debug.edenclocks = false;

${{
root.edenclocks = {};
var edenclocks = root.lookup("edenclocks");
edenclocks.addJSObserver("setClocks", function (symbol, clocks) {
var newClockNames = {};
var debugSym = root.lookup("debug");
var debug = debugSym.value().edenclocks;
var pausedSym = root.lookup("edenclocks_paused");

if (Array.isArray(clocks)) {
var incrementClock = function (symbol) {
if (!pausedSym.cache.value) {
symbol.assign(symbol.cache.value + 1, root.scope, edenclocks);
if (debugSym.cache.value.edenclocks) {
console.log("edenclocks: clock " + symbol.name);
}
}
};
var callClockProc = function (symbol) {
if (!pausedSym.cache.value) {
if (debugSym.cache.value.edenclocks) {
console.log("edenclocks: clock " + symbol.name);
}
symbol.definition(root)();
}
};
var startClock = function (interval, target) {
if (target.eden_definition !== undefined && target.definition !== undefined && /^proc\s/.test(target.eden_definition)) {
return window.setInterval(callClockProc, interval, target);
} else {
var currentValue = target.value();
if (currentValue === undefined) {
target.assign(0, root.scope, edenclocks);
return window.setInterval(incrementClock, interval, target);
} else if (typeof(currentValue) == "number") {
return window.setInterval(incrementClock, interval, target);
} else {
var targetName = target.name.slice(1);
eden.error(new Error("edenclocks: edenclock observable " + targetName + " must be a procedure or have a numeric value assigned, not a " + typeof(currentValue) + ".  Paused edenclock " + targetName), "error");
return undefined;
}
}
};

for (var i = 0; i < clocks.length; i++) {
var clockDetails = clocks[i];
if (Array.isArray(clockDetails)) {
var clockSymbol = clockDetails[0];
if (clockSymbol instanceof Symbol) {
var clockName = clockSymbol.name;
var clockInterval = clockDetails[1];
if (clockInterval !== undefined && typeof(clockInterval) != "number") {
eden.error(new Error("edenclocks: The value assigned to item " + i + " of the edenclocks list must be a list where the second element is a number or undefined, not a " + typeof(clockInterval) + ".  Paused edenclock " + clockName), "error");
clockInterval = undefined;
}
var existingClock = root.edenclocks[clockName];
var timer;
if (existingClock === undefined) {
if (clockInterval === undefined) {
if (debug) {
console.log("edenclocks: new clock " + clockName + ", paused");
}
root.edenclocks[clockName] = {intervalID: undefined, interval: undefined};
} else {
if (debug) {
console.log("edenclocks: new clock " + clockName + ", " + clockInterval + "ms");
}
timer = startClock(clockInterval, clockSymbol);
root.edenclocks[clockName] = {intervalID: timer, interval: clockInterval};
}
} else if (existingClock.intervalID === undefined) {
if (clockInterval !== undefined) {
if (debug) {
console.log("edenclocks: restart clock " + clockName + ", " + clockInterval + "ms");
}
timer = startClock(clockInterval, clockSymbol);
existingClock.intervalID = timer;
existingClock.interval = clockInterval;
}
} else if (clockInterval === undefined) {
window.clearInterval(existingClock.intervalID);
if (debug) {
console.log("edenclocks: pause clock " + clockName);
}
existingClock.intervalID = undefined;
} else if (clockInterval != existingClock.interval) {
window.clearInterval(existingClock.intervalID);
if (debug) {
console.log("edenclocks: change interval " + clockName + ", " + clockInterval + "ms");
}
timer = startClock(clockInterval, clockSymbol);
existingClock.intervalID = timer;
existingClock.interval = clockInterval;
}
newClockNames[clockName] = true;
} else if (clockSymbol !== undefined) {
eden.error(new Error("edenclocks: The value assigned to item " + i + " of the edenclocks list must be a list where the first element is a pointer, not a " + typeof(clockSymbol)), "error");
}
} else if (clockDetails !== undefined) {
eden.error(new Error("edenclocks: The value assigned to item " + i + " of the edenclocks list must be a list, not a " + typeof(clockDetails)), "error");
}
}
} else if (clocks !== undefined) {
eden.error(new Error("edenclocks: The value assigned to edenclocks must be a list, not a " + typeof(clocks)), "error");
}
for (var clockName in root.edenclocks) {
if (!(clockName in newClockNames)) {
var existingClock = root.edenclocks[clockName];
if (existingClock.intervalID !== undefined) {
window.clearInterval(existingClock.intervalID);
if (debug) {
console.log("edenclocks: delete clock " + clockName);
}
existingClock.intervalID = undefined;
}
}
}
});
}}$;

proc setedenclock {
para clockPtr, millis;
auto i;
if ($# != 2) {
error("setedenclock: This procedure requires exactly 2 arguments.");
} else if (!isPointer($[1])) {
error("setedenclock: The first argument must be a pointer, not a " // type($[1]));
} else if ($[2] != @ && !isNumber($[2])) {
error("setedenclock: The second argument must be a number or undefined, not a " // type($[2]));
} else {
if (debug.edenclocks) {
${{ console.log("edenclocks: setedenclock(" + arguments[0].name.slice(1) + ", " + arguments[1] + ")"); }}$;
}
for (i = 1; i <= edenclocks#; i++) {
if (isList(edenclocks[i]) && edenclocks[i][1] == clockPtr) {
edenclocks = sublist(edenclocks, 1, i - 1) // [[clockPtr, millis]] // sublist(edenclocks, i + 1);
return;
}
}
edenclocks = edenclocks // [[clockPtr, millis]];
}
}

proc removeedenclock {
para clockPtr;
auto i;
if ($# != 1) {
error("removeedenclock: This procedure requires exactly 1 argument.");
} else if (!isPointer($[1])) {
error("removeedenclock: The argument must be a pointer, not a " // type($[1]));
} else {
if (debug.edenclocks) {
${{ console.log("edenclocks: removeedenclock(" + arguments[0].name.slice(1) + ")"); }}$;
}
for (i = 1; i <= edenclocks#; i++) {
if (isList(edenclocks[i]) && edenclocks[i][1] == clockPtr) {
edenclocks = sublist(edenclocks, 1, i - 1) // sublist(edenclocks, i + 1);
return;
}
}
}
}


func htmlBulletList {
auto items, item, result, i;
if ($# == 1 && isList($[1])) {
items = $[1];
} else {
items = $;
}

if (items# == 0) {
return "";
}

result = "<ul>";

for (i = 1; i <= items#; i++) {
item = items[i];
if (item == @) {
item = "<span style=\"color: red\">undefined</style>";
} else {
item = str(item);
}
result = result // "<li style=\"margin-bottom: 7pt\">" // item // "</li>\n";
}

result = result // "</ul>\n";
return result;
}

func htmlNumberedList {
auto items, item, result, i, numberingType, start;
if ($# == 0) {
return "";
} else if ($# <= 3 && $[$#] == @) {
return "";
} else if ($# <= 3 && isList($[$#])) {
items = $[$#];
if (isString($[1])) {
numberingType = $[1];
if ($# == 3) {
if (isInt($[2])) {
start = $[2];
} else if ($[2] == @) {
numberingType = "symbols(\"?\")";
} else {
error("htmlNumberedList: The second argument must be an integer, not a " // type($[2]));
return "";
}
}
} else if (isInt($[1]) && $# == 2) {
start = $[1];
} else if ($[1] == @) {
numberingType = "symbols(\"?\")";
} else if ($# > 1) {
error("htmlNumberedList: The first argument must be a string or an integer, not a " // type($[1]));
return "";
}
} else {
if ($# >= 2 && (isString($[1]) || $[1] == @) && (isInt($[2]) || $[2] == @)) {
numberingType = $[1];
start = $[2];
items = sublist($, 3);
} else if ($# >= 1 && (isInt($[1]) || $[1] == @)) {
start = $[1];
items = sublist($, 2);
} else {
items = $;
}
}

if (items# == 0) {
return "";
}

result = "<ol";
if (start != @) {
result = result // " start=\"" // str(start) // "\"";
}
if (numberingType =~ "^[1aAiI]$") {
result = result // " type=\"" // numberingType // "\"";
} else if (numberingType != @) {
result = result // " style='list-style-type: " // numberingType // "'";
}
result = result + ">\n";

for (i = 1; i <= items#; i++) {
item = items[i];
if (item == @) {
item = "<span style=\"color: red\">undefined</style>";
} else {
item = str(item);
}
result = result // "<li style=\"margin-bottom: 7pt\">" // item // "</li>\n";
}

result = result // "</ol>\n";
return result;
}

func rgb2colour {
auto r, g, b, a;
if ($# < 3 || $# > 4) {
error("rgb: This function requires at least 3 arguments and at most 4 arguments.");
return "black";
}

r = $[1]; g = $[2]; b = $[3]; a = @;

if (r == @) {
r = 0;
} else if (!isNumber(r)) {
error("rgb: The first argument must be a number, not a " // type(r));
return "black";
} else {
r = round(r);
}

if (g == @) {
g = 0;
} else if (!isNumber(g)) {
error("rgb: The second argument must be a number, not a " // type(g));
return "black";
} else {
g = round(g);
}

if (b == @) {
b = 0;
} else if (!isNumber(b)) {
error("rgb: The third argument must be a number, not a " // type(b));
return "black";
} else {
b = round(b);
}

if ($# == 4) {
a = $[4];
if (isNumber(a)) {
if (a < 0) {
a = 0;
} else if (a > 1) {
a = 1;
}
} else if (a != @) {
error("rgb: The forth argument must be a number, not a " // type(a));
return "black";
}
}

if (a == @) {
return "rgb(" // str(r) // "," // str(g) // "," // str(b) // ")";
} else {
return "rgba(" // str(r) // "," // str(g) // "," // str(b) // "," // str(a) // ")";
}
}

func hsl2colour {
auto h, s, l, a;
if ($# < 3 || $# > 4) {
error("hsl: This function requires at least 3 arguments and at most 4 arguments.");
return "black";
}

h = $[1]; s = $[2]; l = $[3]; a = @;

if (h == @) {
h = 0;
} else if (!isNumber(h)) {
error("hsl: The first argument must be a number, not a " // type(h));
return "black";
} else if (h < 0) {
h = 0;
} else if (h > 360) {
h = 360;
}

if (s == @) {
s = 0;
} else if (!isNumber(s)) {
error("hsl: The second argument must be a number, not a " // type(s));
return "black";
} else if (s < 0) {
s = 0;
} else if (s > 100) {
s = 100;
}

if (l == @) {
l = 0;
} else if (!isNumber(l)) {
error("hsl: The third argument must be a number, not a " // type(l));
return "black";
} else if (l < 0) {
l = 0;
} else if (l > 100) {
l = 100;
}

if ($# == 4) {
a = $[4];
if (isNumber(a)) {
if (a < 0) {
a = 0;
} else if (a > 1) {
a = 1;
}
} else if (a != @) {
error("hsl: The forth argument must be a number, not a " // type(a));
return "black";
}
}

if (a == @) {
return "hsl(" // str(h) // "," // str(s) // "%," // str(l) // "%)";
} else {
return "hsla(" // str(h) // "," // str(s) // "%," // str(l) // "%," // str(a) // ")";
}
}

proc bindCSSProperty {
${{
var scope, selector, property, obsName;

if (arguments.length == 3) {
scope = undefined;
selector = arguments[0];
property = arguments[1];
obsName = arguments[2];
} else if (arguments.length == 4) {
scope = arguments[0];
selector = arguments[1];
property = arguments[2];
obsName = arguments[3];
} else {
eden.error(new Error("bindCSSProperty: This procedure requires a minimum of 3 arguments and a maximum of 4 arguments."), "error");
return;
}

if (typeof(property) != "string") {
eden.error(new Error("bindCSSProperty: The CSS property name must be a string, not a " + typeof(property)), "error");
return;
}
if (obsName instanceof Symbol) {
obsName = obsName.name.slice(1);
} else if (typeof(obsName) != "string") {
eden.error(new Error("bindCSSProperty: The observable reference must be a string or a pointer, not a " + typeof(obsName)), "error");
return;
}

var stylesheetID = "css-dependencies-" + selector.replace(/\s+/g, "$$") + "$$" + property;

selector = putCSSSelectorIntoScope(scope, selector);
if (selector === undefined) {
//Disallowed or invalid selector.
return;
}

var stylesheet;
var styleElement = document.getElementById(stylesheetID);
if (styleElement === null) {
styleElement = document.createElement("style");
styleElement.id = stylesheetID;
var headElement = document.getElementsByTagName("head")[0];
headElement.appendChild(styleElement);
stylesheet = styleElement.sheet;
stylesheet.insertRule(selector + "{ }", 0);
} else {
stylesheet = styleElement.sheet;
}

var cssDeclarations = stylesheet.cssRules[0].style;
var updateFunction = function (obs, value) {
if (value === undefined) {
cssDeclarations.cssText = "";
} else {
cssDeclarations.cssText = property + ": " + value + ";";
}
};
var obsSym = root.lookup(obsName);
updateFunction("/" + obsName, obsSym.value());
obsSym.addJSObserver("bind", updateFunction);
}}$;
}

proc bindCSSNumericProperty {
${{
var scope, selector, property, obsName, units;

if (arguments.length == 4) {
scope = undefined;
selector = arguments[0];
property = arguments[1];
obsName = arguments[2];
units = arguments[3];
} else if (arguments.length == 5) {
scope = arguments[0];
selector = arguments[1];
property = arguments[2];
obsName = arguments[3];
units = arguments[4];
} else {
eden.error(new Error("bindCSSNumericProperty: This procedure requires a minimum of 4 arguments and a maximum of 5 arguments."), "error");
return;
}

if (typeof(property) != "string") {
eden.error(new Error("bindCSSNumericProperty: The CSS property name must be a string, not a " + typeof(property)), "error");
return;
}
if (obsName instanceof Symbol) {
obsName = obsName.name.slice(1);
} else if (typeof(obsName) != "string") {
eden.error(new Error("bindCSSNumericProperty: The observable reference must be a string or a pointer, not a " + typeof(obsName)), "error");
return;
}
if (typeof(units) != "string") {
eden.error(new Error("bindCSSNumericProperty: The unit name must be a string, not a " + typeof(units)), "error");
return;
}


var stylesheetID = "css-dependencies-" + selector.replace(/\s+/g, "$$") + "$$" + property;

selector = putCSSSelectorIntoScope(scope, selector);
if (selector === undefined) {
//Disallowed or invalid selector.
return;
}

var stylesheet;
var styleElement = document.getElementById(stylesheetID);
if (styleElement === null) {
styleElement = document.createElement("style");
styleElement.id = stylesheetID;
var headElement = document.getElementsByTagName("head")[0];
headElement.appendChild(styleElement);
stylesheet = styleElement.sheet;
stylesheet.insertRule(selector + "{ }", 0);
} else {
stylesheet = styleElement.sheet;
}

var cssDeclarations = stylesheet.cssRules[0].style;
var updateFunction = function (obs, value) {
if (value === undefined) {
cssDeclarations.cssText = "";
} else if (/[+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?/.test(value)) {
cssDeclarations.cssText = property + ": " + value + units + ";";
} else {
//values like auto and inherit
cssDeclarations.cssText = property + ": " + value + ";";
}
};
var obsSym = root.lookup(obsName);
updateFunction("/" + obsName, obsSym.value());
obsSym.addJSObserver("bind", updateFunction);
}}$;
}

proc bindCSSRule {
${{
var scope, selector, obsName;

if (arguments.length == 2) {
scope = undefined;
selector = arguments[0];
obsName = arguments[1];
} else if (arguments.length == 3) {
scope = arguments[0];
selector = arguments[1];
obsName = arguments[2];
} else {
eden.error(new Error("bindCSSRule: This procedure requires a minimum of 2 arguments and a maximum of 3 arguments."), "error");
return;
}

if (obsName instanceof Symbol) {
obsName = obsName.name.slice(1);
} else if (typeof(obsName) != "string") {
eden.error(new Error("bindCSSRule: The observable reference must be a string or a pointer, not a " + typeof(obsName)), "error");
return;
}

var stylesheetID = "css-dependencies-" + selector.replace(/\s+/g, "$$");

selector = putCSSSelectorIntoScope(scope, selector);
if (selector === undefined) {
//Disallowed or invalid selector.
return;
}

var stylesheet;
var styleElement = document.getElementById(stylesheetID);
if (styleElement === null) {
styleElement = document.createElement("style");
styleElement.id = stylesheetID;
var headElement = document.getElementsByTagName("head")[0];
headElement.appendChild(styleElement);
stylesheet = styleElement.sheet;
stylesheet.insertRule(selector + "{ }", 0);
} else {
stylesheet = styleElement.sheet;
}

var cssDeclarations = stylesheet.cssRules[0].style;
var updateFunction = function (obs, value) {
if (value === undefined) {
cssDeclarations.cssText = "";
} else if (typeof(value) == "object") {
var capital = /([A-Z])/g;
var jsSyntax = /^\w*[A-Z]\w*$/;
var declarations = "";
for (var key in value) {
if (typeof(value[key]) == "string") {
var property;
if (jsSyntax.test(key)) {
property = key.replace(capital, function (match, capitalLetter) {
return "-" + capitalLetter.toLowerCase();
});
} else {
property = key;
}
declarations = declarations + property + ": " + value[key] + ";\n";
}
}
cssDeclarations.cssText = declarations;
} else {
cssDeclarations.cssText = value;
}
};
var obsSym = root.lookup(obsName);
updateFunction("/" + obsName, obsSym.value());
obsSym.addJSObserver("bind", updateFunction);
}}$;
}

proc unbind {
${{
if (arguments.length != 1) {
eden.error(new Error("unbind: This procedure requires exactly 1 argument."), "error");
return;
}
var obsSym;
if (arguments[0] instanceof Symbol) {
obsSym = arguments[0];
} else if (typeof(arguments[0]) == "string") {
obsSym = root.lookup(arguments[0]);
} else {
eden.error(new Error("unbind: The argument must be a string or a pointer, not a " + typeof(arguments[0])), "error");
return;
}
obsSym.removeJSObserver("bind");
}}$;
}

${{
putCSSSelectorIntoScope = function (scope, selector) {
var scopeSpecified;
if (scope === undefined) {
scopeSpecified = false;
} else if (typeof(scope) != "string") {
eden.error(new Error("Scope for CSS modifications must be a string, not a " + typeof(scope)), "error");
return undefined;
} else {
scopeSpecified = !(/^\s*$/.test(scope));
}

if (typeof(selector) != "string") {
eden.error(new Error("CSS selector must be a string, not a " + typeof(selector)), "error");
return undefined;
}

var regExp = /^\s*(([^",]|("[^"]*"))+)(,|$)/g
var match, individualSelector;
var selectors = [];
var authoringMode = (root.lookup("_authoringMode").value() == "tool development");

while ((match = regExp.exec(selector)) !== null) {
individualSelector = match[1];
if (/^((:not\(([^"]|("[^"]*"))*\))|[^":.#]|(\:[^n])|("[^"]*"))*[.#]/.test(individualSelector)) {
selectors.push(individualSelector);
} else if (scopeSpecified) {
selectors.push("#" + scope + " " + individualSelector);
} else if (authoringMode) {
selectors.push(individualSelector);
} else {
eden.error(new Error("Cannot alter CSS globally for selector " + individualSelector +
" when not in tool authoring mode.  Please specify a scope in which to restrict the changes."),
"error");
return undefined;
}
}

if (selectors.length == 0) {
if (scopeSpecified && selector == "") {
return "#" + scope;
} else {
eden.error(new Error("Invalid CSS selector specified."), "error");
return undefined;
}
} else {
return selectors.join(", ");
}
}
}}$;



${{

declare_jse = function(p1, p2, p3) {
var object = this;
var nameJ = "";
var nameJSE = "";
if (typeof(p1) == "string") {
if (p2 === undefined) {
nameJ = p1;
nameJSE = p1;
} else {
nameJ = p1;
nameJSE = p2;
}
} else {
if (p3 === undefined) {
object = p1;
nameJ = p2;
nameJSE = p2;
} else {
object = p1;
nameJ  = p2;
nameJSE = p3;
}
}

object.__defineGetter__(nameJ, function() {
return root.lookup(nameJSE).value();
});

object.__defineSetter__(nameJ, function(val) {
root.lookup(nameJSE).assign(val, root.scope, {name: "declare_jse"});
});
}

}}$;



${{
function _keys(obj) {
if (Object.keys) {
return Object.keys.apply(this, arguments);
}

var result = [];
var p;
for (p in obj) {
if (obj.hasOwnProperty(p)) {
result.push(p);
}
}
return result;
}

root.lookup("generate_function").assignFunction(function generate(name, outputSym, inputs) {
//TODO How to handle dynamic dependencies (backticks)?
var inputSet = {};
for (var i = 0; i < inputs.length; ++i) {
inputSet[inputs[i]] = true;
}

var output = outputSym.name.slice(1);
var todo = [outputSym.name];
var next;
var nextSym;
var ordered = [];
var defParts;
var deps;
while (todo.length) {
next = todo.pop().slice(1);
if (inputSet[next]) {
continue;
}
nextSym = root.lookup(next);
ordered.unshift(next);
deps = _keys(nextSym.dependencies);
todo.unshift.apply(todo, deps);
}

var i;
var statements = [];
var autos = {};
for (i = 0; i < ordered.length; ++i) {
next = ordered[i];
if (autos[next]) {
console.log('skipping', next);
continue;
}
console.log('visiting', next);
autos[next] = true;
nextSym = root.lookup(next);
defParts = nextSym.eden_definition.match(/\S+\s+is\s+(.*)/);
console.log(defParts);
statements.push(next+' = '+defParts[1]);
}
var autoKeys = _keys(autos);

return 'func '+name+' {\n'+
(!inputs.length ? '' : 'para '+inputs.join(', ')+';')+'\n'+
(!autoKeys.length ? '' : 'auto '+autoKeys.join(', ')+';')+'\n'+
statements.join(";\n")+';\n'+
'return '+output+';\n'+
'}';
}, {name: "/include"});
}}$;


include2("library/scoping.js-e");

initialViews = ${{getParameterByName("views") }}$;
if (initialViews == "" || initialViews == "default") {
createView("projects", "ProjectList");
_view_projects_x = 0;
_view_projects_y = 0;
_view_projects_width = 210;
_view_projects_height = screenHeight;
createCanvas("picture", "Canvas Picture");
_view_picture_x = _view_projects_width + _views_frame_width;
_view_picture_y = 0;
if (${{ "logo" in edenUI.branding }}$) {
picture is [Image(_view_picture_width / 2 - ${{edenUI.branding.logo.width}}$ / 2, _view_picture_height / 2 - ${{edenUI.branding.logo.height}}$ / 2, ${{edenUI.branding.logo.url}}$)];
}
createView("input", "ScriptInput");
if (${{edenUI.getOptionValue("developer") == "true" }}$) {
_view_input_x = _view_picture_x + _view_picture_width + _views_frame_width;
_view_input_y = 0;
} else {
_view_input_x = _view_picture_x;
_view_input_width = _view_picture_width;
_view_picture_height = min(_view_picture_height, screenHeight - (180 + 2 * _views_frame_height));
_view_input_y = _view_picture_height + _views_frame_height;
_view_input_height = max(180, screenHeight - _view_input_y - _views_frame_height);
}
}
forget(&initialViews);

