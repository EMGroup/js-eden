## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

PI = ${{ Math.PI }}$;
radiansPerUnit is PI / 180;

func abs {
  return ${{ Math.abs(arguments[0]); }}$;
}

func acos {
  return ${{ Math.acos(arguments[0]) }}$ / radiansPerUnit;
}

func asin {
  return ${{ Math.asin(arguments[0]) }}$ / radiansPerUnit;
}

func atan {
  return ${{ Math.atan(arguments[0]) }}$ / radiansPerUnit;
}

func ceil {
	${{
		if (arguments.length < 1 || arguments.length > 2) {
			eden.error(new Error("ceil: This function requires at least 1 argument and at most 2 arguments."), "error");
			return undefined;
		}
		
		var number = arguments[0];
		if (number === undefined) {
			return undefined;
		} else if (typeof(number) != "number") {
			eden.error(new Error("ceil: The first argument must be a number, not a " + typeof(number)), "error");
			return undefined;
		}

		var multiple;
		if (arguments.length == 2) {
			multiple = arguments[1];
			if (multiple === undefined) {
				return undefined;
			} else if (typeof(multiple) != "number") {
				eden.error(new Error("ceil: The second argument must be a number, not a " + typeof(multiple)), "error");
				return undefined;
			}
		} else {
			multiple = 1;
		}
		
		if (multiple === 1) {
			return Math.ceil(number);		
		} else {
			var divided = number / multiple;
			var truncated = parseInt(divided);
			if (divided == truncated) {
				return number;
			} else {
				return (truncated + 1) * multiple;
			}
		}
	}}$;
}

roundUp is ceil;

func cos {
  return ${{ Math.cos(arguments[0]*root.lookup("radiansPerUnit").value()); }}$;
}

func exp {
  return ${{ Math.exp(arguments[0]); }}$;
}

func floor {
	${{
		if (arguments.length < 1 || arguments.length > 2) {
			eden.error(new Error("floor: This function requires at least 1 argument and at most 2 arguments."), "error");
			return undefined;
		}
		
		var number = arguments[0];
		if (number === undefined) {
			return undefined;
		} else if (typeof(number) != "number") {
			eden.error(new Error("floor: The first argument must be a number, not a " + typeof(number)), "error");
			return undefined;
		}

		var multiple;
		if (arguments.length == 2) {
			multiple = arguments[1];
			if (multiple === undefined) {
				return undefined;
			} else if (typeof(multiple) != "number") {
				eden.error(new Error("floor: The second argument must be a number, not a " + typeof(multiple)), "error");
				return undefined;
			}
		} else {
			multiple = 1;
		}
		
		if (multiple === 1) {
			return Math.floor(number);
		} else {
			return parseInt(number / multiple) * multiple;
		}
	}}$;
}

roundDown is floor;

func ln {
  return ${{ Math.log(arguments[0]); }}$;
}

func log {
	${{
		var number = arguments[0];
		var base;
		if (arguments.length == 1) {
			base = 10;
		} else if (arguments.length != 2) {
			eden.error(new Error("log: The function requires at least one argument and at most two arguments."), "error");
			return undefined;
		} else {
			base = arguments[1];
		}

		if (number === undefined || base === undefined) {
			return undefined;
		} else if (typeof(number) != "number") {
			eden.error(new Error("log: The first argument must be a number, not a " + typeof(number)), "error");
		} else if (typeof(base) != "number") {
			eden.error(new Error("log: The second argument must be a number, not a " + typeof(base)), "error");
		}

		return Math.log(number) / Math.log(base);
	}}$;
}

##The same remarks apply as for min, mutatis mutandis.
func max {
	auto list, i, maxSoFar;

	if ($# == 0) {
		return @;
	} else if ($# == 1 && type($[1]) == "list") {
		list = $[1];
		if (list# == 0) {
			return @;
		}
	} else {
		list = $;
	}

	maxSoFar = list[1];	
	for (i = 2; i <= list#; i++) {
		if (list[i] > maxSoFar) {
			maxSoFar = list[i];
		}
	}
	return maxSoFar;
}

##If exactly one argument is provided and it is the empty list then undefined
##is returned.  tkeden produces an error message.
##
##If two or more list type arguments are provided then they are compared
##lexicographically, e.g. min([2], [1,2]) is [1,2].  tkeden returns the lowest
##value from the first list in this scenario.  If exactly one argument is
##provided and it is a list then the lowest value from that list is returned,
##the same as in tkeden.
##
##min(@, 2) returns @ but min(2, @) returns 2.  This is bizarre but consistent
##with tkeden.
##
func min {
	auto list, i, minSoFar;

	if ($# == 0) {
		return @;
	} else if ($# == 1 && type($[1]) == "list") {
		list = $[1];
		if (list# == 0) {
			return @;
		}
	} else {
		list = $;
	}
	
	minSoFar = list[1];

	for (i = 2; i <= list#; i++) {
		if (list[i] < minSoFar) {
			minSoFar = list[i];
		}
	}
	return minSoFar;
}

func mod {
	para x, n;
	return x>=0? x % n : (n + (x % n));
}

func randomBoolean {
	para probability;
	if (probability == @) {
		probability = 0.5;
	}
	return random() <= probability;
}

func randomInteger {
	${{
		if (arguments.length != 2) {
			eden.error(new Error("randomInteger: This function requires exactly 2 arguments"), "error");
			return undefined;
		}
		
		var lowerBound = arguments[0];
		var upperBound = arguments[1];

		if (lowerBound === undefined || upperBound === undefined) {
			return undefined;
		} else if (typeof(lowerBound) != "number") {
			eden.error(new Error("randomInteger: The lower bound must be an int, not a " + typeof(lowerBound)), "error");
			return undefined;
		} else if (isNaN(lowerBound)) {
			return undefined;
		} else if (!Number.isInteger(lowerBound)) {
			eden.error(new Error("randomInteger: The lower bound must be an int, not a float."), "error");
			return undefined;
		} else if (typeof(upperBound) != "number") {
			eden.error(new Error("randomInteger: The upper bound must be an int, not a " + typeof(upperBound)), "error");
			return undefined;
		} else if (isNaN(upperBound)) {
			return undefined;
		} else if (!Number.isInteger(upperBound)) {
			eden.error(new Error("randomInteger: The upper bound must be an int, not a float."), "error");
			return undefined;
		}
		
		var n = Math.floor(root.lookup("random").definition(root)() * (upperBound - lowerBound + 1) + lowerBound);
		if (n > upperBound) {
			// 1 / 2^62 chance
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
			n = upperBound;
		}
		return n;
	}}$;
}

func randomFloat {
	${{
		if (arguments.length != 2) {
			eden.error(new Error("randomFloat: This function requires exactly 2 arguments"), "error");
			return undefined;
		}

		var lowerBound = arguments[0];
		var upperBound = arguments[1];

		if (lowerBound === undefined || upperBound === undefined) {
			return undefined;
		} else if (typeof(lowerBound) != "number") {
			eden.error(new Error("randomFloat: The lower bound must be a float, not a " + typeof(lowerBound)), "error");
			return undefined;
		} else if (isNaN(lowerBound)) {
			return undefined;
		} else if (typeof(upperBound) != "number") {
			eden.error(new Error("randomFloat: The upper bound must be a float, not a " + typeof(upperBound)), "error");
			return undefined;
		} else if (isNaN(upperBound)) {
			return undefined;
		}

		var n = root.lookup("random").definition(root)() * (upperBound - lowerBound + 1) + lowerBound;
		if (n > upperBound) {
			n = upperBound;
		}
		return n;
	}}$;
}

${{
	xorshift32Random = function (state) {
		state ^= state << 13;
		state ^= state >>> 17;
		state ^= state << 5;
		return state;
	}
}}$;

func xorshiftRandomGenerator {
	${{
		var stateSym = root.lookup("randomGeneratorState");
		var lower = xorshift32Random(stateSym.value());
		var upper = xorshift32Random(lower);
		stateSym.assign(upper, root.lookup("xorshiftRandomGenerator"));
		upper = Math.abs(upper) * 4194304; // 2^22, 53 bits of precision in total
		return (upper + Math.abs(lower)) / 9007199254740991; // 2^53 - 1
	}}$;
}

randomSeed = @;
randomGenerator is xorshiftRandomGenerator;

${{
	root.lookup("randomSeed").addJSObserver("applySeed", function (obs, seed) {
		root.lookup("randomGeneratorState").assign(seed, obs);
		root.lookup("randomIndex").assign(0, obs);
	});

	root.lookup("randomGenerator").addJSObserver("applySeed", function (obs, generator) {
		root.lookup("randomGeneratorState").assign(root.lookup("randomSeed").value(), obs);		
		root.lookup("randomIndex").assign(0, obs);
	});	
}}$;
	
func random {
	randomIndex++;
	if (randomSeed == @) {
		return ${{ Math.random(); }}$;
	} else {
		return randomGenerator();
	}
}

func round {
	${{
		if (arguments.length == 0 || arguments.length > 2) {
			eden.error(new Error("round: This function requires at least 1 argument and at most 2 arguments."), "error");
			return undefined;
		}
		
		var number = arguments[0];
		if (number === undefined) {
			return undefined;
		} else if (typeof(number) != "number") {
			eden.error(new Error("round: The first argument must be a number, not a " + typeof(number)), "error");
			return undefined;
		}

		var decimalPlaces;
		if (arguments.length == 2) {
			decimalPlaces = arguments[1];
		} else {
			decimalPlaces = 0;
		}
		
		if (decimalPlaces === 0) {
			return Math.round(number);
		} else if (decimalPlaces === undefined) {
			return undefined;
		} else if (typeof(decimalPlaces) != "number") {
			eden.error(new Error("round: The second argument must be an int, not a " + typeof(decimalPlaces)), "error");
			return undefined;
		} else if (!Number.isInteger(decimalPlaces)) {
			eden.error(new Error("round: The second argument must be an int, not a float"), "error");
			return undefined;
		} else {
			var multiplier = Math.pow(10, decimalPlaces);
			return Math.round(number * multiplier) / multiplier;
		}
	}}$;
}

func sin {
  return ${{ Math.sin(arguments[0]*root.lookup("radiansPerUnit").value()); }}$;
}

func sqrt {
  return ${{ Math.sqrt(arguments[0]); }}$;
}

func sum {
	${{
		var list, total, type;
		if (arguments.length == 1 && Array.isArray(arguments[0])) {
			list = arguments[0];
		} else {
			list = arguments;
		}

		total = 0;
		for (var i = 0; i < list.length; i++) {
			type = typeof(list[i]);
			if (type === undefined) {
				return undefined;
			} else if (type == "number" || type == "boolean") {
				total = total + list[i];
			} else {
				eden.error(new Error("sum: Item " + i + " must be a number, not a " + type));
				return undefined;
			}
		}
		return total;
	}}$;
}

func tan {
  return ${{ Math.tan(arguments[0]*root.lookup("radiansPerUnit").value()); }}$;
}

