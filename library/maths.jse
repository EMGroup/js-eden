## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

func abs {
  return ${{ Math.abs(arguments[0]); }}$;
}

func acos {
  return ${{ Math.acos(arguments[0])*180/Math.PI; }}$;
}

func asin {
  return ${{ Math.asin(arguments[0])*180/Math.PI; }}$;
}

func atan {
  return ${{ Math.atan(arguments[0])*180/Math.PI; }}$;
}

func ceil {
  return ${{ Math.ceil(arguments[0]); }}$;
}

func cos {
  return ${{ Math.cos(arguments[0]*Math.PI/180); }}$;
}

func exp {
  return ${{ Math.exp(arguments[0]); }}$;
}

func floor {
  return ${{ Math.floor(arguments[0]); }}$;
}

func log {
  return ${{ Math.log(arguments[0]); }}$;
}

##If exactly one argument is provided and it is the empty list then undefined
##is returned.  tkeden produces an error message.
##
##If two or more list type arguments are provided then they are compared
##lexicographically, e.g. min([2], [1,2]) is [1,2].  tkeden returns the lowest
##value from the first list in this scenario.  If exactly one argument is
##provided and it is a list then the lowest value from that list is returned,
##the same as in tkeden.
##
##min(@, 2) returns @ but min(2, @) returns 2.  This is bizarre but consistent
##with tkeden.
##
func min {
	auto list, i, minSoFar;

	if ($# == 0) {
		return @;
	} else if ($# == 1 && type($[1]) == "list") {
		list = $[1];
		if (list# == 0) {
			return @;
		}
	} else {
		list = $;
	}
	
	minSoFar = list[1];

	for (i = 2; i <= list#; i++) {
		if (list[i] < minSoFar) {
			minSoFar = list[i];
		}
	}
	return minSoFar;
}

##The same remarks apply as for min, mutatis mutandis.
func max {
	auto list, i, maxSoFar;

	if ($# == 0) {
		return @;
	} else if ($# == 1 && type($[1]) == "list") {
		list = $[1];
		if (list# == 0) {
			return @;
		}
	} else {
		list = $;
	}

	maxSoFar = list[1];	
	for (i = 2; i <= list#; i++) {
		if (list[i] > maxSoFar) {
			maxSoFar = list[i];
		}
	}
	return maxSoFar;
}

func pow {
  return ${{ Math.pow(arguments[0],arguments[1]); }}$;
}

func randomInteger {
	${{
		if (arguments.length != 2) {
			eden.error(new Error("randomInteger: This function requires exactly 2 arguments"), "error");
			return undefined;
		}
		
		var lowerBound = arguments[0];
		var upperBound = arguments[1];

		if (lowerBound === undefined || upperBound === undefined) {
			return undefined;
		} else if (typeof(lowerBound) != "number") {
			eden.error(new Error("randomInteger: The lower bound must be an int, not a " + typeof(lowerBound)), "error");
			return undefined;
		} else if (isNaN(lowerBound)) {
			return undefined;
		} else if (lowerBound != parseInt(lowerBound)) {
			eden.error(new Error("randomInteger: The lower bound must be an int, not a float."), "error");
			return undefined;
		} else if (typeof(upperBound) != "number") {
			eden.error(new Error("randomInteger: The upper bound must be an int, not a " + typeof(upperBound)), "error");
			return undefined;
		} else if (isNaN(upperBound)) {
			return undefined;
		} else if (upperBound != parseInt(upperBound)) {
			eden.error(new Error("randomInteger: The uppe bound must be an int, not a float."), "error");
			return undefined;
		}
		
		var n = Math.floor(Math.random() * (upperBound - lowerBound + 1) + lowerBound);
		if (n > upperBound) {
			// 1 / 2^62 chance
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
			n = upperBound;
		}
		return n;
	}}$;
}

func random {
  return ${{ Math.random(); }}$;
}

func round {
  para num, places;
  auto i;

  for (i = 1; i <= places; i++) {
    num = num*10;
  }

  num = int(num);

  for (i = 1; i <= places; i++) {
    num = num/10;
  }

  return num;
}

func sin {
  return ${{ Math.sin(arguments[0]*Math.PI/180); }}$;
}

func sqrt {
  return ${{ Math.sqrt(arguments[0]); }}$;
}

func tan {
  return ${{ Math.tan(arguments[0]*Math.PI/180); }}$;
}
