## Copyright (c) 2013, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt

PI = ${{ Math.PI }}$;
radiansPerUnit is PI / 180;

func abs {
  return ${{ Math.abs(arguments[0]); }}$;
}

func acos {
  return ${{ Math.acos(arguments[0]) }}$ / radiansPerUnit;
}

func asin {
  return ${{ Math.asin(arguments[0]) }}$ / radiansPerUnit;
}

func atan {
  return ${{ Math.atan(arguments[0]) }}$ / radiansPerUnit;
}

func ceil {
	${{
		if (arguments.length == 0 || arguments.length > 2) {
			eden.error(new Error("ceil: This function requires at least 1 argument and at most 2 arguments."), "error");
			return undefined;
		}
		
		var number = arguments[0];
		if (number === undefined) {
			return undefined;
		} else if (typeof(number) != "number") {
			eden.error(new Error("round: The first argument must be a number, not a " + typeof(number)), "error");
			return undefined;
		}

		var multiple;
		if (arguments.length == 2) {
			multiple = arguments[1];
		} else {
			multiple = 1;
		}
		
		if (multiple !== 1) {
			if (multiple === undefined) {
				return undefined;
			} else if (typeof(multiple) != "number") {
				eden.error(new Error("round: The second argument must be a number, not a " + typeof(multiple)), "error");
				return undefined;
			} else {
				var divided = number / multiple;
				var truncated = parseInt(divided);
				if (divided == truncated) {
					return number;
				} else {
					return (truncated + 1) * multiple;
				}
			}
		} else {
			return Math.ceil(number);
		}
	}}$;
}

func cos {
  return ${{ Math.cos(arguments[0]*root.lookup("radiansPerUnit").value()); }}$;
}

func exp {
  return ${{ Math.exp(arguments[0]); }}$;
}

func floor {
	${{
		if (arguments.length != 2) {
			eden.error(new Error("floor: This function requires exactly 2 arguments."), "error");
			return undefined;
		}
		
		var number = arguments[0];
		if (number === undefined) {
			return undefined;
		} else if (typeof(number) != "number") {
			eden.error(new Error("floor: The first argument must be a number, not a " + typeof(number)), "error");
			return undefined;
		}

		var multiple = arguments[1];
		
		if (multiple === undefined) {
			return undefined;
		} else if (typeof(multiple) != "number") {
			eden.error(new Error("floor: The second argument must be a number, not a " + typeof(multiple)), "error");
			return undefined;
		} else {
			return parseInt(number / multiple) * multiple;
		}
	}}$;
}

func log {
  return ${{ Math.log(arguments[0]); }}$;
}

##The same remarks apply as for min, mutatis mutandis.
func max {
	auto list, i, maxSoFar;

	if ($# == 0) {
		return @;
	} else if ($# == 1 && type($[1]) == "list") {
		list = $[1];
		if (list# == 0) {
			return @;
		}
	} else {
		list = $;
	}

	maxSoFar = list[1];	
	for (i = 2; i <= list#; i++) {
		if (list[i] > maxSoFar) {
			maxSoFar = list[i];
		}
	}
	return maxSoFar;
}

##If exactly one argument is provided and it is the empty list then undefined
##is returned.  tkeden produces an error message.
##
##If two or more list type arguments are provided then they are compared
##lexicographically, e.g. min([2], [1,2]) is [1,2].  tkeden returns the lowest
##value from the first list in this scenario.  If exactly one argument is
##provided and it is a list then the lowest value from that list is returned,
##the same as in tkeden.
##
##min(@, 2) returns @ but min(2, @) returns 2.  This is bizarre but consistent
##with tkeden.
##
func min {
	auto list, i, minSoFar;

	if ($# == 0) {
		return @;
	} else if ($# == 1 && type($[1]) == "list") {
		list = $[1];
		if (list# == 0) {
			return @;
		}
	} else {
		list = $;
	}
	
	minSoFar = list[1];

	for (i = 2; i <= list#; i++) {
		if (list[i] < minSoFar) {
			minSoFar = list[i];
		}
	}
	return minSoFar;
}

func mod {
	para x, n;
	return x>=0? x % n : (n + (x % n));
}

func pow {
  return ${{ Math.pow(arguments[0],arguments[1]); }}$;
}

func randomInteger {
	${{
		if (arguments.length != 2) {
			eden.error(new Error("randomInteger: This function requires exactly 2 arguments"), "error");
			return undefined;
		}
		
		var lowerBound = arguments[0];
		var upperBound = arguments[1];

		if (lowerBound === undefined || upperBound === undefined) {
			return undefined;
		} else if (typeof(lowerBound) != "number") {
			eden.error(new Error("randomInteger: The lower bound must be an int, not a " + typeof(lowerBound)), "error");
			return undefined;
		} else if (isNaN(lowerBound)) {
			return undefined;
		} else if (lowerBound != parseInt(lowerBound)) {
			eden.error(new Error("randomInteger: The lower bound must be an int, not a float."), "error");
			return undefined;
		} else if (typeof(upperBound) != "number") {
			eden.error(new Error("randomInteger: The upper bound must be an int, not a " + typeof(upperBound)), "error");
			return undefined;
		} else if (isNaN(upperBound)) {
			return undefined;
		} else if (upperBound != parseInt(upperBound)) {
			eden.error(new Error("randomInteger: The upper bound must be an int, not a float."), "error");
			return undefined;
		}
		
		var n = Math.floor(Math.random() * (upperBound - lowerBound + 1) + lowerBound);
		if (n > upperBound) {
			// 1 / 2^62 chance
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
			n = upperBound;
		}
		return n;
	}}$;
}

func random {
  return ${{ Math.random(); }}$;
}

func round {
	${{
		if (arguments.length == 0 || arguments.length > 2) {
			eden.error(new Error("round: This function requires at least 1 argument and at most 2 arguments."), "error");
			return undefined;
		}
		
		var number = arguments[0];
		if (number === undefined) {
			return undefined;
		} else if (typeof(number) != "number") {
			eden.error(new Error("round: The first argument must be a number, not a " + typeof(number)), "error");
			return undefined;
		}

		var decimalPlaces;
		if (arguments.length == 2) {
			decimalPlaces = arguments[1];
		} else {
			decimalPlaces = 0;
		}
		
		if (decimalPlaces !== 0) {
			if (decimalPlaces === undefined) {
				return undefined;
			} else if (typeof(decimalPlaces) != "number") {
				eden.error(new Error("round: The second argument must be an int, not a " + typeof(decimalPlaces)), "error");
				return undefined;
			} else if (decimalPlaces != parseInt(decimalPlaces) && !isNaN(decimalPlaces)) {
				eden.error(new Error("round: The second argument must be an int, not a float"), "error");
				return undefined;
			} else {
				var multiplier = Math.pow(10, decimalPlaces);
				return Math.round(number * multiplier) / multiplier;
			}
		} else {
			return Math.round(number);
		}
	}}$;
}

func sin {
  return ${{ Math.sin(arguments[0]*root.lookup("radiansPerUnit").value()); }}$;
}

func sqrt {
  return ${{ Math.sqrt(arguments[0]); }}$;
}

func tan {
  return ${{ Math.tan(arguments[0]*root.lookup("radiansPerUnit").value()); }}$;
}

