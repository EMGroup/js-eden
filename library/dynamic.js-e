## Copyright (c) 2014, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt
##
##Functions and procedures that allow EDEN code to inspect, manipulate and
##construct parts of scripts at runtime.


##alias(y, x) makes the identifier y an alias for the identifier x.  It's
##similar to definition "y is x" except that if y is subsequently redefined or
##assigned to then x inherits y's new definition or assigned value.  Thus the
##aliasing operation also simultaneously acts like the definition "x is y".
##This procedure is used when combining two construals to produce a larger
##construal where the component construals share a common concept but use
##different observable names to refer to that concept.
proc alias {
	${{
		if (arguments.length != 2) {
			eden.error(new Error("alias: This procedure requires exactly two arguments."), "error");
		}
		
		var dest = arguments[0];
		var source = arguments[1];
		
		if (typeof(dest) != "string") {
			eden.error(new Error("alias: The first argument must be a string, not a " + typeof(dest)), "error");
		}
		
		if (typeof(source) == "string") {
			source = root.lookup(source);
		} else if (!(source instanceof Symbol)) {
			eden.error(new Error("alias: The second argument must be a string or a pointer, not a " + typeof(source)), "error");
		}
		
		root.symbols[dest] = source;
	}}$;
}

##This function is the reverse of execute.  Given pointer or a string that names
##an observable it returns the code used to define the observable that is named
##or being pointed to, that is, this function returns the text of the most
##recent assignment or "is" statement that determines the observable's current
##value.
func definitionOf {
	${{
		if (arguments.length != 1) {
			eden.error(new Error("definitionOf: This function requires exactly 1 argument."), "error");
			return undefined;
		}
		
		var observable = arguments[0];
		var name, symbol
		if (observable === undefined) {
			return undefined;
		} else if (observable instanceof Symbol) {
			symbol = observable;
			name = symbol.name.slice(1);
		} else if (typeof(observable) == "string") {
			name = observable;
			symbol = root.lookup(name);		
		} else {
			eden.error(new Error("definitionOf: The argument must be a pointer or a string, not a " + typeof(observable)), "error");
			return undefined;
		}
		
		if (symbol.eden_definition !== undefined && symbol.definition !== undefined) {
			return symbol.eden_definition + ";";
		} else {
			return name + " = " + root.lookup("edenCode").definition(root)(symbol.cached_value) + ";";
		}
	}}$;
}

##Similar to definitionOf but the result only includes the right-hand side of
##the definition and excludes the terminating semi-colon.
##E.g. if an observable b is defined as:
## b is a + 3;
##then definitionOf("b") returns "b is a + 3;" and definitionRHS("b") returns "a + 3".
func definitionRHS {
	${{
		if (arguments.length != 1) {
			eden.error(new Error("definitionRHS: This function requires exactly 1 argument."), "error");
			return undefined;
		}
		
		var observable = arguments[0];
		var name, symbol
		if (observable === undefined) {
			return undefined;
		} else if (observable instanceof Symbol) {
			symbol = observable;
			name = symbol.name.slice(1);
		} else if (typeof(observable) == "string") {
			name = observable;
			symbol = root.lookup(name);		
		} else {
			eden.error(new Error("definitionRHS: The argument must be a pointer or a string, not a " + typeof(observable)), "error");
			return undefined;
		}

		if (symbol.eden_definition !== undefined && symbol.definition !== undefined) {
			var lhsRegExp = new RegExp("^\\s*" + name + "\\s+is\\s+", "");
			var rhs = symbol.eden_definition.replace(lhsRegExp, "");
			rhs = rhs.replace(/^\[\s*\]/, "[]");
			rhs = rhs.replace(/\[\s*\]$/, "[]");
			return rhs;
		} else {
			return root.lookup("edenCode").definition(root)(symbol.cached_value);
		}	
	}}$;
}

##Given a value, this function returns the string representing the simplest
##EDEN code that evaluates as that value.  For example, edenCode applied to a
##string is the string formed by adding quotes to the original string.
func edenCode {
	${{
		if (arguments.length != 1) {
			eden.error(new Error("edenCode: This function requires exactly 1 argument."), "error");
			return undefined;
		}
		var value = arguments[0];
		var type = typeof(value);
		var code = "";
		if (type == "undefined") {
			code = "@";
		} else if (value === null) {
			code = "$" + "{{ null }}" + "$";
		} else if (type == "string") {
			code = "\"" + value + "\"";
		} else if (Array.isArray(value)) {
			code = "[";
			for (var i = 0; i < value.length - 1; i++) {
				code = code + root.lookup("edenCode").definition(root)(value[i]) + ", ";
			}
			if (value.length > 0) {
				code = code + root.lookup("edenCode").definition(root)(value[value.length - 1]);
			}
			code = code + "]";
		} else if (type == "object") {
			if (value instanceof Symbol) {	
				code = "&" + value.name.slice(1);
			} else if (
				"keys" in value &&
				Array.isArray(value.keys) &&
				value.keys.length > 0 &&
				typeof(value.keys[0]) == "number" &&
				"parent" in value &&
				value.parent instanceof Symbol
			) {
				code = "&" + value.parent.name.slice(1) + "[" + value.keys[0].toString() + "]";
			} else {
				code = "{";
				for (var key in value) {
					code = code + key + ": " + root.lookup("edenCode").definition(root)(value[key]) + ", ";
				}
				if (code != "{") {
					code = code.slice(0, -2);
				}
				code = code + "}";
			}
		} else if (type == "function") {
			code = "$" +"{{ " + value.toString() + " }}" + "$";
		} else {
			code = value.toString();
		}
		return code;
	}}$;
}

##This procedure inspects the current definition of a list observable and
##redefines the observable such that its new definition is like the old one but
##with an extra item (or items) added onto the end of the list.  It is similar
##to append but append is shorthand for an assignment whereas withAppendedItem
##is shorthand for a dependency definition.  The first argument is a string or a
##pointer identifying the observable to be redefined.  The second argument is
##a string containing EDEN code for defining the new item(s).
##
##Examples:
## list is [a];
## b = 2;
##
## For each example begin in the state defined above.
##
##Example 1:
##	withAppendedItem(&list, "b");
##Equivalent to executing: list is [a, b];
##
##Example 2:
##	withAppendedItem(&list, "b, a + b");
##Equivalent to executing list is [a, b, a + b];
##
##Example 3:
##	withAppendedItem(&list, edenCode(b));
##Equivalent to executing list is [a, 2];
##(withAppendedItem deliberately rejects non-string values to avoid accidentally
##freezing the current value of the appended expression.)
##
proc withAppendedItem {
	para target, appendItem;
	auto listObs, oldRHS, currentValue, last2Chars;
	
	if ($# != 2) {
		error("withAppendedItems: This procedure requires at exactly 2 arguments.");
		return @;
	} else if (isString($[1])) {
		oldRHS = definitionRHS($[1]);
		listObs = $[1];
		currentValue = `listObs`;
	} else if (isPointer($[1])) {
		oldRHS = definitionRHS($[1]);
		listObs = nameof($[1]);
		currentValue = *($[1]);
	} else {
		error("withAppendedItem: The first argument must be a string or a pointer, not a " // type($[1]));
		return @;
	}
	
	if (currentValue != @ && !isList(currentValue)) {
		error("withAppendedItem: " // listObs // " must be a list type observable, not a " // type(currentValue) // " observable.");
		return @;
	}
	
	if (!isString(appendItem)) {
		error("withAppendedItem: The second argument must be a string, not a " // type(appendItem));
		return @;
	}

	if (oldRHS# >= 2) {
		last2Chars = substr(oldRHS, oldRHS# - 1, oldRHS#);
	} else {
		last2Chars = @;
	}

	if (oldRHS == "@" || oldRHS == "[]") {
		execute(listObs // " is [" // appendItem // "];");
	} else if (last2Chars != @ && last2Chars[2] == "]" && last2Chars[1] != "[") {
		##Use a comma instead of ] // [
		execute(listObs // " is " // substr(oldRHS, 1, oldRHS# - 1) // ", " // appendItem // "];");	
	} else {
		execute(listObs // " is " // oldRHS // " // [" // appendItem // "];");
	}
}
