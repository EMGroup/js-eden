## Copyright (c) 2014, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt
##
##Functions that operate on strings.

##Concatenates a collection of values, separating each one by a given
##separator string or separator element.  The values can either be provided as
##multiple arguments or alternatively as a single list type argument.
##
##Basically you can pass to this function any list of values that you want to
##munge together and it will attempt to figure out what you meant.
##
##Case 1: separator + a list of strings
##	The strings are concatenated, separated by the separator.  If the separator
##	is undefined and there are two more strings then undefined is returned.  If
##	the separator is defined but is not a string then it is automatically
##	converted into a string.
##
##Case 2: separator + a list of lists
##	The lists are concatenated, separated by the single separator element.
##
##Case 3: separator + a list of things that are not all lists but are all defined
##	Any list items that are not strings are converted into strings, then as Case 1.
##
##Case 4: separator + a list containing the undefined value
##	Undefined is returned.
##
##Case 5: separator + one or more further arguments that are all strings
##	The strings are concatenated, separated by the separator.
##
##Case 6: separator + two or more further arguments that are all lists
##	The lists are concatenated, separated by the single separator element.
##
##Case 7: separator + one or more further arguments that are not all lists but are all defined
##	Any arguments that are not strings are converted into strings, then as Case 5.
##
##Case 8: separator + one or more further arguments, at least one of which is undefined
##	Undefined is returned.
##
##Case 9: separator only (zero further arguments)
##	The empty string is returned.
##
func concat {
	auto separator, concatStrings, list, i, item, result;
	if ($# < 1) {
		error("concat: This function requires at least one argument.");
		return @;
	}

	if ($# == 2 && type($[2]) == "list") {
		list = $[2];
	} else {
		list = sublist($, 2, $#);
	}
	
	if (list# == 0) {
		return "";
	}
	
	separator = $[1];
	concatStrings = false;
	for (i = 1; i <= list#; i++) {
		if (list[i] == @) {
			return @;
		} else if (!isList(list[i])) {
			concatStrings = true;
			break;
		}
	}
	
	if (concatStrings) {
		if (separator == @) {
			if (list# > 1) {
				return @;
			}
		} else {
			separator = str(separator);
		}
		result = "";
	} else {
		separator = [separator];
		result = [];
	}
	
	for (i = 1; i < list#; i++) {
		if (concatStrings) {
			item = str(list[i]);
		} else {
			item = list[i];
		}
		result = result // item // separator;
	}
	if (list# > 0) {
		if (concatStrings) {
			item = str(list[list#]);
		} else {
			item = list[list#];
		}
		result = result // item;
	}
	return result;
}

func strcat {
	auto result, i;
	result = "";
	for (i = 1; i <= $#; i++) {
		if ($[i] == @) {
			return @;
		} else if (isString($[i])) {
			result = result // $[i];
		} else {
			error("strcat: Argument " // str(i) // " must be a string, not a " // type($[i]));
			return @;
		}
	}
	return result;
}

##The same issues arise as with the sublist function (in lists.js-e) and they're handled in the
##same way.
func substr {
	${{
		if (arguments.length < 2 || arguments.length > 3) {
			eden.error(new Error("substr: this function requires a minimum of 2 arguments and a maximum of 3 arguments."), "error");
			return undefined;
		}
		
		var str = arguments[0];
		var from = arguments[1];
		var to = arguments[2];
		
		if (str === undefined) {
			return undefined;
		}
		if (typeof(str) != "string") {
			eden.error(new Error("substr: expected string but got " + typeof(str)), "error");
			return undefined;
		}
		if (from === undefined) {
			from = 1;
		} else if (from > to) {
			return "";
		}
		if (from > 0) {
			from = from - 1;
		} else if (from == 0) {
			eden.error(new Error("substr: from cannot be 0."), "error");
			return undefined;
		}
		if (to == 0) {
			eden.error(new Error("substr: to cannot be 0."), "error");		
		} else if (to < 0) {
			to = to + 1;
			if (to == 0) {
				to = str.length;
			}
		}
		
		var result = str.slice(from, to);
		
		if (to > str.length) {
			result = result + Array(to - str.length + 1).join(" ");
		}
		
		return result;
	}}$;
}
