## Copyright (c) 2014, Empirical Modelling Group
## All rights reserved.
##
## See LICENSE.txt
##
##Functions commonly found in or inspired by functional programming languages.

func compose {
	${{
		var functions;

		if (arguments.length == 1 && Array.isArray(arguments[0])) {
			functions = arguments[0];
		} else {
			functions = arguments;
		}
		
		//Return the identity function if a zero length list of functions are composed.
		if (functions.length == 0) {
			return function () {
				if (arguments.length == 1) {
					return arguments[0];
				} else {
					return Array.prototype.slice.call(arguments);
				}
			};
		}
		
		for (var i = 0; i < functions.length; i++) {
			if (typeof(functions[i]) != "function") {
				eden.error(new Error("compose: Item " + i.toString() + " must be a func, not a " + typeof(functions[i])), "error");
				return undefined;
			}
		}
		
		if (functions.length == 1) {
			return functions[0];
		} else {
			return function () {
				var result = functions[0].apply(this, Array.prototype.slice.call(arguments));
				for (var i = 1; i < functions.length; i++) {
					result = functions[i](result);
				}
				return result;
			};
		}
	}}$;
}

func foldl {
	auto f, initialValue, list, i, value;
	if ($# < 2) {
		error("foldl: This function requires at least 2 arguments.");
		return @;
	} else if ($# == 3 && $[2] == @) {
		return @;
	} else if ($# == 3 && type($[2]) == "list") {
		f = $[1];
		initialValue = $[2];
		list = $[3];
	} else {
		f = $[1];
		initialValue = $[2];
		list = sublist($, 3, $#);
	}
	
	if (f == @) {
		return @;
	} else if (type(f) != "func") {
		error("foldl: The first argument must be a function, not a " // type(f));
		return @;
	}
	
	value = initialValue;
	for (i = 1; i <= list#; i++) {
		value = f(value, list[i]);
	}
	return value;
}

func foldr {
	auto f, initialValue, list, i, value;
	if ($# < 2) {
		error("foldr: This function requires at least 2 arguments.");
		return @;
	} else if ($# == 3 && $[2] == @) {
		return @;
	} else if ($# == 3 && type($[2]) == "list") {
		f = $[1];
		initialValue = $[2];
		list = $[3];
	} else {
		f = $[1];
		initialValue = $[2];
		list = sublist($, 3, $#);
	}
	
	if (f == @) {
		return @;
	} else if (type(f) != "func") {
		error("foldr: The first argument must be a function, not a " // type(f));
		return @;
	}

	value = initialValue;
	for (i = list#; i >= 1; i--) {
		value = f(value, list[i]);
	}
	return value;
}

##This function is useful in conjunction with compose.  It converts an argument
##list (a, b, c,...) into a list [a, b, c,...].
func List {
	return $;
}

func map {
	auto f, list, result, i;
	if ($# == 0) {
		error("map: This function requires at least 1 argument.");
		return @;
	} else if ($# == 2 && $[2] == @) {
		return @;
	} else if ($# == 2 && type($[2]) == "list") {
		f = $[1];
		list = $[2];	
	} else {
		f = $[1];
		list = sublist($, 2, $#);
	}

	if (f == @) {
		return array(list#);
	} else if (type(f) != "func") {
		error("map: The first argument must be a function, not a " // type(f));
		return @;
	}
	
	result = [];
	for (i = 1; i <= list#; i++) {
		append result, f(list[i]);
	}
	return result;
}

func mapPartial {
	auto f, list, result, i;
	if ($# == 0) {
		error("mapPartial: This function requires at least 1 argument.");
		return @;
	} else if ($# == 2 && $[2] == @) {
		return @;
	} else if ($# == 2 && type($[2]) == "list") {
		f = $[1];
		list = $[2];	
	} else {
		f = $[1];
		list = sublist($, 2, $#);
	}

	if (f == @) {
		return array(list#);
	} else if (type(f) != "func") {
		error("mapPartial: The first argument must be a function, not a " // type(f));
		return @;
	}
	
	result = [];
	for (i = 1; i <= list#; i++) {
		if (list[i] == @) {
			append result, @;
		} else {
			append result, f(list[i]);
		}
	}
	return result;
}

##Similar to currying, except that any combination of arguments can be applied
##to produce a partially instantiated function, not just the leftmost argument.
##
##Example:
##
##	g = partApply(f, 1, "A", 3, "B");
##	g("C", "D") is equivalent to f("A", "C", "B", D")
##
##	Can also be written as g = partApply(f, [1, "A", 3, "B"]);
##
func partApply {
	${{
		var argMap;
		if (arguments.length < 2) {
			eden.error(new Error("partApply: This function requires at least 2 arguments."), "error");
			return undefined;
		} else if (arguments.length == 2) {
			if (Array.isArray(arguments[1])) {
				argMap = arguments[1].slice();
			} else {
				eden.error(new Error("partApply: The second argument must be a list or an int, not a " + typeof(arguments[1])), "error");
				return undefined;			
			}
		} else if (arguments.length % 2 == 1) {
			argMap = Array.prototype.slice.call(arguments, 1);
		} else {
			eden.error(new Error("partApply: This function requires exactly 2 arguments or an odd number of arguments, not " + arguments.length.toString() + " arguments."), "error");
			return undefined;		
		}
		
		for (var i = 0; i < argMap.length; i = i + 2) {
			if (typeof(argMap[i]) != "number") {
				eden.error(new Error("partApply: Argument" + (i+1).toString() + " must be an int, not a " + typeof(argMap[i])), "error");
				return undefined;
			} else if (isNaN(argMap[i])) {
				eden.error(new Error("partApply: Argument" + (i+1).toString() + " must be a int, not a NaN."), "error");
				return undefined;
			} else if (argMap[i] != parseInt(argMap[i])) {
				eden.error(new Error("partApply: Argument" + (i+1).toString() + " must be a int, not a float."), "error");
				return undefined;			
			} else if (argMap[i] < 1) {
				eden.error(new Error("partApply: Argument" + (i+1).toString() + " must be greater than zero, not " + argMap[i].toString()), "error");
				return undefined;
			}
		}
		
		var f = arguments[0];
		if (typeof(f) != "function") {
			eden.error(new Error("partApply: The first argument must be a func, not a " + typeof(f)), "error");
			return undefined;			
		}

		
		return function () {
			var fArgs = Array(argMap.length / 2);
			var filledArgs = Array(argMap.length / 2);
			
			for (var i = 0; i < argMap.length; i = i + 2) {
				fArgs[argMap[i] - 1] = argMap[i + 1];
				filledArgs[argMap[i] - 1] = true;
			}
			
			var slot = 0;
			var argNum = 0;
			while (slot < filledArgs.length && argNum < arguments.length) {
				if (filledArgs[slot] != true) {
					fArgs[slot] = arguments[argNum];
					argNum++;
				}
				slot++;
			}
			while (argNum < arguments.length) {
				fArgs[slot] = arguments[argNum];
				argNum++;
				slot++;
			}
			return f.apply(this, fArgs);
		}
	}}$;
}
