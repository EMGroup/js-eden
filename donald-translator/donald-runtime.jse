donaldPicture = [];
donaldPictureNames = ${{ Object.create(null) }}$;

proc declDonald {
  ${{
  var elName = arguments[0];
  var donaldPictureNames = context.lookup('donaldPictureNames').value();
  var donaldPicture = context.lookup('donaldPicture').value();
  if (donaldPictureNames[elName]) { return; }
  donaldPictureNames[elName] = true;
  donaldPicture.push(elName);
  }}$;
}

proc drawPicture {
  ${{
  var donaldPicture = context.lookup('donaldPicture').value();
  var canvas = document.getElementById('donald-canvas');
  canvas.width = canvas.width;
  var height = canvas.height;
  var drawingContext = canvas.getContext('2d');

  for (var i = 0; i < donaldPicture.length; ++i) {
    var el = root.lookup(donaldPicture[i]).value();
    if (!el) { continue; }
    if (el[0] === 'C') {
      drawingContext.fillRect(el[1], height - el[2], 1, 1);
    } else if (el[0] === 'L') {
      drawingContext.beginPath();
      drawingContext.moveTo(el[1][1], height - el[1][2]);
      drawingContext.lineTo(el[2][1], height - el[2][2]);
      drawingContext.stroke();
    } else if (el[0] === 'U') {
      drawingContext.beginPath();

      var a = ['C', el[1][1], height - el[1][2]];
      var b = ['C', el[2][1], height - el[2][2]];
      var angle = el[3];
      var diff = ['C', b[1] - a[1], b[2] - a[2]];
      var mid = ['C', a[1] + diff[1] / 2, a[2] + diff[2] / 2];
      var diffmag = Math.sqrt(diff[1]*diff[1] + diff[2]*diff[2]);

      // which direction normal is the correct normal?
      var normal = ['C', -diff[2] / diffmag, diff[1] / diffmag];
      var radius = diffmag / Math.sin(angle * Math.PI / 180) * Math.sin((90 - angle) * Math.PI / 180);

      var halfDiffMagSquared = diff[1] / 2 * diff[1] / 2 + diff[2] / 2 * diff[2] / 2;
      var radiusSquared = radius * radius;
      var height = Math.sqrt(halfDiffMagSquared + radiusSquared);
      var scaledNormal = ['C', normal[1] * height, normal[2] * height];
      var centre = ['C', mid[1] + scaledNormal[1], mid[2] + scaledNormal[2]];

      // TODO(trmonks) figure out starting angle
      var startAngle = 0;

      console.log('draw arc!',
        centre[1],
        centre[2],
        radius,
        startAngle * Math.PI / 180,
        (startAngle + angle) * Math.PI / 180
      );
      drawingContext.arc(
        centre[1],
        centre[2],
        radius,
        startAngle * Math.PI / 180,
        startAngle + angle * Math.PI / 180
      );
      drawingContext.stroke();
    }
  }

  }}$;
}

CART = 'C';
LINE = 'L';
ARC = 'U';
POLAR = 'P';

func cart {
  return [CART, $1, $2];
}

func polar {
  return [POLAR, $1, $2];
}

func line {
  return [LINE, $1, $2];
}

func arc {
  return [ARC, $1, $2, $3];
}

func float {
  return $1;
}

func int {
	return ${{ Math.floor(arguments[0]) }}$;
}

func sqrt {
  return ${{ Math.sqrt(arguments[0]) }}$;
}

func atan2 {
  return ${{ Math.sqrt(arguments[0], arguments[1]) }}$;
}

func cos {
  return ${{ Math.cos(arguments[0]) }}$;
}

func sin {
  return ${{ Math.sin(arguments[0]) }}$;
}

func cart_to_polar {
	para cart;
	if (idv(cart)) return @;
	if (cart[1] == POLAR) return cart;
	if (cart[1] != CART) error("argument is not in cart coordinate");
	cart[2] = float(cart[2]);
	cart[3] = float(cart[3]);
	if (cart[2] == 0.0 && cart[3] == 0.0)
		return [POLAR, 0.0, 0.0];
	return [POLAR, sqrt(cart[2]*cart[2]+cart[3]*cart[3]),
		atan2(cart[3], cart[2])];
}

func polar_to_cart {
	para polar;
	if (idv(polar)) return @;
	if (polar[1] == CART) return polar;
	if (polar[1] != POLAR) error("argument is not in polar coordinate");
	return [CART,
		polar[2] * cos(float(polar[3])),
		polar[2] * sin(float(polar[3]))];
}

func type {
  return "notlist";
}

/* check for ill-defined value
   argument: list
   return:
	   0 if all terms are well-defined
	   1 if partly undefined */
func idv
{
	para	d;
	auto	i;
	
	if (d == @) return 1;
	if (type(d) != "list")
		return 0;
	for (i = d#; i > 0; --i) {
		if (idv(d[i]))
			return 1;
	}
	return 0;
}

func vector_sub
{
	para	point1, point2;

	if (idv(point1) || idv(point2)) return @;
	if (point1[1] == POLAR) point1 = polar_to_cart(point1);
	if (point2[1] == POLAR) point2 = polar_to_cart(point2);
	return [CART, point1[2] - point2[2], point1[3] - point2[3]];
}

PI = ${{ Math.PI }}$;
